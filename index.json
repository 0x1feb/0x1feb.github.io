[{"content":"概要 Android アプリを作ってみたくなったので、チュートリアルを試してみた結果をメモとして残す。\n準備  Kotlin の基礎知識があること。 Android Studio がインストールされていること。 実機でアプリを動かす場合は確認用の Android 端末があること。  サンプルアプリの作成 テンプレートからプロジェクトを作成する  Android Studio を起動し、[New Project] をクリックする。 [Phone and Tablet] を選択し、[Empty Compose Activity] を選択する。 [Next] をクリックする。 以下を入力する。  Name: GreetingCard Package name: com.example.greetingcard Save location: 任意のパス Language: Kotlin (固定) Minimum SDK: API 21: Android 5.0 (Lollipop)   [Finish] をクリックする。  読み込みが終わるまで時間がかかるのでしばらく待つと、テンプレートを使用したプロジェクトが作成される。\nテキスト/デザインを更新する   MainActivity.kt の Greeting() を次のように変更する。\n@Composable fun Greeting(name: String) { Text(text = \u0026#34;Hi, my name is $name!\u0026#34;) }   Greeting() を呼び出すときの引数を任意の名前に変更する。\nGreeting(\u0026#34;rano\u0026#34;)   Text... の行をハイライト表示し、Alt + Enter を押して、[Surround with widget] を選択する。\n@Composable fun Greeting(name: String) { Box { Text(text = \u0026#34;Hi, my name is $name!\u0026#34;) } }   Box を Surface() に変更する。\n@Composable fun Greeting(name: String) { Surface() { Text(text = \u0026#34;Hi, my name is $name!\u0026#34;) } }   color パラメータを追加する。（ここでは青を指定）\n... import androidx.compose.ui.graphics.Color ... @Composable fun Greeting(name: String) { Surface(color = Color.Blue) { Text(text = \u0026#34;Hi, my name is $name!\u0026#34;) } }   パディングを追加する。\n... import androidx.compose.foundation.layout.padding ... import androidx.compose.ui.unit.dp ... @Composable fun Greeting(name: String) { Surface(color = Color.Blue) { Text(text = \u0026#34;Hi, my name is $name!\u0026#34;, modifier = Modifier.padding(24.dp)) } }   以上で簡単なカスタマイズが完了した。\n実機での動作確認 開発用デバイスをセットアップする デバイスとの接続は、USB 接続と Wi-Fi 接続の2種類あるが、今回は Wi-Fi 経由で接続する。\n デバイスの設定アプリより、[開発者向けオプション] を選択し、[ワイヤレス デバッグ] を有効にする。  デバイスの開発者向けオプションを設定する ｜ Android デベロッパー ｜ Android Developers    デバイスに接続する  実行構成のプルダウンメニューから [Pair Devices Using Wi-Fi] を選択する。 デバイスの設定アプリより、[開発者向けオプション] を選択し、[ワイヤレス デバッグ] を選択する。 [QR コードによるデバイスのペア設定] を選択し、QR コードを読み取る。 ペアリングしたら対象のデバイスを選択し、[Run \u0026lsquo;app\u0026rsquo;] のアイコンをクリックする。 実機端末にサンプルアプリが表示される。  基本はエミュレータでの確認で問題ないと思うが、実際の操作感を確認したい場合は実機を使うのが良い。\n参考  初めてのアプリを作成する ｜ Android デベロッパー ｜ Android Developers ハードウェア デバイス上でのアプリの実行 ｜ Android デベロッパー ｜ Android Developers  ","permalink":"https://0x1feb.github.io/posts/2023/01/03/basic-android-kotlin-compose-first-app/","summary":"概要 Android アプリを作ってみたくなったので、チュートリアルを試してみた結果をメモとして残す。 準備 Kotlin の基礎知識があること。 Android Studio がインストールされてい","title":"Android アプリ入門"},{"content":"挿入ソートとは、未ソートの部分から取り出した要素を、ソート済みの部分の適切な位置に挿入するソートアルゴリズムである。\nソースコード #include \u0026lt;bits/stdc++.h\u0026gt;#define rep(i, n) for (int i = 0; i \u0026lt; (n); ++i) using namespace std; using vi = vector\u0026lt;int\u0026gt;; void print_list(vi A, int n) { rep(i, n) cout \u0026lt;\u0026lt; (i \u0026gt; 0 ? \u0026#34; \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; A[i]; cout \u0026lt;\u0026lt; endl; } void insertion_sort(vi \u0026amp;A, int n) { rep(i, n - 1) { // i番目までソート済み  // i+1番目の要素を挿入対象とする  int tmp = A[i + 1]; // 整列済みの要素 (A[j], A[j-1], ..., A[0]) の中で適切な挿入位置を探す  int j = i; while (j \u0026gt;= 0 \u0026amp;\u0026amp; A[j] \u0026gt; tmp) { A[j + 1] = A[j]; j--; } A[j + 1] = tmp; print_list(A, n); } } int main() { int n; cin \u0026gt;\u0026gt; n; vi A(n); rep(i, n) cin \u0026gt;\u0026gt; A[i]; insertion_sort(A, n); return 0; } 実行した結果は以下のとおり。\n// 入力 8 8 4 3 7 6 5 2 1 // 出力 4 8 3 7 6 5 2 1 (1回目のループ終了時) 3 4 8 7 6 5 2 1 (2回目のループ終了時) 3 4 7 8 6 5 2 1 (3回目のループ終了時) 3 4 6 7 8 5 2 1 (4回目のループ終了時) 3 4 5 6 7 8 2 1 (5回目のループ終了時) 2 3 4 5 6 7 8 1 (6回目のループ終了時) 1 2 3 4 5 6 7 8 (7回目のループ終了時) 解説 以下の操作を繰り返すことでソートする。\n 0番目の要素を整列済みの配列とし、1番目の要素を適切な位置に挿入する。 0番目と1番目までの配列は整列済みなので、2番目の要素を適切な位置に挿入する。 上記操作を配列の最後の要素まで繰り返すと、配列全体が整列する。  挿入対象となる値は tmp に格納し、適切な位置が見つかるまで A[j + 1] = A[j] で整列済みの配列の要素を後ろにずらす。\nループの条件を抜けたときの j + 1 が挿入位置となるため、A[j + 1] = tmp で挿入する。\n最悪の場合、 $i$ ループの各処理が $i$ 回行われるため、計算量は $O(n^{2})$ となる。\n参考  挿入ソート - Wikipedia  ","permalink":"https://0x1feb.github.io/posts/2022/12/29/insertion-sort/","summary":"挿入ソートとは、未ソートの部分から取り出した要素を、ソート済みの部分の適切な位置に挿入するソートアルゴリズムである。 ソースコード #include \u0026lt;bits/stdc++.h\u0026gt;#define rep(i, n) for (int","title":"挿入ソート (Insertion sort)"},{"content":"ユークリッドの互除法とは、2つの自然数の最大公約数を求めるアルゴリズムである。\nソースコード #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int gcd(int a, int b) { return (b == 0 ? a : gcd(b, a % b)); } int main() { cout \u0026lt;\u0026lt; gcd(1071, 1029) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; gcd(1029, 1071) \u0026lt;\u0026lt; endl; return 0; } 出力結果は以下の通り。\n21 21 参考  ユークリッドの互除法 - Wikipedia - Wikipedia  ","permalink":"https://0x1feb.github.io/posts/2022/12/27/euclidean-algorithm/","summary":"ユークリッドの互除法とは、2つの自然数の最大公約数を求めるアルゴリズムである。 ソースコード #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int gcd(int a, int b) { return (b == 0 ? a : gcd(b, a % b)); } int main() {","title":"最大公約数 (ユークリッドの互除法)"},{"content":"二分探索とは、ソート済みの配列について、探索範囲を半分に絞り込む操作を繰り返す検索アルゴリズムである。\nたとえば、素数の配列が与えられているとき、指定した数よりも小さい数のうち最大となる数を調べる。\nソースコード #include \u0026lt;bits/stdc++.h\u0026gt;#define rep(i, n) for (int i = 0; i \u0026lt; (n); ++i) #define srep(i, s, t) for (int i = s; i \u0026lt; t; ++i) using namespace std; using vi = vector\u0026lt;int\u0026gt;; vi sieve_of_eratosthenes(int n) { vector\u0026lt;bool\u0026gt; is_prime(n + 1); srep(i, 2, n + 1) is_prime[i] = true; vi primes; rep(i, n + 1) { if (is_prime[i]) { primes.push_back(i); for (int j = i * i; j \u0026lt;= n; j += i) is_prime[j] = false; } } return primes; } bool solve(int a, int x) { // 判定条件  return a \u0026lt; x; } int binary_search(vi list, int x) { int ok = -1; // 条件を満たす最大の位置  int ng = list.size(); // 条件を満たさない最小の位置  while (abs(ok - ng) \u0026gt; 1) { int mid = (ok + ng) / 2; if (solve(list[mid], x)) { // 条件を満たす場合 ok の位置を拡張する  ok = mid; } else { // 条件を満たさない場合 ng の位置を拡張する  ng = mid; } } return ok; } void print_info(vi list, int i) { cout \u0026lt;\u0026lt; \u0026#34;index: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;number: \u0026#34;; if (i == -1) { cout \u0026lt;\u0026lt; \u0026#34;not found\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; list[i] \u0026lt;\u0026lt; endl; } } int main() { // 100までの素数の配列  // 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97  vi primes = sieve_of_eratosthenes(100); cout \u0026lt;\u0026lt; \u0026#34;29より小さい数のうち最大となる素数\u0026#34; \u0026lt;\u0026lt; endl; print_info(primes, binary_search(primes, 29)); cout \u0026lt;\u0026lt; \u0026#34;30より小さい数のうち最大となる素数\u0026#34; \u0026lt;\u0026lt; endl; print_info(primes, binary_search(primes, 30)); cout \u0026lt;\u0026lt; \u0026#34;2より小さい数のうち最大となる素数\u0026#34; \u0026lt;\u0026lt; endl; print_info(primes, binary_search(primes, 2)) return 0; } 出力結果は以下の通り。\n29より小さい数のうち最大となる素数 index: 8 number: 23 30より小さい数のうち最大となる素数 index: 9 number: 29 2より小さい数のうち最大となる素数 index: -1 number: not found 解説 探索する配列はソート済みである必要がある。\n ok と ng は配列の添え字の下限-1と上限+1で初期化する。  ok: 条件を満たす最大の位置（初期値-1を除く） ng: 条件を満たさない最小の位置   中央値 mid が条件を満たすかを判定する。  true: ok の位置を mid まで拡張 false: ng の位置を mid まで拡張   ok と ng が隣同士になったとき、探索を終了する。 探索終了時点の ok の位置が、条件を満たす最大の値となる。  条件を満たす値が1つもない場合、ok の値は初期値のままで -1 となることに注意    $n$ 個のデータがある場合の計算量は $O(\\log n)$ となる。\n参考  https://twitter.com/meguru_comp/status/697008509376835584  ","permalink":"https://0x1feb.github.io/posts/2022/12/25/binary-search/","summary":"二分探索とは、ソート済みの配列について、探索範囲を半分に絞り込む操作を繰り返す検索アルゴリズムである。 たとえば、素数の配列が与えられていると","title":"二分探索 (binary search)"},{"content":"ナップサック問題とは、 $n$ 種類の品物（価値 $v$ , 重量 $w$ ）のうちいくつかを選び、ナップサックに収まる範囲で品物の価値の合計が最大になる選び方を求める問題である。\n様々な解き方があるが、動的計画法で解いてみる。（問題は D - Knapsack 1）\nソースコード #include \u0026lt;bits/stdc++.h\u0026gt;#define rep(i, n) for (int i = 0; i \u0026lt; (n); ++i) #define maxs(x, y) (x = max(x, y)) using namespace std; using ll = long long; using vl = vector\u0026lt;ll\u0026gt;; using vvl = vector\u0026lt;vl\u0026gt;; int main() { int N, W; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; W; vl weight(N), value(N); rep(i, N) cin \u0026gt;\u0026gt; weight[i] \u0026gt;\u0026gt; value[i]; vvl dp(N + 1, vl(W + 1, 0)); rep(i, N) rep(w, W + 1) { // i個目の品物を選ぶ場合  if (w \u0026gt;= weight[i]) maxs(dp[i + 1][w], dp[i][w - weight[i]] + value[i]); // i個目の品物を選ばない場合  maxs(dp[i + 1][w], dp[i][w]); } cout \u0026lt;\u0026lt; dp[N][W] \u0026lt;\u0026lt; endl; return 0; } 解説 dp[i][w] には、最初の $i$ 個の品物の中から重さの合計が $w$ 以下になるよう選んだときの価値の合計の最大値を格納する。\n$i$ 個目の品物を選ぶ場合は、選ぶ前の状態 dp[i][w - weight[i]] に $i$ 個目の品物の価値 value[i] を追加した値を格納する。（ナップサックの容量を超えてはならないため、w \u0026gt;= weight[i] の条件が必要となる。）\nmaxs(dp[i + 1][w], dp[i][w - weight[i]] + value[i])\n$i$ 個目の品物を選ばない場合は、選ぶ前の状態 dp[i][w] と何の変化もないため、そのままの値を格納する。\nmaxs(dp[i + 1][w], dp[i][w]);\nちなみに、 $i = 0$ のときは品物を1つも選ばないので、すべての $w$ について価値の合計の最大値は0となる。また、任意の $i$ について、$w = 0$ のときは品物を1つも入れることができないので、価値の合計の最大値は0となる。\n参考  ナップサック問題 - Wikipedia D - Knapsack 1  ","permalink":"https://0x1feb.github.io/posts/2022/12/21/knapsack-dp/","summary":"ナップサック問題とは、 $n$ 種類の品物（価値 $v$ , 重量 $w$ ）のうちいくつかを選び、ナップサックに収まる範囲で品物の価値の合計が最大になる選び方を求め","title":"ナップサック問題 (動的計画法)"},{"content":"エラトステネスの篩とは、指定した数以下の素数を探すアルゴリズムである。\n指定した数までの数列を用意し、素数を見つけたらその素数の倍数を篩い落としていくことで、素数のみの数列が残るという仕組みである。\nソースコード #include \u0026lt;bits/stdc++.h\u0026gt;#define rep(i, n) for (int i = 0; i \u0026lt; (n); ++i) #define srep(i, s, t) for (int i = s; i \u0026lt; t; ++i) using namespace std; using vi = vector\u0026lt;int\u0026gt;; vi sieve_of_eratosthenes(int n) { vector\u0026lt;bool\u0026gt; is_prime(n + 1); // 添え字の数が素数か判定した結果を持つ配列  // 0, 1 は素数ではないので false のまま初期化する  srep(i, 2, n + 1) is_prime[i] = true; vi primes; // 素数を格納する配列  rep(i, n + 1) { if (is_prime[i]) { primes.push_back(i); // 素数iについて、i^2以上のiの倍数を篩い落とすため false にする  for (int j = i * i; j \u0026lt;= n; j += i) is_prime[j] = false; } } return primes; } int main() { vi primes = sieve_of_eratosthenes(100); for (int p : primes) cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; return 0; } 100までの素数を出力した結果は以下の通り。\n2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 参考  エラトステネスの篩 - Wikipedia  ","permalink":"https://0x1feb.github.io/posts/2022/12/20/sieve-of-eratosthenes/","summary":"エラトステネスの篩とは、指定した数以下の素数を探すアルゴリズムである。 指定した数までの数列を用意し、素数を見つけたらその素数の倍数を篩い落と","title":"素数列挙 (エラトステネスの篩)"},{"content":"2のべき乗で求められる組み合わせを全探索する方法として、bit 全探索という方法がある。\n例えば、 $n$ 人が「立っている」または「座っている」のどちらかの状態で行列に並んでいるとする。このとき、考えられる行列の並び方を全て列挙する場合に使える。\nソースコード #include \u0026lt;bits/stdc++.h\u0026gt;#define rep(i, n) for (int i = 0; i \u0026lt; (n); ++i) using namespace std; void bit_full_search(int n) { rep(i, 1 \u0026lt;\u0026lt; n) { rep(j, n) { if (i \u0026amp; (1 \u0026lt;\u0026lt; j)) { cout \u0026lt;\u0026lt; \u0026#34;1\u0026#34;; // 1のときの処理  } else { cout \u0026lt;\u0026lt; \u0026#34;0\u0026#34;; // 0のときの処理  } } cout \u0026lt;\u0026lt; endl; } } int main() { bit_full_search(4); return 0; } n = 4 のときの出力結果は以下の通り。先ほどの例えで考えると、立っている状態を0、座っている状態を1とすれば、ありうる行列の組み合わせが全て出力されていることになる。\n0000 1000 0100 1100 0010 1010 0110 1110 0001 1001 0101 1101 0011 1011 0111 1111 解説 数値同士の論理積は、2進数の各位のビットを比較し、両方が1のときのみ1となる。\n#include \u0026lt;bits/stdc++.h\u0026gt;#define rep(i, n) for (int i = 0; i \u0026lt; (n); ++i) using namespace std; void printAndValue(int x, int y) { cout \u0026lt;\u0026lt; bitset\u0026lt;8\u0026gt;(x) \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; bitset\u0026lt;8\u0026gt;(y) \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; bitset\u0026lt;8\u0026gt;(x \u0026amp; y) \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026amp; \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; } int main() { printAndValue(42, 121); return 0; } 00101010 = 42 01111001 = 121 00101000 = 42 \u0026amp; 121 上記の例の場合、42と121を2進数で表したとき、右から4桁目と6桁目はどちらも1であるから、42と121の論理積は 00101000 となる。\nまた、1 \u0026lt;\u0026lt; n で 00000001 を n ビット左シフトした値を得ることができる。\n#include \u0026lt;bits/stdc++.h\u0026gt;#define rep(i, n) for (int i = 0; i \u0026lt; (n); ++i) using namespace std; void printLeftShiftValue(int n) { rep(i, n) { int num = 1 \u0026lt;\u0026lt; i; bitset\u0026lt;8\u0026gt; bit_num(num); cout \u0026lt;\u0026lt; \u0026#34;bit: \u0026#34; \u0026lt;\u0026lt; bit_num \u0026lt;\u0026lt; \u0026#34;, num: \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; } } int main() { printLeftShiftValue(8); return 0; } 1を0ビットから7ビットまで左シフトした出力結果は以下の通り。\nbit: 00000001, num: 1 bit: 00000010, num: 2 bit: 00000100, num: 4 bit: 00001000, num: 8 bit: 00010000, num: 16 bit: 00100000, num: 32 bit: 01000000, num: 64 bit: 10000000, num: 128 ある数iについて、上記の数との論理積をとれば、任意の位が0か1かを判定することができる。\nbitFullSearch() ではこの性質を組み合わせることで、全探索を実現している。\n 外側のループで $0$ から $2^{n-1}$ までの数値 $i$ を作る。 各 $i$ について、 $2^{0}$ から $2^{n-1}$ 乗までの数値 (1 \u0026lt;\u0026lt; j) との論理積をとる。 論理積 (i \u0026amp; (1 \u0026lt;\u0026lt; j)) の値が $0$ となれば $j+1$ 桁目は $0$ であり、それ以外なら $1$ となる。  ","permalink":"https://0x1feb.github.io/posts/2022/12/18/bit-full-search/","summary":"2のべき乗で求められる組み合わせを全探索する方法として、bit 全探索という方法がある。 例えば、 $n$ 人が「立っている」または「座っている」のどち","title":"bit 全探索"},{"content":"概要 AtCoder で std::map を使うときのメモ書き。\n基本 map  キーに設定した値の昇順にソートされる。  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { map\u0026lt;int, int\u0026gt; mp; mp[5] = 10; mp[1] = 3; mp[4] = 6; for (auto p : mp) { printf(\u0026#34;key:%d, value:%d\\n\u0026#34;, p.first, p.second); } return 0; } key:1, value:3 key:4, value:6 key:5, value:10 unorderd_map  ソートされないため、 map よりも高速に動作する。  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { unordered_map\u0026lt;int, int\u0026gt; mp; mp[5] = 10; mp[1] = 3; mp[4] = 6; for (auto p : mp) { printf(\u0026#34;key:%d, value:%d\\n\u0026#34;, p.first, p.second); } return 0; } key:4, value:6 key:1, value:3 key:5, value:10 キーの検索 find  find でキーを指定すると、該当する場合はイテレータを返す。 該当しない場合は末尾のイテレータを返す。  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { map\u0026lt;int, int\u0026gt; mp; mp[5] = 10; mp[1] = 3; mp[4] = 6; auto f = [](map\u0026lt;int, int\u0026gt; mp, int x) { auto it = mp.find(x); if (it == mp.end()) { cout \u0026lt;\u0026lt; \u0026#34;該当なし。\u0026#34; \u0026lt;\u0026lt; endl; return; } cout \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; endl; }; // 対象キーが存在しない場合  f(mp, 0); // 対象キーが存在する場合  f(mp, 4); return 0; } 該当なし。 4, 6 二分探索(lower_bound/upper_bound) lower_bound  指定したキー \u0026lt;= x となる最小のキー x を持つイテレータを返す。 該当する x が存在しない場合、末尾のイテレータを返す。  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { map\u0026lt;int, int\u0026gt; mp; mp[5] = 10; mp[1] = 3; mp[4] = 6; auto f = [](map\u0026lt;int, int\u0026gt; mp, int x) { auto it = mp.lower_bound(x); if (it == mp.end()) { cout \u0026lt;\u0026lt; \u0026#34;該当なし。\u0026#34; \u0026lt;\u0026lt; endl; return; } cout \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; endl; }; f(mp, 3); f(mp, 4); f(mp, 5); f(mp, 6); return 0; } 4, 6 4, 6 5, 10 該当なし。 upper_bound  指定したキー \u0026lt; x となる最小のキー x を持つイテレータを返す。 該当する x が存在しない場合、末尾のイテレータを返す。  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { map\u0026lt;int, int\u0026gt; mp; mp[5] = 10; mp[1] = 3; mp[4] = 6; auto f = [](map\u0026lt;int, int\u0026gt; mp, int x) { auto it = mp.upper_bound(x); if (it == mp.end()) { cout \u0026lt;\u0026lt; \u0026#34;該当なし。\u0026#34; \u0026lt;\u0026lt; endl; return; } cout \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; endl; }; f(mp, 3); f(mp, 4); f(mp, 5); f(mp, 6); return 0; } 4, 6 5, 10 該当なし。 該当なし。 ","permalink":"https://0x1feb.github.io/posts/2022/10/26/cpp-map-memo/","summary":"概要 AtCoder で std::map を使うときのメモ書き。 基本 map キーに設定した値の昇順にソートされる。 #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { map\u0026lt;int, int\u0026gt; mp; mp[5] = 10; mp[1] = 3; mp[4] = 6; for (auto p : mp) { printf(\u0026#34;key:%d, value:%d\\n\u0026#34;, p.first, p.second); } return 0;","title":"C++ の std::map メモ"},{"content":"やりたいこと 単体のリストではない複数の要素に、同じ処理を適用したい。\n複数のリストや要素を一時的にまとめた Stream を作成し、一括で処理したい。\npublic class User { private String name; private int age; public User(String name, int age) { this.name = name; this.age = age; } // getter と setter は省略  public String toString() { return \u0026#34;name: \u0026#34; + name + \u0026#34;, age: \u0026#34; + age; } } 以下のリスト1とリスト2をまとめたり、リスト1と単体の要素1をまとめたりして処理する。\n// リスト1 List\u0026lt;User\u0026gt; userList1 = new ArrayList\u0026lt;User\u0026gt;(); userList1.add(new User(\u0026#34;John\u0026#34;, 40)); userList1.add(new User(\u0026#34;Paul\u0026#34;, 79)); userList1.add(new User(\u0026#34;George\u0026#34;, 58)); userList1.add(new User(\u0026#34;Ringo\u0026#34;, 81)); // リスト2 List\u0026lt;User\u0026gt; userList2 = new ArrayList\u0026lt;User\u0026gt;(); userList2.add(new User(\u0026#34;Albert\u0026#34;, 76)); userList2.add(new User(\u0026#34;Richard\u0026#34;, 69)); // 単体の要素1 User user1 = new User(\u0026#34;Tanaka\u0026#34;, 36); // 単体の要素2 User user2 = new User(\u0026#34;Suzuki\u0026#34;, 74); 単体の要素同士 Stream.of に要素を列挙して Stream を作成する。\nStream.of(user1, user2) .forEach(System.out::println); // name: Tanaka, age: 36 // name: Suzuki, age: 74 リスト同士 Stream.of でリストをまとめると、リスト単位で処理する。\nStream.of(userList1, userList2) .forEach(System.out::println); // [name: John, age: 40, name: Paul, age: 79, name: George, age: 58, name: Ringo, age: 81] // [name: Albert, age: 76, name: Richard, age: 69] リスト内の要素単位で処理する場合は、flatMap を用いる。\nStream.of(userList1, userList2) .flatMap(Collection::stream) .forEach(System.out::println); // name: John, age: 40 // name: Paul, age: 79 // name: George, age: 58 // name: Ringo, age: 81 // name: Albert, age: 76 // name: Richard, age: 69 各リストを Stream に変換し、均した新しい Stream を返ため、各要素単位で処理できる。\n単体の要素とリスト リストと単体の要素を個別に Stream に変換し、Stream.concat でまとめた Stream を作成する。\nStream.concat(userList1.stream(), Stream.of(user1)) .forEach(System.out::println); // name: John, age: 40 // name: Paul, age: 79 // name: George, age: 58 // name: Ringo, age: 81 // name: Tanaka, age: 36 ","permalink":"https://0x1feb.github.io/posts/2022/01/27/combining-multi-elements-in-java-stream/","summary":"やりたいこと 単体のリストではない複数の要素に、同じ処理を適用したい。 複数のリストや要素を一時的にまとめた Stream を作成し、一括で処理したい。 public class User","title":"複数の要素を Stream でまとめる"},{"content":"Stream とは Java 8 から追加され、コレクションに対する集約操作をサポートした機能を持つ。\n中間操作と終端操作を組み合わせてパイプラインにできるため、for 文による繰り返し処理を簡潔に記述できる。\nサンプルクラス User クラス 年齢と名前の情報のみを持つ、以下のユーザクラスを用いる。\npublic class User { private String name; private int age; public User(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String toString() { return \u0026#34;name: \u0026#34; + name + \u0026#34;, age: \u0026#34; + age; } } User のコレクション コレクションは以下とする。\nList\u0026lt;User\u0026gt; userList = new ArrayList\u0026lt;User\u0026gt;(); userList.add(new User(\u0026#34;John\u0026#34;, 40)); userList.add(new User(\u0026#34;Paul\u0026#34;, 79)); userList.add(new User(\u0026#34;George\u0026#34;, 58)); userList.add(new User(\u0026#34;Ringo\u0026#34;, 81)); 要素を順番に処理 forEach userList.stream() .forEach(u -\u0026gt; System.out.println(u)); // name: John, age: 40 // name: Paul, age: 79 // name: George, age: 58 // name: Ringo, age: 81  // 以下も同じ結果 userList.stream() .forEach(System.out::println); ラムダ式を受け取るが、別のメソッドをそのまま呼び出す場合、メソッドのみを渡すこともできる。\n順次/並列 stream ストリームは明示的に並列を指定しない限り、順次で実行される。\n// stream userList.stream() .forEach(System.out::println); // name: John, age: 40 // name: Paul, age: 79 // name: George, age: 58 // name: Ringo, age: 81 parallelStream 並列で実行する場合は、並列のストリームを生成する必要がある。\n// parallelStream userList.parallelStream() .forEach(System.out::println); // name: George, age: 58 // name: Ringo, age: 81 // name: John, age: 40 // name: Paul, age: 79 絞り込み filter 与えられたラムダ式が true となる要素から構成された stream を返す。\n// 60歳未満のみ出力 userList.stream() .filter(u -\u0026gt; u.getAge() \u0026lt; 60) .forEach(System.out::println); // name: John, age: 40 // name: George, age: 58 加工 map 与えられたラムダ式で加工した結果から構成される stream を返す。\n// \u0026#34;My name is XX\u0026#34; の文字列に加工して出力 userList.stream() .map(u -\u0026gt; \u0026#34;My name is\u0026#34; + u.getName()) .forEach(System.out::println); // My name isJohn // My name isPaul // My name isGeorge // My name isRingo スキップ skip 先頭から n 番目の要素を除いた stream を返す。\nuserList.stream() .skip(2) .forEach(System.out::println); // name: George, age: 58 // name: Ringo, age: 81 この例の場合、John と Paul の2人がスキップされている。\n要素数の制限 limit 指定した要素数の stream を返す。\nuserList.stream() .limit(2) .forEach(System.out::println); // name: John, age: 40 // name: Paul, age: 79 並べ替え sorted 指定したルールでソートした stream を返す。\n// 年齢の昇順 userList.stream() .sorted(Comparator.comparing(User::getAge)) .forEach(System.out::println); // name: John, age: 40 // name: George, age: 58 // name: Paul, age: 79 // name: Ringo, age: 81  // 年齢の降順 userList.stream() .sorted(Comparator.comparing(User::getAge).reversed()) .forEach(System.out::println); // name: Ringo, age: 81 // name: Paul, age: 79 // name: George, age: 58 // name: John, age: 40 条件判定 anyMatch // いずれかの要素が指定した条件を満たせば true boolean anyMatch = userList.stream() .anyMatch(u -\u0026gt; u.getAge() \u0026lt; 60); System.out.println(anyMatch); // true allMatch // 全ての要素が指定した条件を満たせば true boolean allMatch = userList.stream() .anyMatch(u -\u0026gt; u.getAge() \u0026lt; 60); System.out.println(allMatch); // false noneMatch // 全ての要素が指定した条件を満たさなければ true boolean noneMatch = userList.stream() .noneMatch(u -\u0026gt; u.getName().equals(\u0026#34;Pete\u0026#34;)); System.out.println(noneMatch); 先頭の要素を取得 findFirst Optional 型を返すので、orElse などが必要となる。\nUser user = userList.stream() .findFirst() .orElse(null); System.out.println(user); 集計 max // 年齢が最大のユーザ User maxAgeUser = userList.stream() .max(Comparator.comparing(User::getAge)) .orElse(null); System.out.println(maxAgeUser); // name: Ringo, age: 81 min // 年齢が最小のユーザ User minAgeUser = userList.stream() .min(Comparator.comparing(User::getAge)) .orElse(null); System.out.println(minAgeUser); // name: John, age: 40 count // 要素の個数 long count = userList.stream() .count(); System.out.println(count); // 4 average // 年齢の平均 double average = userList.stream() .mapToInt(User::getAge) .average() .orElse(0); System.out.println(average); // 64.5 sum // 年齢の合計 int sum = userList.stream() .mapToInt(User::getAge) .sum(); System.out.println(sum); // 258 値をまとめる reduce // 全員の名前をカンマ区切りで並べた文字列を取得 String result = userList.stream() .map(User::getName) .reduce((res, u) -\u0026gt; res += \u0026#34;, \u0026#34; + u) .orElse(\u0026#34;\u0026#34;); System.out.println(result); // John, Paul, George, Ringo ","permalink":"https://0x1feb.github.io/posts/2022/01/24/java-stream-memo/","summary":"Stream とは Java 8 から追加され、コレクションに対する集約操作をサポートした機能を持つ。 中間操作と終端操作を組み合わせてパイプラインにできるため、fo","title":"Java の Stream メモ"},{"content":"hello, world main() { printf(\u0026#34;hello, world\\n\u0026#34;); } ","permalink":"https://0x1feb.github.io/posts/2022/01/21/hello-world/","summary":"hello, world main() { printf(\u0026#34;hello, world\\n\u0026#34;); } ","title":"hello, world"}]