[{"content":"やりたいこと 単体のリストではない複数の要素に、同じ処理を適用したい。\n複数のリストや要素を一時的にまとめた Stream を作成し、一括で処理したい。\npublic class User { private String name; private int age; public User(String name, int age) { this.name = name; this.age = age; } // getter と setter は省略  public String toString() { return \u0026#34;name: \u0026#34; + name + \u0026#34;, age: \u0026#34; + age; } } 以下のリスト1とリスト2をまとめたり、リスト1と単体の要素1をまとめたりして処理する。\n// リスト1 List\u0026lt;User\u0026gt; userList1 = new ArrayList\u0026lt;User\u0026gt;(); userList1.add(new User(\u0026#34;John\u0026#34;, 40)); userList1.add(new User(\u0026#34;Paul\u0026#34;, 79)); userList1.add(new User(\u0026#34;George\u0026#34;, 58)); userList1.add(new User(\u0026#34;Ringo\u0026#34;, 81)); // リスト2 List\u0026lt;User\u0026gt; userList2 = new ArrayList\u0026lt;User\u0026gt;(); userList2.add(new User(\u0026#34;Albert\u0026#34;, 76)); userList2.add(new User(\u0026#34;Richard\u0026#34;, 69)); // 単体の要素1 User user1 = new User(\u0026#34;Tanaka\u0026#34;, 36); // 単体の要素2 User user2 = new User(\u0026#34;Suzuki\u0026#34;, 74); 単体の要素同士 Stream.of に要素を列挙して Stream を作成する。\nStream.of(user1, user2) .forEach(System.out::println); // name: Tanaka, age: 36 // name: Suzuki, age: 74 リスト同士 Stream.of でリストをまとめると、リスト単位で処理する。\nStream.of(userList1, userList2) .forEach(System.out::println); // [name: John, age: 40, name: Paul, age: 79, name: George, age: 58, name: Ringo, age: 81] // [name: Albert, age: 76, name: Richard, age: 69] リスト内の要素単位で処理する場合は、flatMap を用いる。\nStream.of(userList1, userList2) .flatMap(Collection::stream) .forEach(System.out::println); // name: John, age: 40 // name: Paul, age: 79 // name: George, age: 58 // name: Ringo, age: 81 // name: Albert, age: 76 // name: Richard, age: 69 各リストを Stream に変換し、均した新しい Stream を返ため、各要素単位で処理できる。\n単体の要素とリスト リストと単体の要素を個別に Stream に変換し、Stream.concat でまとめた Stream を作成する。\nStream.concat(userList1.stream(), Stream.of(user1)) .forEach(System.out::println); // name: John, age: 40 // name: Paul, age: 79 // name: George, age: 58 // name: Ringo, age: 81 // name: Tanaka, age: 36 ","permalink":"https://0x1feb.github.io/posts/2022/01/27/combining-multi-elements-in-java-stream/","summary":"やりたいこと 単体のリストではない複数の要素に、同じ処理を適用したい。 複数のリストや要素を一時的にまとめた Stream を作成し、一括で処理したい。 public class User","title":"複数の要素を Stream でまとめる"},{"content":"Stream とは Java 8 から追加され、コレクションに対する集約操作をサポートした機能を持つ。\n中間操作と終端操作を組み合わせてパイプラインにできるため、for 文による繰り返し処理を簡潔に記述できる。\nサンプルクラス User クラス 年齢と名前の情報のみを持つ、以下のユーザクラスを用いる。\npublic class User { private String name; private int age; public User(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String toString() { return \u0026#34;name: \u0026#34; + name + \u0026#34;, age: \u0026#34; + age; } } User のコレクション コレクションは以下とする。\nList\u0026lt;User\u0026gt; userList = new ArrayList\u0026lt;User\u0026gt;(); userList.add(new User(\u0026#34;John\u0026#34;, 40)); userList.add(new User(\u0026#34;Paul\u0026#34;, 79)); userList.add(new User(\u0026#34;George\u0026#34;, 58)); userList.add(new User(\u0026#34;Ringo\u0026#34;, 81)); 要素を順番に処理 forEach userList.stream() .forEach(u -\u0026gt; System.out.println(u)); // name: John, age: 40 // name: Paul, age: 79 // name: George, age: 58 // name: Ringo, age: 81  // 以下も同じ結果 userList.stream() .forEach(System.out::println); ラムダ式を受け取るが、別のメソッドをそのまま呼び出す場合、メソッドのみを渡すこともできる。\n順次/並列 stream ストリームは明示的に並列を指定しない限り、順次で実行される。\n// stream userList.stream() .forEach(System.out::println); // name: John, age: 40 // name: Paul, age: 79 // name: George, age: 58 // name: Ringo, age: 81 parallelStream 並列で実行する場合は、並列のストリームを生成する必要がある。\n// parallelStream userList.parallelStream() .forEach(System.out::println); // name: George, age: 58 // name: Ringo, age: 81 // name: John, age: 40 // name: Paul, age: 79 絞り込み filter 与えられたラムダ式が true となる要素から構成された stream を返す。\n// 60歳未満のみ出力 userList.stream() .filter(u -\u0026gt; u.getAge() \u0026lt; 60) .forEach(System.out::println); // name: John, age: 40 // name: George, age: 58 加工 map 与えられたラムダ式で加工した結果から構成される stream を返す。\n// \u0026#34;My name is XX\u0026#34; の文字列に加工して出力 userList.stream() .map(u -\u0026gt; \u0026#34;My name is\u0026#34; + u.getName()) .forEach(System.out::println); // My name isJohn // My name isPaul // My name isGeorge // My name isRingo スキップ skip 先頭から n 番目の要素を除いた stream を返す。\nuserList.stream() .skip(2) .forEach(System.out::println); // name: George, age: 58 // name: Ringo, age: 81 この例の場合、John と Paul の2人がスキップされている。\n要素数の制限 limit 指定した要素数の stream を返す。\nuserList.stream() .limit(2) .forEach(System.out::println); // name: John, age: 40 // name: Paul, age: 79 並べ替え sorted 指定したルールでソートした stream を返す。\n// 年齢の昇順 userList.stream() .sorted(Comparator.comparing(User::getAge)) .forEach(System.out::println); // name: John, age: 40 // name: George, age: 58 // name: Paul, age: 79 // name: Ringo, age: 81  // 年齢の降順 userList.stream() .sorted(Comparator.comparing(User::getAge).reversed()) .forEach(System.out::println); // name: Ringo, age: 81 // name: Paul, age: 79 // name: George, age: 58 // name: John, age: 40 条件判定 anyMatch // いずれかの要素が指定した条件を満たせば true boolean anyMatch = userList.stream() .anyMatch(u -\u0026gt; u.getAge() \u0026lt; 60); System.out.println(anyMatch); // true allMatch // 全ての要素が指定した条件を満たせば true boolean allMatch = userList.stream() .anyMatch(u -\u0026gt; u.getAge() \u0026lt; 60); System.out.println(allMatch); // false noneMatch // 全ての要素が指定した条件を満たさなければ true boolean noneMatch = userList.stream() .noneMatch(u -\u0026gt; u.getName().equals(\u0026#34;Pete\u0026#34;)); System.out.println(noneMatch); 先頭の要素を取得 findFirst Optional 型を返すので、orElse などが必要となる。\nUser user = userList.stream() .findFirst() .orElse(null); System.out.println(user); 集計 max // 年齢が最大のユーザ User maxAgeUser = userList.stream() .max(Comparator.comparing(User::getAge)) .orElse(null); System.out.println(maxAgeUser); // name: Ringo, age: 81 min // 年齢が最小のユーザ User minAgeUser = userList.stream() .min(Comparator.comparing(User::getAge)) .orElse(null); System.out.println(minAgeUser); // name: John, age: 40 count // 要素の個数 long count = userList.stream() .count(); System.out.println(count); // 4 average // 年齢の平均 double average = userList.stream() .mapToInt(User::getAge) .average() .orElse(0); System.out.println(average); // 64.5 sum // 年齢の合計 int sum = userList.stream() .mapToInt(User::getAge) .sum(); System.out.println(sum); // 258 値をまとめる reduce // 全員の名前をカンマ区切りで並べた文字列を取得 String result = userList.stream() .map(User::getName) .reduce((res, u) -\u0026gt; res += \u0026#34;, \u0026#34; + u) .orElse(\u0026#34;\u0026#34;); System.out.println(result); // John, Paul, George, Ringo ","permalink":"https://0x1feb.github.io/posts/2022/01/24/java-stream-memo/","summary":"Stream とは Java 8 から追加され、コレクションに対する集約操作をサポートした機能を持つ。 中間操作と終端操作を組み合わせてパイプラインにできるため、fo","title":"Java の Stream メモ"},{"content":"hello, world main() { printf(\u0026#34;hello, world\\n\u0026#34;); } ","permalink":"https://0x1feb.github.io/posts/2022/01/21/hello-world/","summary":"hello, world main() { printf(\u0026#34;hello, world\\n\u0026#34;); } ","title":"hello, world"}]