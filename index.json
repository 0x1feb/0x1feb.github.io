[{"content":"概要 PowerShell の実行ユーザを切り替える。 PowerShell を管理者権限で実行する。 前提 Windows Server 2019 Windows PowerShell 5.1 7.4 でも同じように動くはず。 手順 ユーザ切り替えと管理者権限での実行は、同時にできないため、個別に実行する必要がある。\nユーザ切替 PowerShell を開き、以下のコマンドを実行する。-Credential には、切り替えたいユーザ名を指定する。\nStart-Process \u0026#34;powershell\u0026#34; -Credential ${userName} 指定したユーザの認証を求められるため、認証する。\n以下のコマンドを実行し、指定したユーザになっていることを確認する。\nwhoami 管理者権限 管理者権限にしたいユーザで実行中の PowerShell にて、以下のコマンドを実行する。\nStart-Process \u0026#34;powershell\u0026#34; -Verb RunAs 管理者権限で PowerShell が開く。\nコンソールの動作が遅くなる場合 新たに開いたコンソールが固まったり、動作が異常に遅くなる場合がある。\n以下コマンド実行後に、ユーザ切替や管理者権限のコマンドを実行すると解消する。\nRemove-Module PSReadline Start-Process \u0026#34;powershell\u0026#34; ... Remove-Module PSReadline は、コマンドの履歴を管理する PSReadline をセッション上から削除する。そのため、呼び出し元コンソールの履歴が消えるため注意する。\n参考 Start-Process (Microsoft.PowerShell.Management) - PowerShell ｜ Microsoft Learn ","permalink":"https://0x1feb.github.io/posts/2024/09/10/running-powershell-as-the-specified-user-or-administrator/","summary":"概要 PowerShell の実行ユーザを切り替える。 PowerShell を管理者権限で実行する。 前提 Windows Server 2019 Windows PowerShell 5.1 7.4 でも同じように動くはず。 手順 ユーザ切り替えと管理者権限での実行は","title":"指定したユーザや管理者権限で PowerShell を実行する"},{"content":"概要 JUnit 5 の動的テストを整理する。 @RepeatedTest 前提 JUnit 5 解説 @RepeatedTest @RepeatedTest は、指定した回数だけテストメソッドを繰り返すテストである。\n例えば、以下の ExampleRepeatedTest は、@RepeatedTest(2) が付与されたテストを 1 つ持つ。\nclass ExampleRepeatedTest { static private final Logger LOG = (Logger) LogManager.getLogger(); @BeforeEach void init() { LOG.info(\u0026#34;called init()\u0026#34;); } @RepeatedTest(2) void repeatedTest() { LOG.info(\u0026#34;called repeatedTest()\u0026#34;); assertEquals(2, 1 + 1); } } このテストクラスを実行した結果は、次の通りである。\nExampleRepeatedTest: 2 total, 2 passed ExampleRepeatedTest repeatedTest repetition 1 of 2 [passed] repetition 2 of 2 [passed] repeatedTest が 2 回実行される。\nまた、ログを確認すると、@Test と同じライフサイクルで 2 回テストが実行されていることがわかる。\n22:04:16.800 [Test worker] INFO method.ExampleRepeatedTest - called init() 22:04:16.806 [Test worker] INFO method.ExampleRepeatedTest - called repeatedTest() 22:04:16.816 [Test worker] INFO method.ExampleRepeatedTest - called init() 22:04:16.817 [Test worker] INFO method.ExampleRepeatedTest - called repeatedTest() @RepeatedTest は、以下の要素を持つ。\n必須要素 value: 繰り返す数 オプション要素 failureThreshold: 繰り返しを中断する失敗回数 name: 繰り返し毎のテスト名 また、テストメソッドの引数に RepetitionInfo を注入することで、繰り返しに関する情報を取得できる。\nclass ExampleRepeatedTest { static private final Logger LOG = (Logger) LogManager.getLogger(); @BeforeEach void init(TestInfo testInfo, RepetitionInfo repetitionInfo) { int currentRepetition = repetitionInfo.getCurrentRepetition(); int totalRepetitions = repetitionInfo.getTotalRepetitions(); int failureCount = repetitionInfo.getFailureCount(); int failureThreshold = repetitionInfo.getFailureThreshold(); String methodName = testInfo.getTestMethod().get().getName(); LOG.info(\u0026#34;About to execute repetition %d of %d for %s\u0026#34;.formatted( currentRepetition, totalRepetitions, methodName )); } @RepeatedTest(2) void repeatedTest() { assertEquals(2, 1 + 1); } @RepeatedTest(3) void repeatedTestWithRepetitionInfo(RepetitionInfo repetitionInfo) { assertEquals(3, repetitionInfo.getTotalRepetitions()); } @RepeatedTest(value = 4, name = \u0026#34;{currentRepetition}/{totalRepetitions} ({displayName})\u0026#34;) @DisplayName(\u0026#34;myDisplayName\u0026#34;) void repeatedTestWithCustomName() { assertEquals(2, 1 + 1); } @RepeatedTest(value = 5, failureThreshold = 2) void repeatedTestWithFailureThreshold() { fail(\u0026#34;failure\u0026#34;); } } ExampleRepeatedTest では、@BeforeEach にて RepetitionInfo の情報を出力している。\nRepetitionInfo currentRepetition: 現在の繰り返し回数 totalRepetitions: 繰り返し回数の合計 (@RepeatedTest の value の値) failureCount: 失敗した回数 failureThreshold: 繰り返しを中断する失敗回数 (@RepeatedTest の failureThreshold の値) また、repeatedTestWithRepetitionInfo では、RepetitionInfo から totalRepetitions を取得し、繰り返し回数をテストメソッドの中で使用している。\nrepeatedTestWithCustomName では、テスト結果の表示名をカスタマイズしている。表示名の設定値やプレースホルダは RepeatedTest#name() に記載されている。\nrepeatedTestWithFailureThreshold では、繰り返しを中断する失敗回数 failureThreshold を 2 回に設定している。このテストは、2 回失敗した時点で、3 回目以降はスキップとなる。\nこのテストクラスを実行した結果は、次の通りである。\nExampleRepeatedTest: 14 total, 2 failed, 3 ignored, 9 passed ExampleRepeatedTest repeatedTest repetition 1 of 2 [passed] repetition 2 of 2 [passed] myDisplayName 1/4 (myDisplayName) [passed] 2/4 (myDisplayName) [passed] 3/4 (myDisplayName) [passed] 4/4 (myDisplayName) [passed] repeatedTestWithRepetitionInfo repetition 1 of 3 [passed] repetition 2 of 3 [passed] repetition 3 of 3 [passed] repeatedTestWithFailureThreshold repetition 1 of 5 [failed] repetition 2 of 5 [failed] repetition 3 of 5 [ignored] repetition 4 of 5 [ignored] repetition 5 of 5 [ignored] repeatedTestWithCustomName では、名前をカスタマイズしているため、1/4 (myDisplayName) のような形で結果が出力されている。\nまた、ログ出力結果は、次の通りである。\n22:53:03.652 [Test worker] INFO method.ExampleRepeatedTest - repeatedTest: currentRepetition=1, totalRepetitions=2, failureCount=0, failureThreshold=2147483647, 22:53:03.670 [Test worker] INFO method.ExampleRepeatedTest - repeatedTest: currentRepetition=2, totalRepetitions=2, failureCount=0, failureThreshold=2147483647, 22:53:03.674 [Test worker] INFO method.ExampleRepeatedTest - repeatedTestWithCustomName: currentRepetition=1, totalRepetitions=4, failureCount=0, failureThreshold=2147483647, 22:53:03.676 [Test worker] INFO method.ExampleRepeatedTest - repeatedTestWithCustomName: currentRepetition=2, totalRepetitions=4, failureCount=0, failureThreshold=2147483647, 22:53:03.678 [Test worker] INFO method.ExampleRepeatedTest - repeatedTestWithCustomName: currentRepetition=3, totalRepetitions=4, failureCount=0, failureThreshold=2147483647, 22:53:03.680 [Test worker] INFO method.ExampleRepeatedTest - repeatedTestWithCustomName: currentRepetition=4, totalRepetitions=4, failureCount=0, failureThreshold=2147483647, 22:53:03.682 [Test worker] INFO method.ExampleRepeatedTest - repeatedTestWithRepetitionInfo: currentRepetition=1, totalRepetitions=3, failureCount=0, failureThreshold=2147483647, 22:53:03.685 [Test worker] INFO method.ExampleRepeatedTest - repeatedTestWithRepetitionInfo: currentRepetition=2, totalRepetitions=3, failureCount=0, failureThreshold=2147483647, 22:53:03.688 [Test worker] INFO method.ExampleRepeatedTest - repeatedTestWithRepetitionInfo: currentRepetition=3, totalRepetitions=3, failureCount=0, failureThreshold=2147483647, 22:53:03.691 [Test worker] INFO method.ExampleRepeatedTest - repeatedTestWithFailureThreshold: currentRepetition=1, totalRepetitions=5, failureCount=0, failureThreshold=2, Expected :100 Actual :2 ... 22:53:03.699 [Test worker] INFO method.ExampleRepeatedTest - repeatedTestWithFailureThreshold: currentRepetition=2, totalRepetitions=5, failureCount=1, failureThreshold=2, Expected :100 Actual :2 ... 参考 RepeatedTest (JUnit 5.11.0 API) ","permalink":"https://0x1feb.github.io/posts/2024/09/09/understanding-junit-5-repeated-test-annotation/","summary":"概要 JUnit 5 の動的テストを整理する。 @RepeatedTest 前提 JUnit 5 解説 @RepeatedTest @RepeatedTest は、指定した回数だけテストメソッドを繰り返すテストである。 例えば、以下の ExampleRepeatedTest は、@Repea","title":"JUnit 5 の動的テスト @RepeatedTest を整理する"},{"content":"概要 JUnit 5 の静的テストを整理する。 @Test 前提 JUnit 5 解説 @Test @Test アノテーションは、付与したメソッドがテストメソッドであることを表す。\n以下の ExampleTest は、@Test のテストを 2 つ持つ。\nclass ExampleTest { @Test void testMethod1() { assertEquals(2, 1 + 1); } @Test void testMethod2() { assertEquals(2, 1 + 1); } } このテストクラスでは、testMethod1 と testMethod2 の 2 つが実行される。\nExampleTest: 2 total, 2 passed ExampleTest testMethod1 [passed] testMethod2 [passed] 参考 Test (JUnit 5.11.0 API) ","permalink":"https://0x1feb.github.io/posts/2024/09/08/understanding-junit-5-test-annotation/","summary":"概要 JUnit 5 の静的テストを整理する。 @Test 前提 JUnit 5 解説 @Test @Test アノテーションは、付与したメソッドがテストメソッドであることを表す。 以下の ExampleTest は、@Test","title":"JUnit 5 の静的テスト @Test を整理する"},{"content":"概要 JUnit 5 のライフサイクルを整理する。 @TestInstance TestInstance.Lifecycle.PER_METHOD TestInstance.Lifecycle.PER_CLASS @BeforeAll @AfterAll @BeforeEach @AfterEach 前提 JUnit 5 説明 ライフサイクル JUnit 5 のテストクラスは、以下の 2 つのライフサイクルがある。\nTestInstance.Lifecycle.PER_METHOD メソッド単位でテストクラスオブジェクトが生成される。 TestInstance.Lifecycle.PER_CLASS クラス単位でテストクラスオブジェクトが生成される。 テストクラスのライフサイクルは、テストクラスに @TestInstance アノテーションを付与することで設定できる。@TestInstance を付与していない場合のデフォルトのライフサイクルは、PER_METHOD である。\nまた、次のアノテーションを付与したメソッドは、各テストの前後で実行される。\n@BeforeAll 現在のテストクラスの全てのテストの前に実行される。 @AfterAll 現在のテストクラスの全てのテストの後に実行される。 @BeforeEach 現在のテストクラスの各テストメソッドの前に実行される。 @AfterEach 現在のテストクラスの各テストメソッドの後に実行される。 続いて、テストクラスのライフサイクル毎の詳細な動きを確認する。\nTestInstance.Lifecycle.PER_METHOD (default) 以下の LifecyclePerMethodTest クラスは、@TestInstance(TestInstance.Lifecycle.PER_METHOD) を付与しているため、ライフサイクルに PER_CLASS が適用されている。(何も付与しない場合も、PER_CLASS がデフォルト値として適用される。)\n処理内容は、呼び出されたらその旨をログ出力するだけである。テストメソッドでは、クラスのインスタンス変数である count を 1 増やし、増やした後の count の値も出力している。\npackage lifecycle; import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.core.Logger; import org.junit.jupiter.api.*; @TestInstance(TestInstance.Lifecycle.PER_METHOD) class LifecyclePerMethodTest { static private final Logger LOG = (Logger) LogManager.getLogger(); private int count = 0; LifecyclePerMethodTest() { LOG.info(\u0026#34;called LifecycleTest()\u0026#34;); } @BeforeAll static void initAll() { LOG.info(\u0026#34;called @BeforeAll initAll()\u0026#34;); } @AfterAll static void AfterAll() { LOG.info(\u0026#34;called @AfterAll AfterAll()\u0026#34;); } @BeforeEach void init() { LOG.info(\u0026#34;called @BeforeEach init()\u0026#34;); } @AfterEach void tearDown() { LOG.info(\u0026#34;called @AfterEach tearDown()\u0026#34;); } @Test void test1() { count++; LOG.info(\u0026#34;called @Test test1(), count={}\u0026#34;, count); } @Test void test2() { count++; LOG.info(\u0026#34;called @Test test2(), count={}\u0026#34;, count); } } ライフサイクルが PER_METHOD のとき、@BeforeAll と @AfterAll は、static メソッドにする必要がある。static メソッドではなくインスタンスメソッドを使いたい場合は、後述する PER_CLASS のライフサイクルを使用する。\nLifecyclePerMethodTest の実行結果は次の通りである。\n18:57:11.644 [Test worker] INFO lifecycle.LifecyclePerMethodTest - called @BeforeAll initAll() 18:57:11.652 [Test worker] INFO lifecycle.LifecyclePerMethodTest - called LifecycleTest() 18:57:11.658 [Test worker] INFO lifecycle.LifecyclePerMethodTest - called @BeforeEach init() 18:57:11.667 [Test worker] INFO lifecycle.LifecyclePerMethodTest - called @Test test1(), count=1 18:57:11.670 [Test worker] INFO lifecycle.LifecyclePerMethodTest - called @AfterEach tearDown() 18:57:11.678 [Test worker] INFO lifecycle.LifecyclePerMethodTest - called LifecycleTest() 18:57:11.679 [Test worker] INFO lifecycle.LifecyclePerMethodTest - called @BeforeEach init() 18:57:11.680 [Test worker] INFO lifecycle.LifecyclePerMethodTest - called @Test test2(), count=1 18:57:11.680 [Test worker] INFO lifecycle.LifecyclePerMethodTest - called @AfterEach tearDown() 18:57:11.683 [Test worker] INFO lifecycle.LifecyclePerMethodTest - called @AfterAll AfterAll() 整理すると、以下の順番で全てのテストを実行している。\n@BeforeAll のメソッドを実行する。 1 つ目のテストを以下の順で実行する。 テストクラスのコンストラクタを実行する。(テストクラスのオブジェクト生成) @BeforeEach のメソッドを実行する。 @Test のメソッドを実行する。 @AfterEach のメソッドを実行する。 2 つ目のテストを以下の順で実行する。 テストクラスのコンストラクタを実行する。(テストクラスのオブジェクト生成) @BeforeEach のメソッドを実行する。 @Test のメソッドを実行する。 @AfterEach のメソッドを実行する。 @AfterAll のメソッドを実行する。 テストメソッド単位で、テストクラスのオブジェクトを新たに生成していることがわかる。そのため、あるテストメソッドでの実行内容は、他のテストメソッドの実行内容に影響しない。\n今回の例だと、テストクラスのインスタンス変数 count は、テストメソッド毎に別のインスタンスの count を参照しているため、どちらも 1 となる。\nTestInstance.Lifecycle.PER_CLASS 以下の LifecyclePerClassTest クラスは、@TestInstance(TestInstance.Lifecycle.PER_CLASS) を付与しているため、ライフサイクルに PER_CLASS が適用されている。\n処理内容は、PER_METHOD のクラスと同じである。\npackage lifecycle; import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.core.Logger; import org.junit.jupiter.api.*; @TestInstance(TestInstance.Lifecycle.PER_CLASS) class LifecyclePerClassTest { static private final Logger LOG = (Logger) LogManager.getLogger(); private int count = 0; LifecyclePerClassTest() { LOG.info(\u0026#34;called LifecycleTest()\u0026#34;); } @BeforeAll void initAll() { LOG.info(\u0026#34;called @BeforeAll initAll()\u0026#34;); } @AfterAll void AfterAll() { LOG.info(\u0026#34;called @AfterAll AfterAll()\u0026#34;); } @BeforeEach void init() { LOG.info(\u0026#34;called @BeforeEach init()\u0026#34;); } @AfterEach void tearDown() { LOG.info(\u0026#34;called @AfterEach tearDown()\u0026#34;); } @Test void test1() { count++; LOG.info(\u0026#34;called @Test test1(), count={}\u0026#34;, count); } @Test void test2() { count++; LOG.info(\u0026#34;called @Test test2(), count={}\u0026#34;, count); } } ライフサイクルが PER_CLASS のとき、@BeforeAll と @AfterAll は、static メソッドではなく、インスタンスメソッドを使用できる。\nLifecyclePerClassTest の実行結果は次の通りである。\n19:07:33.183 [Test worker] INFO lifecycle.LifecyclePerClassTest - called LifecycleTest() 19:07:33.197 [Test worker] INFO lifecycle.LifecyclePerClassTest - called @BeforeAll initAll() 19:07:33.202 [Test worker] INFO lifecycle.LifecyclePerClassTest - called @BeforeEach init() 19:07:33.211 [Test worker] INFO lifecycle.LifecyclePerClassTest - called @Test test1(), count=1 19:07:33.213 [Test worker] INFO lifecycle.LifecyclePerClassTest - called @AfterEach tearDown() 19:07:33.219 [Test worker] INFO lifecycle.LifecyclePerClassTest - called @BeforeEach init() 19:07:33.220 [Test worker] INFO lifecycle.LifecyclePerClassTest - called @Test test2(), count=2 19:07:33.220 [Test worker] INFO lifecycle.LifecyclePerClassTest - called @AfterEach tearDown() 19:07:33.223 [Test worker] INFO lifecycle.LifecyclePerClassTest - called @AfterAll AfterAll() 整理すると、以下の順番で全てのテストを実行している。\nテストクラスのコンストラクタを実行する。(テストクラスのオブジェクト生成) @BeforeAll のメソッドを実行する。 1 つ目のテストを以下の順で実行する。 @BeforeEach のメソッドを実行する。 @Test のメソッドを実行する。 @AfterEach のメソッドを実行する。 2 つ目のテストを以下の順で実行する。 @BeforeEach のメソッドを実行する。 @Test のメソッドを実行する。 @AfterEach のメソッドを実行する。 @AfterAll のメソッドを実行する。 テストクラス単位で、テストクラスのオブジェクトを新たに生成していることがわかる。そのため、あるテストメソッドでの実行内容は、他のテストメソッドの実行内容に影響する。\n今回の例だと、テストクラスのインスタンス変数 count は、テストメソッド毎に同じインスタンスの count を参照しているため、2 回目に実行されるテストの結果は 2 となる。\n参考 TestInstance (JUnit 5.11.0 API) BeforeAll (JUnit 5.11.0 API) AfterAll (JUnit 5.11.0 API) BeforeEach (JUnit 5.11.0 API) AfterEach (JUnit 5.11.0 API) ","permalink":"https://0x1feb.github.io/posts/2024/09/07/understanding-junit-5-lifecycle/","summary":"概要 JUnit 5 のライフサイクルを整理する。 @TestInstance TestInstance.Lifecycle.PER_METHOD TestInstance.Lifecycle.PER_CLASS @BeforeAll @AfterAll @BeforeEach @AfterEach 前提 JUnit 5 説明 ライフサイクル JUnit 5 のテストクラスは、以下の 2 つのライフサイクルがある。 TestInstance.Lifecycle.PER_METHOD メソッ","title":"JUnit 5 のライフサイクルを整理する"},{"content":"概要 JUnit 5 のテストクラスを整理する。 テストクラス @Nested 前提 JUnit 5 説明 テストクラス名 基本的には、テスト対象のクラス名の末尾に Test を付与したクラス名を使うと良い。\nJUnit は、デフォルトで以下の正規表現に一致するクラスがテストクラスとして検出される。\n^(Test.*|.+[.$]Test.*|.*Tests?)$ また、Maven Surefire Plugin を使っている場合、以下のクラスがデフォルトでテストクラスとして検出される。\n**/Test*.java **/*Test.java **/*Tests.java **/*TestCase.java テストクラス テストクラスとは、テストメソッドを少なくとも 1 つもつトップレベルまたは static な内部クラスである。\n例えば、以下の ExampleTest クラスは、@Test アノテーションが付与されたテストメソッドを持つため、テストクラスである。\nclass ExampleTest { @Test void testExampleMethod() { assertEquals(2, 1 + 1); } } 以下の ExampleInnerTest クラスは、@Test アノテーションが付与されたテストメソッドを持つ static な内部クラスであるため、テストクラスである。\npublic class ExampleTest { static class ExampleInnerTest { @Test void testExampleInnerMethod() { assertEquals(2, 1 + 1); } } } static であるため、外部クラスのインスタンスに依存せず動作する。static な内部クラスを使ってテストクラスを作成するメリットはあまりない気がするため、基本的にはトップレベルのクラス単位でテストクラスを作成する方が良いと思う。\n非 static な内部クラスを扱う場合は、後述する @Nested アノテーションを用いる必要がある。\n@Nested 以下の ExampleTest クラスは、@Nested アノテーションを付与した ExampleNestedTest クラスを内部クラスとして持っている。\nclass ExampleTest { private final int expected = 2; @Test void testExampleMethod() { assertEquals(expected, 1 + 1); } @Nested class ExampleNestedTest { @Test void testExampleNestedMethod1() { assertEquals(expected, 1 + 1); } } } このテストクラスは、testExampleMethod と testExampleNestedMethod1 をテストメソッドとして実行する。\nネストした内部クラスは、外部クラスの情報にアクセスすることができる。また、内部クラスで定義した情報に外部クラスからアクセスすることはできない。\nネストした内部クラス内で更に @Nested でネストした内部クラスを作成することもできる。\n参考 JUnit 5 User Guide ","permalink":"https://0x1feb.github.io/posts/2024/09/06/junit-5-test-classes/","summary":"概要 JUnit 5 のテストクラスを整理する。 テストクラス @Nested 前提 JUnit 5 説明 テストクラス名 基本的には、テスト対象のクラス名の末尾に Test を付与したクラス名を使う","title":"JUnit 5 のテストクラスを整理する"},{"content":"概要 JUnit 5 にて、 @DisplayName を付与したテストを実行しても、実行結果に @DisplayName で設定した名前が反映されない。 maven-surefire-plugin の設定を入れることで、@DisplayName が反映されるようになる。 前提 JUnit 5 Maven 3.8.x+ 手順 pom.xml に以下を設定する。\n... \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; ... \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-surefire-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.0\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;statelessTestsetReporter implementation=\u0026#34;org.apache.maven.plugin.surefire.extensions.junit5.JUnit5Xml30StatelessReporter\u0026#34;\u0026gt; \u0026lt;disable\u0026gt;false\u0026lt;/disable\u0026gt; \u0026lt;version\u0026gt;3.0.2\u0026lt;/version\u0026gt; \u0026lt;usePhrasedFileName\u0026gt;false\u0026lt;/usePhrasedFileName\u0026gt; \u0026lt;usePhrasedTestSuiteClassName\u0026gt;true\u0026lt;/usePhrasedTestSuiteClassName\u0026gt; \u0026lt;usePhrasedTestCaseClassName\u0026gt;true\u0026lt;/usePhrasedTestCaseClassName\u0026gt; \u0026lt;usePhrasedTestCaseMethodName\u0026gt;true\u0026lt;/usePhrasedTestCaseMethodName\u0026gt; \u0026lt;/statelessTestsetReporter\u0026gt; \u0026lt;consoleOutputReporter implementation=\u0026#34;org.apache.maven.plugin.surefire.extensions.junit5.JUnit5ConsoleOutputReporter\u0026#34;\u0026gt; \u0026lt;disable\u0026gt;false\u0026lt;/disable\u0026gt; \u0026lt;encoding\u0026gt;UTF-8\u0026lt;/encoding\u0026gt; \u0026lt;usePhrasedFileName\u0026gt;false\u0026lt;/usePhrasedFileName\u0026gt; \u0026lt;/consoleOutputReporter\u0026gt; \u0026lt;statelessTestsetInfoReporter implementation=\u0026#34;org.apache.maven.plugin.surefire.extensions.junit5.JUnit5StatelessTestsetInfoReporter\u0026#34;\u0026gt; \u0026lt;disable\u0026gt;false\u0026lt;/disable\u0026gt; \u0026lt;usePhrasedFileName\u0026gt;false\u0026lt;/usePhrasedFileName\u0026gt; \u0026lt;usePhrasedClassNameInRunning\u0026gt;true\u0026lt;/usePhrasedClassNameInRunning\u0026gt; \u0026lt;usePhrasedClassNameInTestCaseSummary\u0026gt;true\u0026lt;/usePhrasedClassNameInTestCaseSummary\u0026gt; \u0026lt;/statelessTestsetInfoReporter\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; ... 参考 Maven Surefire Plugin – Using JUnit 5 Platform ","permalink":"https://0x1feb.github.io/posts/2024/09/05/fixing-display-name-annotation-issue-in-maven-with-junit-5/","summary":"概要 JUnit 5 にて、 @DisplayName を付与したテストを実行しても、実行結果に @DisplayName で設定した名前が反映されない。 maven-surefire-plugin の設定を入れることで、@DisplayName が反","title":"Maven で JUnit 5 の @DisplayName が反映されない問題に対処する"},{"content":"概要 JUnit 5 について、最低限の動きを整理する。 @Test アノテーション assertEquals fail 前提 JUnit 5 Java 8 (or higher) 今回のサンプルは Java 21 で作成 手順 ライブラリの設定 JUnit 5 User Guide の以下の章を参照し、環境に合わせて JUnit 5 に必要なライブラリを設定する。\n4.1. IDE Support | JUnit 5 User Guide 4.2. Build Support | JUnit 5 User Guide テスト対象クラスの作成 以下の Main クラスをテスト対象クラスとする。\npublic class Main { public Main() { } public String hello(String name) { return \u0026#34;Hello, %s.\u0026#34;.formatted(name); } public String bye(String name) { return \u0026#34;Bye, %s.\u0026#34;.formatted(name); } } 各メソッドは、引数の String を使って、メッセージを作成し、作成したメッセージを返却する。\n例えば、hello メソッドに文字列 \u0026quot;John Smith\u0026quot; を渡すと、文字列 \u0026quot;Hello, John Smith.\u0026quot; を返却する。\nテストクラスの作成 Main クラスに対するテストとして、MainTest クラスを作成する。\n大体の IDE には、Main クラスをもとに自動で MainTest を作成する機能がある。\nclass MainTest { @Test void testHello() { } @Test void testBye() { } } @Test アノテーションが付与されたメソッドは、テストメソッドとして扱われる。\n以下の状態でテストを実行すると、2 件中 2 件のテストがパスする。\nclass MainTest { @Test void testHello() { } @Test void testBye() { } } テストメソッドは、何もしなくても成功扱いになる。後述するが、未実装のテストコードは失敗するようにしておいた方が良い。\nテストメソッドの実装 今回は hello メソッドのテストメソッド testHello を実装する。\n完成した testHello は、以下の通りである。\n@Test void testHello() { // setup Main main = new Main(); final String name = \u0026#34;John Smith\u0026#34;; // exercise final String actual = main.hello(name); // verify final String expected = \u0026#34;Hello, John Smith.\u0026#34;; assertEquals(expected, actual); } テストコードは一度書いたら終わりというものではなく、次のような対応でメンテナンスが必要となる。\nテスト対象コードの変更に伴い、テストコードを修正する。 あるテストコードと別のテストコードの共通処理をまとめて整理する。 そのため、テストコードも可読性や保守性を意識して実装する。\n今回は、テストメソッドを以下の 3 段階に分けて記載する。\nsetup: テスト対象コード実行前の前処理 exercise: テスト対象コード実行処理 verify: テスト対象コード実行結果の検証処理 setup setup では、テスト対象コードを実行する前の準備処理を書く。\n// setup Main main = new Main(); final String name = \u0026#34;John Smith\u0026#34;; テスト対象クラスである Main クラスのインスタンスを作成している。また、hello メソッドの引数に渡す文字列 name を定義している。\nexercise exercise では、テスト対象メソッドの実行処理を書く。\n// exercise final String actual = main.hello(name); テスト対象クラスのインスタンスである main の hello メソッドを実行している。このとき、setup で準備した name を引数として渡している。\n実行結果は、actual に格納する。\nverify verify では、テスト対象コードの実行結果を検証する処理を書く。\n// verify final String expected = \u0026#34;Hello, John Smith.\u0026#34;; assertEquals(expected, actual); hello メソッドは String を返すため、期待する String と 実際の戻り値である String が一致すれば、正しく実装できていることを検証できる。\n期待する結果を expected に格納し、assertEquals メソッドで、期待する結果 expected と実際の結果 actual が等しいか検証する。\n未実装のテストコード テストメソッド testHello は実装したが、testBye は未実装である。\n@Test void testBye() { } しかし、上記のコードだと、実行してもテスト自体はパスしてしまう。そのため、実装忘れを防ぐために、以下のコードを実装しておく。\n@Test void testBye() { fail(\u0026#34;Not yet implemented\u0026#34;); } fail メソッドは、実行されるとテストが失敗したことになる。\nテストの実行 今回は、テストメソッド testHello を実装し、testBye は未実装として常に失敗するようにした。\nclass MainTest { @Test void testHello() { // setup Main test = new Main(); final String name = \u0026#34;John Smith\u0026#34;; // exercise final String actual = test.hello(name); // verify final String expected = \u0026#34;Hello, John Smith.\u0026#34;; assertEquals(expected, actual); } @Test void testBye() { fail(\u0026#34;Not yet implemented\u0026#34;); } } テストは、クラス単位やメソッド単位でも実行できる。\n今回の MainTest を実行すると、次の結果になる。\ntestHello: pass testBye: fail (Not yet implemented) testHello が失敗している場合、hello メソッドまたは testHello メソッドに誤りがある。テストの実行結果に詳細が出力されるため、その内容をもとに修正する。\n参考 JUnit 5 User Guide ","permalink":"https://0x1feb.github.io/posts/2024/09/04/writing-test-code-in-java-using-junit-5/","summary":"概要 JUnit 5 について、最低限の動きを整理する。 @Test アノテーション assertEquals fail 前提 JUnit 5 Java 8 (or higher) 今回のサンプルは Java 21 で作成 手順 ライブラリの設定 JUnit 5 User Guide の以下の","title":"JUnit 5 で Java のテストコードを作成する"},{"content":"概要 Ubuntu のセキュリティアップデートを定期実行し、必要に応じて再起動する。 前提 Ubuntu 22.04 LTS 手順 自動アップデートの設定 任意のエディタで 20auto-upgrades を開く。\nsudo vi /etc/apt/apt.conf.d/20auto-upgrades APT::Periodic::Update-Package-Lists \u0026#34;1\u0026#34;; APT::Periodic::Unattended-Upgrade \u0026#34;1\u0026#34;; 以下の項目について、更新頻度を設定する。\nAPT::Periodic::Update-Package-Lists パッケージリストを自動的に更新する頻度 (日単位) を指定する。 0 は無効となる。 APT::Periodic::Unattended-Upgrade 自動アップグレードの頻度 (日単位) を指定する。 0 は無効となる。 デフォルトでは 1 が設定されており、 1 日毎に更新される。\n更新対象/自動再起動の設定 任意のエディタで 50unattended-upgrades を開く。\nvi /etc/apt/apt.conf.d/50unattended-upgrades Unattended-Upgrade::Allowed-Origins { \u0026#34;${distro_id}:${distro_codename}\u0026#34;; \u0026#34;${distro_id}:${distro_codename}-security\u0026#34;; // Extended Security Maintenance; doesn\u0026#39;t necessarily exist for // every release and this system may not have it installed, but if // available, the policy for updates is such that unattended-upgrades // should also install from here by default. \u0026#34;${distro_id}ESMApps:${distro_codename}-apps-security\u0026#34;; \u0026#34;${distro_id}ESM:${distro_codename}-infra-security\u0026#34;; // \u0026#34;${distro_id}:${distro_codename}-updates\u0026#34;; // \u0026#34;${distro_id}:${distro_codename}-proposed\u0026#34;; // \u0026#34;${distro_id}:${distro_codename}-backports\u0026#34;; }; Unattended-Upgrade::Allowed-Origins にて、許可対象を指定する。\nデフォルトでは、-security 系が設定されている。セキュリティ系以外も自動更新したい場合は、コメントアウトする。\n// Automatically reboot *WITHOUT CONFIRMATION* if // the file /var/run/reboot-required is found after the upgrade Unattended-Upgrade::Automatic-Reboot \u0026#34;true\u0026#34;; // Automatically reboot even if there are users currently logged in // when Unattended-Upgrade::Automatic-Reboot is set to true Unattended-Upgrade::Automatic-Reboot-WithUsers \u0026#34;false\u0026#34;; // If automatic reboot is enabled and needed, reboot at the specific // time instead of immediately // Default: \u0026#34;now\u0026#34; Unattended-Upgrade::Automatic-Reboot-Time \u0026#34;03:00\u0026#34;; 以下の項目にて、再起動に関する設定をする。\nUnattended-Upgrade::Automatic-Reboot 自動アップグレード後に再起動するかどうかを設定する。 デフォルトは無効に設定されている。 Unattended-Upgrade::Automatic-Reboot-WithUsers システムにログイン中のユーザがいても再起動するかを設定する。 デフォルトは無効に設定されている。 Unattended-Upgrade::Automatic-Reboot-Time 再起動が必要となった場合に再起動する時刻を設定する。 デフォルトは \u0026quot;now\u0026quot; が設定されており、再起動が必要となったら直ぐに再起動する。 上記の設定では、「再起動が必要」かつ「03:00」かつ「ログインユーザがいない」場合に自動で再起動する。\n設定の確認 --dry-run を付与すると、実際に更新を適用せずに、実行結果をシミュレートできる。\nsudo unattended-upgrade --debug --dry-run ログファイルは以下に出力される。\ncd /var/log/unattended-upgrades ","permalink":"https://0x1feb.github.io/posts/2024/09/02/automating-security-updates-and-reboots-on-ubuntu/","summary":"概要 Ubuntu のセキュリティアップデートを定期実行し、必要に応じて再起動する。 前提 Ubuntu 22.04 LTS 手順 自動アップデートの設定 任意のエディタで 20auto-upgrades を開く。 sudo vi /etc/apt/apt.conf.d/20auto-upgrades APT::Periodic::Update-Package-Lists","title":"Ubuntu のセキュリティアップデートを定期実行/自動再起動する"},{"content":"概要 JUnit 4 のテストコードを JUnit 5 に移行する。 JUnit 4 のテストコードはそのままにして、新規のテストコードは JUnit 5 で作成する。 前提 JUnit 4 JUnit 5 手順 JUnit 5 ライブラリの追加 junit5-samples/junit5-migration-maven at main · junit-team/junit5-samples を参考に、pom.xml を更新する。\njunit-vintage-engine を使うことで、JUnit 3 や JUnit 4 の API を使って書かれたテストも実行できるようになる。\n\u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-bom\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.11.0\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagemen\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.junit.jupiter\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-jupiter-api\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.13.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.junit.jupiter\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-jupiter-engine\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; この状態で JUnit 4 で書かれたコードが実行できることを確認する。\nJUnit 4 のテストコード更新 JUnit 4 で書かれたテストコードを修正し、JUnit 5 で動くようにする。\nアノテーション @Test 等のアノテーションは、パッケージが変わる。\nversion package JUnit 4 org.junit.* JUnit 5 org.junit.jupiter.api.* いくつかのアノテーションは、名前が変わる。\nJUnit 4 JUnit 5 @Before,@After @BeforeEach, @AfterEach @BeforeClass,@AfterClass @BeforeAll,@AfterAll @Ignore @Disabled @Category @Tag @RunWith @ExtendWith @Rule や @ClassRule を使っている個所は、@ExtendWith と @RegisterExtension を使って実装する。 以下の JUnit 4 のルールは、 junit-jupiter-migrationsupport を入れることで使い続けることもできる。 org.junit.rules.ExternalResource (including org.junit.rules.TemporaryFolder) org.junit.rules.Verifier (including org.junit.rules.ErrorCollector) org.junit.rules.ExpectedException @Test(expected = …​) と ExpectedException を使ったルールは、Assertions.assertThrows(…​) を使って実装する。 アサーション AssertEquals 等のアサーションは、パッケージが変わる。\nversion package JUnit 4 org.junit.Assert.* JUnit 5 org.junit.jupiter.api.Assertions.* org.junit.Assert やその他のアサーションライブラリ (AssertJ, Hamcrest, Truth) を使い続けることもできる。\nアサーションの引数にメッセージを含めて呼び出している場合、メッセージの引数の位置が変わる。\nversion package JUnit 4 assertEquals(String message, Object expected, Object actual) JUnit 5 assertEquals(Object expected, Object actual, String message) JUnit 4 ライブラリの削除 JUnit 4 のテストコードを全て JUnit 5 で動作するよう修正したら、pom.xml から JUnit 4 のライブラリと junit-vintage-engine を削除する。\nこの状態でテストを実行し、問題なく動作すれば以降は完了となる。\n参考 junit5-samples/junit5-migration-maven at main · junit-team/junit5-samples 3. Migrating from JUnit 4 | JUnit 5 User Guide ","permalink":"https://0x1feb.github.io/posts/2024/09/01/migrating-from-junit-4-to-junit-5/","summary":"概要 JUnit 4 のテストコードを JUnit 5 に移行する。 JUnit 4 のテストコードはそのままにして、新規のテストコードは JUnit 5 で作成する。 前提 JUnit 4 JUnit 5 手順 JUnit 5 ライブラ","title":"JUnit 4 から JUnit 5 に移行する"},{"content":"概要 Jakarta Faces 4.0 の XHTML にて、\u0026lt;h:outputScript\u0026gt; に defer/async 属性を付与できなかった。 \u0026lt;script src=\u0026quot;...\u0026quot; defer=\u0026quot;defer\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; タグを使って読み込むことで対応した。 前提 Jakarta Faces 4.0 実装 src/main/webapp/resources/js/main.js を defer 属性で読み込む。 修正前 \u0026lt;h:outputScript library=\u0026#34;js\u0026#34; src=\u0026#34;main.js\u0026#34; /\u0026gt; なお、以下のような記載にしても、defer や async は反映されなかった。\n\u0026lt;h:outputScript library=\u0026#34;js\u0026#34; src=\u0026#34;main.js\u0026#34; defer=\u0026#34;defer\u0026#34; /\u0026gt; 修正後 \u0026lt;script src=\u0026#34;#{resource[\u0026#39;js/main.js\u0026#39;]}\u0026#34; defer=\u0026#34;defer\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; XHTML では、defer=\u0026quot;defer\u0026quot; のように、属性名を明示的に指定する必要がある。\n参考 outputScript (Jakarta Faces 4.0.0 VDL Documentation) XHTML 1.0： The Extensible HyperText Markup Language (Second Edition) ","permalink":"https://0x1feb.github.io/posts/2024/08/02/loading-javascript-with-defer-or-async-attributes-in-jakarta-faces-4.0/","summary":"概要 Jakarta Faces 4.0 の XHTML にて、\u0026lt;h:outputScript\u0026gt; に defer/async 属性を付与できなかった。 \u0026lt;script src=\u0026quot;...\u0026quot; defer=\u0026quot;defer\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; タグを使って読み込むことで対応した。 前提 Jakarta","title":"Jakarta Faces 4.0 で JavaScript を defer/async で読み込む"},{"content":"概要 tailscale で自宅サーバを VPN サーバとして使用する。 外部ネットワークから、自宅サーバ上で動かしている各サービスを利用する。 tailscale のネットワーク (100.64.0.0/10) で自宅サービスを公開するのではなく、自宅 LAN (ex.192.168.1.0/24) で閉じたサービスに tailscale 経由で接続する。 前提 tailscale 1.68.2 Ubuntu 22.04 LTS 手順 tailscale のインストール tailscale に登録し、各端末に tailscale をインストールする。\nDownload · Tailscale 設定と登録が終わると、tailscale が割り当てた IP アドレスやホスト名で各端末同士が P2P 通信で接続できるようになる。\nExit nodes の設定 Exit node は、tailscale ネットワークを介してトラフィックをルーティングするデバイスである。\n今回は、自宅サーバとして稼働している Ubuntu 22.04 LTS を Exit node に設定する。\n以下のコマンドを実行し、IP フォワードの設定を有効化する。\necho \u0026#39;net.ipv4.ip_forward = 1\u0026#39; | sudo tee -a /etc/sysctl.d/99-tailscale.conf echo \u0026#39;net.ipv6.conf.all.forwarding = 1\u0026#39; | sudo tee -a /etc/sysctl.d/99-tailscale.conf sudo sysctl -p /etc/sysctl.d/99-tailscale.conf 次のオプションを付与して tailscale set コマンドを実行する。\n--advertise-routes=192.168.1.0/24: ルーティングする自宅 LAN のネットワーク (ex. 192.168.1.0/24) を指定する。 --advertise-exit-node: exit node を設定する。 sudo tailscale up --advertise-routes=192.168.1.0/24 --advertise-exit-node tailscale のウェブコンソールに接続し、Machines から Exit node を設定する端末の Edit route settings... を選択する。\n以下にチェックを入れ、Save をクリックする。\nSubnet routes \u0026gt; 192.168.1.0/24 Exit node \u0026gt; Use as exit node クライアントの設定 tailscale クライアントの設定にて、end nodes から設定した端末を選択し、接続する。\nLinux 系の OS から接続する場合は、次のコマンドを実行する。\nsudo tailscale up --accept-routes --exit-node=\u0026lt;ip|name\u0026gt; 自宅 LAN 内の各サービスに接続できることを確認する。\nファイアウォールの設定 スマホの回線から接続したところ、relay \u0026quot;tok\u0026quot; と表示される。\n$ tailscale status ... 100.64.x.x phone example@ android active; relay \u0026#34;tok\u0026#34;, tx 33084 rx 11508 ... これは、directly 接続ではなく、DERP relay 接続のときに表示される。\nUDP の 41641 ポートを許可すると、directly 接続になるかもしれないとのこと。\nsudo ufw allow 41641/udp 上記だけでは解決せず、STUN サーバとの通信用ポートを開けたところ、directly 接続になった。\nsudo ufw allow 3478/udp 参考 Exit nodes (route all traffic) · Tailscale Docs Subnet routers and traffic relay nodes · Tailscale Docs Using Tailscale with your firewall · Tailscale Docs What firewall ports should I open to use Tailscale? · Tailscale Docs Tailscale CLI · Tailscale Docs ","permalink":"https://0x1feb.github.io/posts/2024/07/07/connecting-to-home-lan-with-tailscale/","summary":"概要 tailscale で自宅サーバを VPN サーバとして使用する。 外部ネットワークから、自宅サーバ上で動かしている各サービスを利用する。 tailscale のネットワーク (100.64.0.0/10) で自宅サ","title":"tailscale で自宅 LAN に VPN 接続する"},{"content":"概要 div 要素を横に3つ並べたコンポーネントを作成したい。 1つ目と2つ目は固定幅で、3つ目は最大幅で表示する。 このコンポーネントを複数列で表示したい。 CSS grid layout を使って実現できそうだったので、記録しておく。 実装 index.html は次の通り。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;ja\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Grid Layout\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;styles.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Grid Layout\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;width 400\u0026lt;/h2\u0026gt; \u0026lt;div class=\u0026#34;main width-400\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;grid\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col fixed-50\u0026#34;\u0026gt;A1-1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col fixed-75\u0026#34;\u0026gt;A1-2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col expand\u0026#34;\u0026gt;A1-3\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;grid\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col fixed-50\u0026#34;\u0026gt;A2-1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col fixed-75\u0026#34;\u0026gt;A2-2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col expand\u0026#34;\u0026gt;A2-3\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;grid\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col fixed-50\u0026#34;\u0026gt;A3-1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col fixed-75\u0026#34;\u0026gt;A3-2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col expand\u0026#34;\u0026gt;A3-3\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;grid\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col fixed-50\u0026#34;\u0026gt;A4-1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col fixed-75\u0026#34;\u0026gt;A4-2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col expand\u0026#34;\u0026gt;A4-3\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;h2\u0026gt;width 800\u0026lt;/h2\u0026gt; \u0026lt;div class=\u0026#34;main width-800\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;grid\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col fixed-50\u0026#34;\u0026gt;A1-1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col fixed-75\u0026#34;\u0026gt;A1-2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col expand\u0026#34;\u0026gt;A1-3\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;grid\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col fixed-50\u0026#34;\u0026gt;A2-1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col fixed-75\u0026#34;\u0026gt;A2-2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col expand\u0026#34;\u0026gt;A2-3\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;grid\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col fixed-50\u0026#34;\u0026gt;A3-1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col fixed-75\u0026#34;\u0026gt;A3-2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col expand\u0026#34;\u0026gt;A3-3\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;grid\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col fixed-50\u0026#34;\u0026gt;A4-1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col fixed-75\u0026#34;\u0026gt;A4-2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col expand\u0026#34;\u0026gt;A4-3\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;h2\u0026gt;width 1200\u0026lt;/h2\u0026gt; \u0026lt;div class=\u0026#34;main width-1200\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;grid\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col fixed-50\u0026#34;\u0026gt;A1-1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col fixed-75\u0026#34;\u0026gt;A1-2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col expand\u0026#34;\u0026gt;A1-3\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;grid\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col fixed-50\u0026#34;\u0026gt;A2-1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col fixed-75\u0026#34;\u0026gt;A2-2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col expand\u0026#34;\u0026gt;A2-3\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;grid\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col fixed-50\u0026#34;\u0026gt;A3-1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col fixed-75\u0026#34;\u0026gt;A3-2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col expand\u0026#34;\u0026gt;A3-3\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;grid\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col fixed-50\u0026#34;\u0026gt;A4-1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col fixed-75\u0026#34;\u0026gt;A4-2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col expand\u0026#34;\u0026gt;A4-3\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; styles.css は次の通り。\nbody { margin: 0; padding: 10px; font-family: Arial, sans-serif; } .main { margin: 10px; padding: 10px; border: #ccc solid 1px; } .width-400 { width: 400px; } .width-800 { width: 800px; } .width-1200 { width: 1200px; } .container { display: grid; grid-template-columns: 1fr 1fr; gap: 4px; padding: 10px; } .grid { display: grid; grid-template-columns: auto auto 1fr; gap: 2px; width: 100%; } .row { display: contents; } .col { background-color: #ccc; text-align: center; border: #000 solid 1px; } .fixed-50 { width: 50px; } .fixed-75 { width: 75px; } .expand { width: 100%; } 実行結果は、Playground にて試すことができる。\nGrit を使うと、方眼紙上の好きな位置に要素を配置するようなイメージでレイアウトを作成できる。重ね合わせたり、入れ子にすることもできるため、複雑なレイアウトも簡単に実装できる。\n参考 CSS grid layout - CSS： Cascading Style Sheets ｜ MDN ","permalink":"https://0x1feb.github.io/posts/2024/07/03/using-css-grid-layout-to-position-div-elements/","summary":"概要 div 要素を横に3つ並べたコンポーネントを作成したい。 1つ目と2つ目は固定幅で、3つ目は最大幅で表示する。 このコンポーネントを複数列で表示し","title":"CSS grid layout を使って div 要素を配置する"},{"content":"概要 Ubuntu のファイアウォールを設定し、アクセスルールを変更する。 前提 Ubuntu 22.04 LTS 注意点 SSH 等のリモート接続で作業する場合、ファイアウォールの設定を間違えると、接続できなくなる可能性がある。 ファイアウォールの設定後には、SSH セッションを切断する前に、別セッションで SSH 接続できることを確認してから切断すること。 手順 ファイアウォールの状態確認 ファイアウォールのステータスを確認する。\nsudo ufw status Status: inactive もしインストールされていない場合は、インストールする。\nsudo apt install ufw ファイアウォールの有効化/無効化 以下のコマンドでファイアウォールを有効化する。\nsudo ufw enable SSH で接続している場合は、既存の接続が切断される可能性があるため、確認のダイアログが出る。\nCommand may disrupt existing ssh connections. Proceed with operation (y|n)? y Firewall is active and enabled on system startup 今回は SSH 接続で作業したが、既存の接続が切断されることはなく維持された。\nファイアウォールが有効化し、システム起動時に自動起動するようになる。\n無効化する場合は、以下のコマンドを実行する。\nsudo ufw disable Firewall stopped and disabled on system startup デフォルトルールの確認 以下のコマンドで、デフォルトのルールを確認する。\nsudo ufw status verbose Status: active Logging: on (low) Default: deny (incoming), allow (outgoing), disabled (routed) New profiles: skip ログがオンになっている場合、/var/log/ufw.log にて確認できる。\nデフォルトの通信ルールは、次の設定になっている。\ndeny (incoming): 全てのインバウンド通信を拒否する。 allow (outgoing): 全てのアウトバウンド通信を許可する。 この場合、許可したいインバウンドの通信と拒否したいアウトバウンドの通信をルールに追加していく。\nデフォルトの設定を変更する場合は、次のコマンドを実行する。\nsudo ufw default deny incoming sudo ufw default allow outgoing 通信ルールの追加 次のコマンドでルールを追加する。\nsudo ufw {allow/deny} {port}/{protocol} protocol は、tcp か udp を指定できる。(省略可)\n例えば、SSH の 22 ポートを許可したい場合は、次のコマンドを実行する。\nsudo ufw allow 22/tcp Rule added Rule added (v6) 特定の IP アドレスから特定のポートへの接続を許可したい場合は、次のコマンドを実行する。\n# 個別IP指定 sudo ufw allow proto tcp from 192.168.1.5 to any port 8080 # セグメント指定 sudo ufw allow proto tcp from 192.168.1.0/24 to any port 8080 通信ルールの削除 次のコマンドでルールを削除する。\nsudo ufw delete allow {port}/{protocol} 例えば、SSH の 22 ポートの許可ルールを削除したい場合は、次のコマンドを実行する。\n# ルール指定 sudo ufw delete allow 22/tcp # ルール番号指定 sudo ufw delete 2 Rule deleted Rule deleted (v6) ルールの番号指定で削除する場合、以下のコマンドで番号を確認する。\nsudo ufw status numbered Status: active To Action From -- ------ ---- [ 1] 80 ALLOW IN Anywhere [ 2] 22/tcp ALLOW IN Anywhere sudo ufw delete 2 対象ルールを確認し、y を入力すると削除する。\nDeleting: allow 22/tcp Proceed with operation (y|n)? y Rule deleted ","permalink":"https://0x1feb.github.io/posts/2024/06/30/how-to-configure-a-firewall-on-ubuntu-22.04-lts/","summary":"概要 Ubuntu のファイアウォールを設定し、アクセスルールを変更する。 前提 Ubuntu 22.04 LTS 注意点 SSH 等のリモート接続で作業する場合、ファイアウォールの設定を間違え","title":"Ubuntu 22.04 LTS のファイアーウォールを設定する"},{"content":"概要 ローカル環境に Git のリモートリポジトリを作成し、push や pull で管理できるようにする。 前提 git version 2.45.2 手順 リモートリポジトリの作成 リモートリポジトリには作業ディレクトリを含まないようにするため、--bare オプションを付与してリポジトリを作成する。\ngit init --bare ~/remote-repo.git ローカルリポジトリの作成 ローカルリポジトリを作成する。\ngit init ~/local-repo 作成したローカルリポジトリに移動する。\ncd ~/local-repo 任意のファイルを作成し、コミットする。\ngit add . git commit -m \u0026#34;initial commit\u0026#34; リモートリポジトリのパスを追加し、プッシュする。\ngit remote add origin ~/remote-repo.git git push origin main リモートリポジトリからの取得 リモートリポジトリからローカルリポジトリを作成する。\ngit clone ~/remote-repo.git 最新の変更を取得する。\ngit pull origin main 参考 Git - Getting Git on a Server ","permalink":"https://0x1feb.github.io/posts/2024/06/28/creating-a-git-remote-repository-in-a-local-enviroment/","summary":"概要 ローカル環境に Git のリモートリポジトリを作成し、push や pull で管理できるようにする。 前提 git version 2.45.2 手順 リモートリポジトリの作成 リモートリポジト","title":"ローカル環境に Git のリモートリポジトリを作成する"},{"content":"概要 SSD を /data にマウントしているが、/data 配下のファイルアクセスに失敗することがある。 特定ファイルが読み取り専用扱いになり、更新できなくなる。 /data のマウントが解除される。 原因を調査したときの記録である。 前提 Ubuntu 22.04 LTS 手順 ディスクの状態を調べる 「SSD の SMART を調べる」の手順で SMART を調べた。\n結果は特に問題なかった。\nシステムのカーネルログを調べる sudo dmesg -T [Thu Jun 27 03:39:15 2024] ata2: COMRESET failed (errno=-32) [Thu Jun 27 03:39:15 2024] ata2: reset failed (errno=-32), retrying in 8 secs [Thu Jun 27 03:39:26 2024] ata2: SATA link down (SStatus 0 SControl 310) [Thu Jun 27 03:39:26 2024] ata2: SATA link down (SStatus 0 SControl 310) [Thu Jun 27 03:39:27 2024] ata2: SATA link down (SStatus 0 SControl 310) [Thu Jun 27 03:39:27 2024] ata2.00: disabled [Thu Jun 27 03:39:27 2024] ata2: SATA link down (SStatus 0 SControl 300) [Thu Jun 27 03:39:27 2024] ata2.00: detaching (SCSI 1:0:0:0) [Thu Jun 27 03:39:27 2024] blk_update_request: I/O error, dev sdd, sector 0 op 0x1:(WRITE) flags 0x800 phys_seg 0 prio class 0 [Thu Jun 27 03:39:27 2024] ata2: limiting SATA link speed to 1.5 Gbps [Thu Jun 27 03:39:28 2024] Buffer I/O error on dev sdd1, logical block 124813312, lost sync page write [Thu Jun 27 03:39:28 2024] JBD2: Error -5 detected when updating journal superblock for sdd1-8. [Thu Jun 27 03:39:28 2024] Aborting journal on device sdd1-8. [Thu Jun 27 03:39:28 2024] Buffer I/O error on dev sdd1, logical block 124813312, lost sync page write [Thu Jun 27 03:39:28 2024] JBD2: Error -5 detected when updating journal superblock for sdd1-8. [Thu Jun 27 03:39:28 2024] EXT4-fs error (device sdd1): ext4_put_super:1196: comm umount: Couldn\u0026#39;t clean up the journal [Thu Jun 27 03:39:28 2024] EXT4-fs (sdd1): Remounting filesystem read-only [Thu Jun 27 03:39:28 2024] sd 1:0:0:0: [sdd] Synchronizing SCSI cache [Thu Jun 27 03:39:28 2024] ata2: SATA link down (SStatus 0 SControl 310) [Thu Jun 27 03:39:28 2024] sd 1:0:0:0: [sdd] Synchronize Cache(10) failed: Result: hostbyte=DID_BAD_TARGET driverbyte=DRIVER_OK [Thu Jun 27 03:39:28 2024] sd 1:0:0:0: [sdd] Stopping disk [Thu Jun 27 03:39:28 2024] sd 1:0:0:0: [sdd] Start/Stop Unit failed: Result: hostbyte=DID_BAD_TARGET driverbyte=DRIVER_OK [Thu Jun 27 03:39:29 2024] ata2: limiting SATA link speed to 1.5 Gbps [Thu Jun 27 03:39:32 2024] ata2: COMRESET failed (errno=-32) [Thu Jun 27 03:39:32 2024] ata2: reset failed (errno=-32), retrying in 8 secs [Thu Jun 27 03:39:41 2024] ata2: SATA link down (SStatus 0 SControl 310) [Thu Jun 27 03:39:41 2024] ata2: limiting SATA link speed to 1.5 Gbps ... [Thu Jun 27 03:40:51 2024] ata2: COMRESET failed (errno=-32) [Thu Jun 27 03:40:51 2024] ata2: reset failed (errno=-32), retrying in 33 secs [Thu Jun 27 03:41:25 2024] ata2: SATA link up 1.5 Gbps (SStatus 113 SControl 310) [Thu Jun 27 03:41:25 2024] ata2.00: ATA-9: SPCC Solid State Disk, W0704A0, max UDMA/133 [Thu Jun 27 03:41:25 2024] ata2.00: 2000409264 sectors, multi 1: LBA48 NCQ (depth 32), AA [Thu Jun 27 03:41:25 2024] ata2.00: configured for UDMA/133 [Thu Jun 27 03:41:25 2024] scsi 1:0:0:0: Direct-Access ATA SPCC Solid State 4A0 PQ: 0 ANSI: 5 [Thu Jun 27 03:41:25 2024] sd 1:0:0:0: Attached scsi generic sg0 type 0 [Thu Jun 27 03:41:25 2024] sd 1:0:0:0: [sda] 2000409264 512-byte logical blocks: (1.02 TB/954 GiB) [Thu Jun 27 03:41:25 2024] sd 1:0:0:0: [sda] Write Protect is off [Thu Jun 27 03:41:25 2024] sd 1:0:0:0: [sda] Mode Sense: 00 3a 00 00 [Thu Jun 27 03:41:25 2024] sd 1:0:0:0: [sda] Write cache: enabled, read cache: enabled, doesn\u0026#39;t support DPO or FUA [Thu Jun 27 03:41:25 2024] sda: sda1 [Thu Jun 27 03:41:25 2024] sd 1:0:0:0: [sda] Attached SCSI disk [Thu Jun 27 08:57:33 2024] EXT4-fs (sda1): recovery complete [Thu Jun 27 08:57:33 2024] EXT4-fs (sda1): mounted filesystem with ordered data mode. Opts: (null). Quota mode: none. エラーログ前半部分の詳細を調べてみる。\nata2: COMRESET failed (errno=-32) ata2 ポートでの COMRESET (SATA リンクのリセット) に失敗した。 ata2: reset failed (errno=-32), retrying in 8 secs ata2 ポートでのリセットに失敗したため、8秒後に再試行する。 ata2: SATA link down (SStatus 0 SControl 310) ata2 ポートで SATA リンクがダウンしている。 ata2.00: disabled ata2 ポートのデバイスが無効化された。 ata2.00: detaching (SCSI 1:0:0:0) ata2 ポートのデバイスが切り離された。 blk_update_request: I/O error, dev sdd, sector 0 op 0x1:(WRITE) flags 0x800 phys_seg 0 prio class 0 デバイス sdd に対する書き込み操作中に I/O エラーが発生した。 ata2: limiting SATA link speed to 1.5 Gbps エラーを減少させるため、ata2 ポートのSATAリンク速度を1.5 Gbpsに制限した。 Buffer I/O error on dev sdd1, logical block 124813312, lost sync page write デバイス sdd1 の論理ブロック 124813312 でバッファ I/O エラーが発生し、ページの書き込みが同期しなかった。 JBD2: Error -5 detected when updating journal superblock for sdd1-8. デバイス sdd1-8 のジャーナルスーパーブロック更新中にエラー -5 が検出された。 Aborting journal on device sdd1-8. デバイス sdd1-8 のジャーナル操作が中止された。 EXT4-fs error (device sdd1): ext4_put_super:1196: comm umount: Couldn't clean up the journal デバイス sdd1 で EXT4 ファイルシステムエラーが発生し、ジャーナルのクリーンアップに失敗した。 EXT4-fs (sdd1): Remounting filesystem read-only データの損失を防ぐため、デバイス sdd1 のファイルシステムが読み取り専用モードで再マウントされた。 2024-06-27 08:57:33 に sudo mount -a で再マウントしたので、そのときのログが出ている。\n接続不良が原因でエラーが発生し、読み取り専用モードでマウントされている。ファイルが読み取り専用で更新できなくなったのは、この状態が原因と思われる。\n最終的にはアンマウントした状態になっていたため、接続を見直してしばらく様子を見ることにする。\n","permalink":"https://0x1feb.github.io/posts/2024/06/27/investigating-the-cause-of-an-unstable-disk-mount/","summary":"概要 SSD を /data にマウントしているが、/data 配下のファイルアクセスに失敗することがある。 特定ファイルが読み取り専用扱いになり、更新できなくなる","title":"ディスクのマウントが不安定なので原因を調べた"},{"content":"概要 SoftEther の VPN Azure (MS-SSTP Server) に Ubuntu で接続したい。 Ubuntu 24.04 LTS では、デフォルトの VPN 設定に SSTP が存在しない。 Ubuntu の VPN サーバクライアントに SSTP を設定できるようにする。 前提 Ubuntu 24.04 LTS 手順 network-manager-sstp-gnome をインストールする。\nsudo apt install network-manager-sstp-gnome GUI の VPN 設定に Secure Soket Tunneling Protocol (SSTP) が追加されていることを確認する。\n","permalink":"https://0x1feb.github.io/posts/2024/06/25/connecting-to-a-vpn-using-sstp-on-ubuntu/","summary":"概要 SoftEther の VPN Azure (MS-SSTP Server) に Ubuntu で接続したい。 Ubuntu 24.04 LTS では、デフォルトの VPN 設定に SSTP が存在しない。 Ubuntu の VPN サーバクライアントに SSTP を設定できるようにする。 前提 Ubuntu","title":"Ubuntu で SSTP を使用して VPN 接続する"},{"content":"概要 SSD の SMART 情報を表示し、故障してないか調べる。 前提 Ubuntu 22.04 LTS smartctl 7.2 手順 インストール sudo apt install smartmontools ディスクの検索 smartctl --scan /dev/sdb -d sat # /dev/sdb [SAT], ATA device /dev/sdc -d scsi # /dev/sdc, SCSI device /dev/nvme0 -d nvme # /dev/nvme0, NVMe device ディスクの SMART を取得 sudo smartctl /dev/nvme0 --all smartctl 7.2 2020-12-30 r5155 [x86_64-linux-5.15.0-112-generic] (local build) Copyright (C) 2002-20, Bruce Allen, Christian Franke, www.smartmontools.org === START OF INFORMATION SECTION === Model Number: 512GB SSD Serial Number: xxxxxxxxxxxxxx Firmware Version: SN12221 PCI Vendor/Subsystem ID: 0x1e4b IEEE OUI Identifier: 0x3a5a27 Total NVM Capacity: 512,110,190,592 [512 GB] Unallocated NVM Capacity: 0 Controller ID: 0 NVMe Version: 1.4 Number of Namespaces: 1 Namespace 1 Size/Capacity: 512,110,190,592 [512 GB] Namespace 1 Formatted LBA Size: 512 Namespace 1 IEEE EUI-64: 3a5a27 03600000c8 Local Time is: Sun Jun 23 16:08:07 2024 JST Firmware Updates (0x1a): 5 Slots, no Reset required Optional Admin Commands (0x0017): Security Format Frmw_DL Self_Test Optional NVM Commands (0x001f): Comp Wr_Unc DS_Mngmt Wr_Zero Sav/Sel_Feat Log Page Attributes (0x06): Cmd_Eff_Lg Ext_Get_Lg Maximum Data Transfer Size: 128 Pages Warning Comp. Temp. Threshold: 90 Celsius Critical Comp. Temp. Threshold: 95 Celsius Supported Power States St Op Max Active Idle RL RT WL WT Ent_Lat Ex_Lat 0 + 6.50W - - 0 0 0 0 0 0 1 + 5.80W - - 1 1 1 1 0 0 2 + 3.60W - - 2 2 2 2 0 0 3 - 0.7460W - - 3 3 3 3 5000 10000 4 - 0.7260W - - 4 4 4 4 8000 45000 Supported LBA Sizes (NSID 0x1) Id Fmt Data Metadt Rel_Perf 0 + 512 0 0 === START OF SMART DATA SECTION === SMART overall-health self-assessment test result: PASSED SMART/Health Information (NVMe Log 0x02) Critical Warning: 0x00 Temperature: 36 Celsius Available Spare: 100% Available Spare Threshold: 10% Percentage Used: 0% Data Units Read: 1,103,499 [564 GB] Data Units Written: 1,678,087 [859 GB] Host Read Commands: 4,284,806 Host Write Commands: 18,051,815 Controller Busy Time: 150 Power Cycles: 27 Power On Hours: 2,082 Unsafe Shutdowns: 4 Media and Data Integrity Errors: 0 Error Information Log Entries: 0 Warning Comp. Temperature Time: 0 Critical Comp. Temperature Time: 0 Temperature Sensor 1: 36 Celsius Temperature Sensor 2: 44 Celsius Error Information (NVMe Log 0x01, 16 of 64 entries) No Errors Logged ","permalink":"https://0x1feb.github.io/posts/2024/06/23/check-ssd-smart/","summary":"概要 SSD の SMART 情報を表示し、故障してないか調べる。 前提 Ubuntu 22.04 LTS smartctl 7.2 手順 インストール sudo apt install smartmontools ディスクの検索 smartctl --scan /dev/sdb -d sat # /dev/sdb [SAT], ATA device /dev/sdc -d scsi # /dev/sdc, SCSI device /dev/nvme0 -d nvme #","title":"SSD の SMART を調べる"},{"content":"概要 rsync を使って、特定ディレクトリのバックアップを日次で取得する。 前回分の差分のみ実ファイルを取得し、変更のないファイルはハードリンクとする。 前提 Ubuntu 22.04 LTS rsync 3.2.7 手順 スクリプトの作成 /opt/rsync_backup.sh を作成する。\n#!/bin/bash function main() { # backup(copy) from \u0026#39;src_dir\u0026#39; to \u0026#39;dest_dir(dest_base_dir/backup-yyyyMMdd-hhmmss)\u0026#39; local -r src_dir=\u0026#34;/data\u0026#34; local -r dest_base_dir=\u0026#34;/backup/data\u0026#34; local -r dir_prefix=\u0026#34;backup-\u0026#34; local -r dest_dir=\u0026#34;${dest_base_dir}/${dir_prefix}$(date +%Y%m%d-%H%M%S)\u0026#34; local -r latest_backup_dir=\u0026#34;${dest_base_dir}/$(ls ${dest_base_dir} | grep ${dir_prefix} | tail -n 1)\u0026#34; rsync -avh --link-dest=\u0026#34;${latest_backup_dir}\u0026#34; \u0026#34;${src_dir}/\u0026#34; \u0026#34;${dest_dir}\u0026#34; } main このスクリプトを実行すると、/data 配下にあるファイルやディレクトリを全て /data/backup/backup-yyyyMMdd-hhmmss 配下にコピーする。\n前回実行時の backup-yyyyMMdd-hhmmss は、--link-dest オプションにより、差分比較対象となる。差分があったファイルのみ実体をコピーし、差分なしのファイルはハードコピーとなる。そのため、差分が少なければ高速でバックアップできる。\nまた、変更がないファイルもハードコピーされるため、見かけ上は各世代をフルバックアップとして扱うことができる。\n実ファイルへの全てのハードコピーが削除されたとき、実ファイルが削除される。そのため、バックアップを繰り返して古いディレクトリを削除しても、他のバックアップディレクトリのどこかにハードコピーが残っていれば、バックアップしたファイルの実体は削除されない。\nn オプションを付けて実行する (rsync -n ...) と、コピーせずにコピー対象の一覧を確認することができる。\nサービスの登録 作成したスクリプトの権限を変更する。\nsudo chmod 755 /opt/rsync_backup.sh sudo chown root:root /opt/rsync_backup.sh 任意のエディタで /etc/systemd/system/rsync-backup.service を作成する。\nsudo vi /etc/systemd/system/rsync-backup.service [Unit] Description = rsync backup [Service] Type=simple ExecStart=/opt/rsync_backup.sh サービスをリロードする。\nsudo systemctl daemon-reload 問題なくサービスが実行されることを確認する。\nsudo systemctl start rsync-backup 任意のタイミングでバックアップを取得したいときは、上記コマンドを実行すればよい。\nスケジュールの登録 任意のエディタで /etc/systemd/system/rsync-backup.timer を作成する。\nsudo vi /etc/systemd/system/rsync-backup.timer 毎日03:00に実行する設定とする。\n[Unit] Description=Run backup service daily at 03:00 [Timer] OnCalendar=*-*-* 03:00:00 Persistent=true [Install] WantedBy=timers.target タイマーを有効化し、起動する。\nsudo systemctl daemon-reload sudo systemctl enable rsync-backup.timer sudo systemctl start rsync-backup.timer タイマーの設定を一覧表示する。\nsudo systemctl list-timers 次回の実行予定が設定どおりスケジュールされていることを確認する。\nNEXT LEFT LAST PASSED UNIT ACTIVATES ... Thu 2024-05-02 03:00:00 JST 2h 37min left n/a n/a rsync-backup.timer rsync-backup.service ... 13 timers listed. Pass --all to see loaded but inactive timers, too. ","permalink":"https://0x1feb.github.io/posts/2024/05/01/perform-daily-incremental-backups-of-a-specific-directory-with-rsync/","summary":"概要 rsync を使って、特定ディレクトリのバックアップを日次で取得する。 前回分の差分のみ実ファイルを取得し、変更のないファイルはハードリンクとする。","title":"rsync で特定ディレクトリを日次で差分バックアップする"},{"content":"概要 Ubuntu 22.04 LTS に NGINX をインストールする。 前提 Ubuntu 22.04 LTS NGINX 1.26.0 手順 Ubuntu Repository 経由 この手順では、Ubuntu Repository の最新版である 1.18.0 がインストールされる。\nNGINX をインストールする。\nsudo apt install nginx NGINX のバージョンを確認する。\n$ sudo nginx -v nginx version: nginx/1.18.0 (Ubuntu) Official NGINX Repository 経由 この手順では、Official NGINX Repository の最新版である 1.26.0 がインストールされる。\n前提となるアプリをインストールする。\nsudo apt install curl gnupg2 ca-certificates lsb-release ubuntu-keyring 公式の NGINX 署名鍵をインポートする。\ncurl https://nginx.org/keys/nginx_signing.key | gpg --dearmor \\ | sudo tee /usr/share/keyrings/nginx-archive-keyring.gpg \u0026gt;/dev/null ダウンロードした鍵が適切か確認する。\ngpg --dry-run --quiet --no-keyring --import --import-options import-show /usr/share/keyrings/nginx-archive-keyring.gpg 573BFD6B3D8FBC641079A6ABABF5BD827BD9BF62 であれば問題ない。\npub rsa2048 2011-08-19 [SC] [expires: 2024-06-14] 573BFD6B3D8FBC641079A6ABABF5BD827BD9BF62 uid nginx signing key \u0026lt;signing-key@nginx.com\u0026gt; apt レポジトリに安定板の NGINX を追加する。\necho \u0026#34;deb [signed-by=/usr/share/keyrings/nginx-archive-keyring.gpg] \\ http://nginx.org/packages/ubuntu `lsb_release -cs` nginx\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/nginx.list 追加したパッケージを優先するよう設定する。\necho -e \u0026#34;Package: *\\nPin: origin nginx.org\\nPin: release o=nginx\\nPin-Priority: 900\\n\u0026#34; \\ | sudo tee /etc/apt/preferences.d/99nginx NGINX をインストールする。\nsudo apt update sudo apt install nginx NGINX のバージョンを確認する。\n$ sudo nginx -v nginx version: nginx/1.26.0 動作確認 NGINX を起動する。\nsudo systemctl start nginx ローカルホストに接続する。\n$ curl -I 127.0.0.1 HTTP/1.1 200 OK Server: nginx/1.26.0 Date: Wed, 24 Apr 2024 14:34:24 GMT Content-Type: text/html Content-Length: 615 Last-Modified: Tue, 23 Apr 2024 14:04:32 GMT Connection: keep-alive ETag: \u0026#34;6627bff0-267\u0026#34; Accept-Ranges: bytes ブラウザで http://{hostname} を開くと、「Welcome to nginx!」ページが表示される。\nOS の起動時に NGINX サーバが動くようにする。\nsudo systemctl enable nginx 参考 Installing NGINX Open Source ｜ NGINX Documentation ","permalink":"https://0x1feb.github.io/posts/2024/04/24/installing-nginx-on-ubuntu-22.04-lts/","summary":"概要 Ubuntu 22.04 LTS に NGINX をインストールする。 前提 Ubuntu 22.04 LTS NGINX 1.26.0 手順 Ubuntu Repository 経由 この手順では、Ubuntu Repository の最新版である 1.18.0 がインストールされる。 NGINX をインストー","title":"Ubuntu 22.04 LTS に NGINX をインストールする"},{"content":"概要 Ubuntu Server に SoftEther VPN Server をインストールしている。 同じサーバ上で Samba によるファイル共有サービス等を動かしている。 VPN 接続すると、Samba の共有ディレクトリや SSH 接続ができない。 Ubuntu Server にブリッジを追加し、VPN 接続したクライアントから Samba や SSH に接続できるようにする。 前提 Ubuntu 22.04 LTS SoftEther VPN Server (Ver 4.43, Build 9799, beta) ローカルブリッジ設定のブリッジ先は、物理 LAN の enp1s0 で動作している。 手順 ブリッジの追加 任意のエディタで、/etc/netplan/ 配下にある YAML ファイルを開く。\nsudo vi /etc/netplan/00-installer-config.yaml ネットワークインタフェース enp1s0 を無効化し、br0 を追加する。\n今回は、192.168.11.100/24 を固定 IP として設定する。\nnetwork: version: 2 ethernets: enp1s0: dhcp4: false dhcp6: false bridges: br0: interfaces: - enp1s0 dhcp4: false dhcp6: true addresses: - 192.168.11.100/24 routes: - to: default via: 192.168.11.1 nameservers: addresses: - 192.168.11.1 netplan で有効化する。\n$ sudo netplan apply WARNING:root:Cannot call Open vSwitch: ovsdb-server.service is not running. ovsdb-server.service がないため警告が出ているが、特に関係ないので無視する。\nSSH 接続して作業している場合は、netplan try コマンドを使う。設定ミスで接続できなくなった場合にロールバックしてくれる。\n$ sudo netplan try --timeout 30 WARNING:root:Cannot call Open vSwitch: ovsdb-server.service is not running. Do you want to keep these settings? Press ENTER before the timeout to accept the new configuration Changes will revert in 23 seconds 設定が変更されているか確認する。\n$ networkctl list IDX LINK TYPE OPERATIONAL SETUP 1 lo loopback carrier unmanaged 2 enp1s0 ether enslaved configured 3 br0 bridge routable configured 3 links listed. $ ip addr 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: enp1s0: \u0026lt;BROADCAST,MULTICAST,PROMISC,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel master br0 state UP group default qlen 1000 link/ether xx:xx:xx:xx:xx:xx brd ff:ff:ff:ff:ff:ff 3: br0: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc noqueue state UP group default qlen 1000 link/ether yy:yy:yy:yy:yy:yy brd ff:ff:ff:ff:ff:ff inet 192.168.11.100/24 brd 192.168.11.255 scope global br0 valid_lft forever preferred_lft forever inet6 aaaa:aaaa:aaaa:aaaa:aaaa:aaaa:aaaa:aaaa/64 scope global dynamic mngtmpaddr noprefixroute valid_lft 2591997sec preferred_lft 604797sec inet6 bbbb::bbbb:bbbb:bbbb:bbbb/64 scope link valid_lft forever preferred_lft forever 念のため、サーバを再起動し、サーバと同じネットワークから以下の接続ができるか確認する。\nSSH 接続 VPN 接続 Samba 接続 Samba に接続できなくなっていたので、次の手順で設定変更する。\nSamba の設定変更 SSH 接続できるが、Samba の共有ディレクトリには接続できなくなった。\nブリッジ経由での接続が許可されていないため、設定に追加する。\n任意のエディタで設定ファイルを開く。\nsudo vi /etc/samba/smb.conf interfaces に br0 を追加する。\n[global] ... # The specific set of interfaces / networks to bind to # This can be either the interface name or an IP address/netmask; # interface names are normally preferred interfaces = 127.0.0.0/8 enp1s0 br0 設定ファイルに問題がないか確認する。\n$ sudo testparm Load smb config files from /etc/samba/smb.conf Loaded services file OK. Weak crypto is allowed Server role: ROLE_STANDALONE Press enter to see a dump of your service definitions 問題なければサービスを再起動する。\nsudo systemctl restart smbd \u0026amp;\u0026amp; sudo systemctl restart nmbd これで外部からブリッジ経由で Samba の共有ディレクトリに接続できるようになる。\nTAP デバイスの追加 SoftEther VPN Server のローカルブリッジ設定にて、TAP デバイスを追加する。\nSoftEther VPN サーバ管理マネージャを起動し、「ローカルブリッジ設定」を開く。\n以下を選択し、「ローカルブリッジを追加」をクリックする。\n仮想 HUB: VPN (作成済みの名称) 作成する種類: 新しい tap デバイスとのブリッジ接続 新しい tap デバイス名: vpn (任意の名称) TAP デバイスが追加されていることを確認する。\n$ networkctl list IDX LINK TYPE OPERATIONAL SETUP 1 lo loopback carrier unmanaged 2 enp1s0 ether enslaved configured 3 br0 bridge routable configured 4 tap_vpn ether routable unmanaged 4 links listed. $ ip addr 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: enp1s0: \u0026lt;BROADCAST,MULTICAST,PROMISC,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel master br0 state UP group default qlen 1000 link/ether xx:xx:xx:xx:xx:xx brd ff:ff:ff:ff:ff:ff 3: br0: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc noqueue state UP group default qlen 1000 link/ether yy:yy:yy:yy:yy:yy brd ff:ff:ff:ff:ff:ff inet 192.168.11.100/24 brd 192.168.11.255 scope global br0 valid_lft forever preferred_lft forever inet6 aaaa:aaaa:aaaa:aaaa:aaaa:aaaa:aaaa:aaaa/64 scope global dynamic mngtmpaddr noprefixroute valid_lft 2591997sec preferred_lft 604797sec inet6 bbbb::bbbb:bbbb:bbbb:bbbb/64 scope link valid_lft forever preferred_lft forever 4: tap_vpn: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel state UNKNOWN group default qlen 1000 link/ether zz:zz:zz:zz:zz:zz brd ff:ff:ff:ff:ff:ff inet6 cccc:cccc:cccc:cccc:cccc:cccc:cccc:cccc/64 scope global temporary dynamic valid_lft 604781sec preferred_lft 86075sec inet6 dddd:dddd:dddd:dddd:dddd:dddd:dddd:dddd/64 scope global dynamic mngtmpaddr valid_lft 2591981sec preferred_lft 604781sec inet6 eeee::eeee:eeee:eeee:eeee/64 scope link valid_lft forever preferred_lft forever SoftEther VPN サーバ管理マネージャを起動し、「ローカルブリッジ設定」を開く。\nブリッジ先に enp1s0 を指定した設定を削除し、tap_vpn の設定のみが動作した状態にする。\nTAP デバイスをブリッジに追加 tap_vpn をプロミスキャスモードに設定する。\nsudo ip link set dev tap_vpn promisc on tap_vpn を br0 のインタフェースに追加する。\nsudo ip link set dev tap_vpn master br0 別ネットワークのクライアントから VPN 接続し、Samba の共有ディレクトリやサーバへの SSH 接続ができることを確認する。\n問題なければ、VPN Server のサービス起動時に tap_vpn を br0 のインタフェースに追加する設定を入れる。\nやり方は色々あると思うので、お好みで。\n$ sudo cat /etc/systemd/system/vpnserver.service [Unit] Description = vpnserver daemon [Service] ExecStart = /opt/vpnserver.sh start ExecStop = /opt/vpnserver.sh stop ExecReload = /opt/vpnserver.sh restart Restart = always Type = forking [Install] WantedBy = multi-user.target /opt/vpnserver.sh の中身は以下とした。\nVPN Server が tap_vpn を作成したら、 br0 に追加している。\n終了時は、念のため br0 から削除したうえで VPN Server を停止する。\n#!/bin/bash # chkconfig: 2345 99 01 # description: SoftEther VPN Server DAEMON=/usr/local/vpnserver/vpnserver LOCK=/var/lock/subsys/vpnserver start_vpnserver() { $DAEMON start touch $LOCK for i in {1..10}; do if ip link show dev tap_vpn \u0026gt;/dev/null 2\u0026gt;\u0026amp;1; then ip link set dev tap_vpn promisc on ip link set dev tap_vpn master br0 break else sleep 1 fi done } stop_vpnserver() { if ip link show dev tap_vpn \u0026gt;/dev/null 2\u0026gt;\u0026amp;1; then ip link set tap_vpn promisc off ip link set dev tap_vpn nomaster fi $DAEMON stop rm $LOCK } test -x $DAEMON || exit 0 case \u0026#34;$1\u0026#34; in start) start_vpnserver ;; stop) stop_vpnserver ;; restart) stop_vpnserver sleep 3 start_vpnserver ;; *) echo \u0026#34;Usage: $0 {start|stop|restart}\u0026#34; exit 1 ;; esac exit 0 最後に、サーバを再起動し、VPN 接続経由で各種サービスが使えることを確認する。\n参考 ネットワークブリッジ - ArchWiki ","permalink":"https://0x1feb.github.io/posts/2024/04/14/connecting-to-samba-and-ssh-on-the-server-running-softether-vpn-server-via-vpn/","summary":"概要 Ubuntu Server に SoftEther VPN Server をインストールしている。 同じサーバ上で Samba によるファイル共有サービス等を動かしている。 VPN 接続すると、Samba の共有ディレクト","title":"SoftEther VPN Server を動かしているサーバ上の Samba や SSH に VPN 経由で接続する"},{"content":"概要 Ubuntu に SoftEther VPN Server をインストールする。 前提 Ubuntu 22.04.4 LTS SoftEther VPN Server (Ver 4.43, Build 9799, beta) 手順 SoftEther VPN Server のダウンロード SoftEther ダウンロード センターより、以下を選択する。\nダウンロードするソフトウェア: SoftEther VPN (Freeware) コンポーネント: SoftEther VPN Server プラットフォーム: Linux CPU: Intel x64 / AMD64 (64bit) ダウンロード可能なファイルが表示されたら、最新の URL をコピーする。\n適当な作業用のディレクトリを作成し、以下コマンドを実行する。\n$ wget https://jp.softether-download.com/files/softether/v4.43-9799-beta-2023.08.31-tree/Linux/SoftEther_VPN_Server/64bit_-_Intel_x64_or_AMD64/softether-vpnserver-v4.43-9799-beta-2023.08.31-linux-x64-64bit.tar.gz --2024-03-21 23:01:57-- https://jp.softether-download.com/files/softether/v4.43-9799-beta-2023.08.31-tree/Linux/SoftEther_VPN_Server/64bit_-_Intel_x64_or_AMD64/softether-vpnserver-v4.43-9799-beta-2023.08.31-linux-x64-64bit.tar.gz Resolving jp.softether-download.com (jp.softether-download.com)... 130.158.75.49 Connecting to jp.softether-download.com (jp.softether-download.com)|130.158.75.49|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 8398576 (8.0M) [application/x-gzip] Saving to: ‘softether-vpnserver-v4.43-9799-beta-2023.08.31-linux-x64-64bit.tar.gz’ softether-vpnserver-v4.43-979 100%[=================================================\u0026gt;] 8.01M 9.25MB/s in 0.9s 2024-03-21 23:01:58 (9.25 MB/s) - ‘softether-vpnserver-v4.43-9799-beta-2023.08.31-linux-x64-64bit.tar.gz’ saved [8398576/8398576] ダウンロードしたパッケージファイルを展開する。\n$ tar xzvf softether-vpnserver-v4.43-9799-beta-2023.08.31-linux-x64-64bit.tar.gz vpnserver/ vpnserver/Makefile vpnserver/.install.sh vpnserver/ReadMeFirst_License.txt vpnserver/Authors.txt vpnserver/ReadMeFirst_Important_Notices_ja.txt vpnserver/ReadMeFirst_Important_Notices_en.txt vpnserver/ReadMeFirst_Important_Notices_cn.txt vpnserver/code/ vpnserver/code/vpnserver.a vpnserver/code/vpncmd.a vpnserver/lib/ vpnserver/lib/libcharset.a vpnserver/lib/libcrypto.a vpnserver/lib/libedit.a vpnserver/lib/libiconv.a vpnserver/lib/libintelaes.a vpnserver/lib/libncurses.a vpnserver/lib/libssl.a vpnserver/lib/libz.a vpnserver/lib/License.txt vpnserver/hamcore.se2 必要なソフトウェアやライブラリのインストール 実行可能ファイルを生成するために必要なソフトウェアやライブラリをインストールする。\nsudo apt install build-essential -y 実行可能ファイルの生成 展開したディレクトリを開き、make を実行する。\n$ cd softether $ make ... The preparation of SoftEther VPN Server is completed ! ... make[1]: Leaving directory \u0026#39;/home/hiro/tmp/vpnserver\u0026#39; The preparation of SoftEther VPN Server is completed ! が表示されたらたぶん問題ない。\nVPN Server の配置 /usr/local/vpnserver に移動する。\ncd .. sudo mv vpnserver /usr/local cd /usr/local/ root 権限のみで読み書きできるように設定する。\nsudo chmod -R 600 vpnserver sudo chmod 700 vpnserver/vpncmd sudo chmod 700 vpnserver/vpnserver sudo chown -R root:root vpnserver 動作チェック make 実行時にもチェックはされているが、再度チェックしたい場合は vpncmd より check を実行する。\n$ sudo vpnserver/vpncmd vpncmd command - SoftEther VPN Command Line Management Utility SoftEther VPN Command Line Management Utility (vpncmd command) Version 4.43 Build 9799 (English) Compiled 2023/08/31 10:50:49 by buildsan at crosswin with OpenSSL 3.0.9 Copyright (c) 2012-2023 SoftEther VPN Project. All Rights Reserved. By using vpncmd program, the following can be achieved. 1. Management of VPN Server or VPN Bridge 2. Management of VPN Client 3. Use of VPN Tools (certificate creation and Network Traffic Speed Test Tool) Select 1, 2 or 3: 3 VPN Tools has been launched. By inputting HELP, you can view a list of the commands that can be used. VPN Tools\u0026gt;check Check command - Check whether SoftEther VPN Operation is Possible --------------------------------------------------- SoftEther VPN Operation Environment Check Tool Copyright (c) SoftEther VPN Project. All Rights Reserved. If this operation environment check tool is run on a system and that system passes, it is most likely that SoftEther VPN software can operate on that system. This check may take a while. Please wait... Checking \u0026#39;Kernel System\u0026#39;... Pass Checking \u0026#39;Memory Operation System\u0026#39;... Pass Checking \u0026#39;ANSI / Unicode string processing system\u0026#39;... Pass Checking \u0026#39;File system\u0026#39;... Pass Checking \u0026#39;Thread processing system\u0026#39;... Pass Checking \u0026#39;Network system\u0026#39;... Pass All checks passed. It is most likely that SoftEther VPN Server / Bridge can operate normally on this system. The command completed successfully. VPN Tools\u0026gt;exit サービスの登録 任意のエディタで、サービス呼び出しスクリプトを作成する。\nsudo vi /opt/vpnserver.sh #!/bin/sh # chkconfig: 2345 99 01 # description: SoftEther VPN Server DAEMON=/usr/local/vpnserver/vpnserver LOCK=/var/lock/subsys/vpnserver test -x $DAEMON || exit 0 case \u0026#34;$1\u0026#34; in start) $DAEMON start touch $LOCK ;; stop) $DAEMON stop rm $LOCK ;; restart) $DAEMON stop sleep 3 $DAEMON start ;; *) echo \u0026#34;Usage: $0 {start|stop|restart}\u0026#34; exit 1 esac exit 0 スクリプトの権限を変更する。\nsudo chmod 755 /opt/vpnserver.sh sudo chown root:root /opt/vpnserver.sh 任意のエディタで /etc/systemd/system/vpnserver.service を作成する。\nsudo vi /etc/systemd/system/vpnserver.service [Unit] Description = vpnserver daemon [Service] ExecStart = /opt/vpnserver.sh start ExecStop = /opt/vpnserver.sh stop ExecReload = /opt/vpnserver.sh restart Restart = always Type = forking [Install] WantedBy = multi-user.target サービスをリロードする。\nsudo systemctl daemon-reload vpnserver サービスを有効化する。\n$ sudo systemctl enable vpnserver.service Created symlink /etc/systemd/system/multi-user.target.wants/vpnserver.service → /etc/systemd/system/vpnserver.service. サービスの開始・停止 # 開始 sudo systemctl start vpnserver # 終了 sudo systemctl stop vpnserver # 再起動 sudo systemctl restart vpnserver 参考 7.3 Linux へのインストールと初期設定 - SoftEther VPN プロジェクト ","permalink":"https://0x1feb.github.io/posts/2024/03/21/installing-softether-vpn-server-on-ubuntu-22.04.4-lts/","summary":"概要 Ubuntu に SoftEther VPN Server をインストールする。 前提 Ubuntu 22.04.4 LTS SoftEther VPN Server (Ver 4.43, Build 9799, beta) 手順 SoftEther VPN Server のダウンロード SoftEther ダウンロード センターより、以下を選択する。 ダウンロード","title":"Ubuntu 22.04.4 LTS に SoftEther VPN Server をインストールする"},{"content":"概要 Ubuntu に Samba をインストールし、ファイルサーバを構築する。 前提 Ubuntu 22.04.4 LTS 手順 Samba のインストール 以下のコマンドを実行し、Samba をインストールする。\n$ sudo apt install samba ... $ samba --version Version 4.15.13-Ubuntu Samba ユーザの作成 Samba を管理するの専用ユーザを作成する。\nOS ユーザを作成する。\n$ sudo adduser --system --group --no-create-home samba Adding system user `samba\u0026#39; (UID 114) ... Adding new group `samba\u0026#39; (GID 121) ... Adding new user `samba\u0026#39; (UID 114) with group `samba\u0026#39; ... Not creating home directory `/home/samba\u0026#39;. 今回作成した samba ユーザは、全体の共有ディレクトリ public を管理するために使用する。\nSamba のユーザデータベースに samba ユーザを追加する。全体の共有ディレクトリとして使用するため、パスワードは空のままとする。\n$ sudo pdbedit -a samba new password: retype new password: Unix username: samba ... 共有ディレクトリの作成 /srv/samba/ ディレクトリを作成する。この配下にユーザ別の共有ディレクトリを作成していく。\nsudo mkdir /srv/samba 自分の環境だと、/data に 1TB の SSD を割り当てているため、シンボリックリンクを作成する。\nsudo ln -s /data/srv/samba /srv/samba 全体で共有するための public ディレクトリを作成する。\nsudo mkdir /srv/samba/public public ディレクトリの所有者を samba に変更する。\nsudo chown samba:samba /srv/samba/public/ public ディレクトリの権限を変更する。\nsudo chmod 775 /srv/samba/public Samba の設定 任意のエディタで /etc/samba/smb.conf を開く。\nsudo vi /etc/samba/smb.conf 以下の設定を追加する。\n[global] guest account = samba [public] writeable = yes path = /srv/samba/public browseable = no create mask = 0664 directory mask = 0775 force user = samba force group = samba guest ok = yes guest only = yes 差分は以下の通り。\n$ diff -u /etc/samba/smb.conf.bk /etc/samba/smb.conf --- /etc/samba/smb.conf.bk 2024-03-20 14:42:05.317855775 +0900 +++ /etc/samba/smb.conf 2024-03-20 15:10:41.737421102 +0900 @@ -22,6 +22,7 @@ #======================= Global Settings ======================= [global] + guest account = samba ## Browsing/Identification ### @@ -215,6 +216,16 @@ ; browseable = no ; create mask = 0600 ; directory mask = 0700 +[public] + writeable = yes + path = /srv/samba/public + browseable = no + create mask = 0664 + directory mask = 0775 + force user = samba + force group = samba + guest ok = yes + guest only = yes [printers] comment = All Printers testparm で設定を確認する。\n$ sudo testparm Load smb config files from /etc/samba/smb.conf Loaded services file OK. Weak crypto is allowed Server role: ROLE_STANDALONE Press enter to see a dump of your service definitions 問題なければサービスを再起動する。\nsudo systemctl restart smbd \u0026amp;\u0026amp; sudo systemctl restart nmbd Windows のエクスプローラで確認 Windows のエクスプローラで、\\\\{ip}\\public にアクセスする。\nファイルを読み書きできることを確認する。\n","permalink":"https://0x1feb.github.io/posts/2024/03/20/setting-up-a-file-server-using-samba-on-ubuntu-22.04.4/","summary":"概要 Ubuntu に Samba をインストールし、ファイルサーバを構築する。 前提 Ubuntu 22.04.4 LTS 手順 Samba のインストール 以下のコマンドを実行し、Samba をインストールする。 $","title":"Ubuntu 22.04.4 で Samba を使ってファイルサーバを構築する"},{"content":"概要 Ubuntu の時刻が日本時間になっていないため、日本時間を設定する。 Windows と Ubuntu をデュアルブートしているとき、時刻がずれないようにしたい。 今回は Ubuntu 側の設定変更で対応する。 前提 Ubuntu 22.04.4 LTS 手順 タイムゾーンの設定 現在のタイムゾーンを確認する。\n$ timedatectl Local time: Tue 2024-03-19 14:32:47 UTC Universal time: Tue 2024-03-19 14:32:47 UTC RTC time: Tue 2024-03-19 14:32:47 Time zone: Etc/UTC (UTC, +0000) System clock synchronized: yes NTP service: active RTC in local TZ: no Etc/UTC が設定されているため、 Asia/Tokyo に変更する。\nsudo timedatectl set-timezone Asia/Tokyo 設定値を確認する。\n$ timedatectl Local time: Tue 2024-03-19 23:45:09 JST Universal time: Tue 2024-03-19 14:45:09 UTC RTC time: Tue 2024-03-19 14:45:09 Time zone: Asia/Tokyo (JST, +0900) System clock synchronized: yes NTP service: active RTC in local TZ: no ハードウェアクロックの設定 Windows と Ubuntu をデュアルブートしている場合、ハードウェアクロックの解釈方法が違うことにより、時刻がずれてしまう。\nWindows ハードウェアクロック: ローカタイム Ubuntu (Linux) ハードウェアクロック: UTC システムクロックは、コンピュータの起動時にハードウェアクロックから読み込まれる。そのため、Windows と Ubuntu でハードウェアクロックの扱いが異なると、システムクロックがずれてしまう。\n今回は、Ubuntu 側のハードウェアクロックをローカルタイムに変更する。\nsudo timedatectl set-local-rtc 1 ローカルタイムになっていることを確認する。\n$ timedatectl Local time: Wed 2024-03-20 00:02:58 JST Universal time: Tue 2024-03-19 15:02:58 UTC RTC time: Wed 2024-03-20 00:02:58 Time zone: Asia/Tokyo (JST, +0900) System clock synchronized: yes NTP service: active RTC in local TZ: yes Warning: The system is configured to read the RTC time in the local time zone. This mode cannot be fully supported. It will create various problems with time zone changes and daylight saving time adjustments. The RTC time is never updated, it relies on external facilities to maintain it. If at all possible, use RTC in UTC by calling \u0026#39;timedatectl set-local-rtc 0\u0026#39;. ハードウェアクロックがローカルタイムとして設定されていると、タイムゾーンの変更やサマータイムの調整で問題が生じるとの警告が出ている。\nタイムゾーンの調査方法 tzselect コマンドを実行して、日本のタイムゾーンを調べる。\n$ tzselect Please identify a location so that time zone rules can be set correctly. Please select a continent, ocean, \u0026#34;coord\u0026#34;, or \u0026#34;TZ\u0026#34;. 1) Africa 2) Americas 3) Antarctica 4) Asia 5) Atlantic Ocean 6) Australia 7) Europe 8) Indian Ocean 9) Pacific Ocean 10) coord - I want to use geographical coordinates. 11) TZ - I want to specify the timezone using the Posix TZ format. #? 4 Please select a country whose clocks agree with yours. 1) Afghanistan 15) French S. Terr. 29) Kyrgyzstan 43) Russia 2) Antarctica 16) Georgia 30) Laos 44) Saudi Arabia 3) Armenia 17) Hong Kong 31) Lebanon 45) Seychelles 4) Azerbaijan 18) India 32) Macau 46) Singapore 5) Bahrain 19) Indonesia 33) Malaysia 47) Sri Lanka 6) Bangladesh 20) Iran 34) Mongolia 48) Syria 7) Bhutan 21) Iraq 35) Myanmar (Burma) 49) Taiwan 8) Brunei 22) Israel 36) Nepal 50) Tajikistan 9) Cambodia 23) Japan 37) Oman 51) Thailand 10) China 24) Jordan 38) Pakistan 52) Turkmenistan 11) Christmas Island 25) Kazakhstan 39) Palestine 53) United Arab Emirates 12) Cocos (Keeling) Islands 26) Korea (North) 40) Philippines 54) Uzbekistan 13) Cyprus 27) Korea (South) 41) Qatar 55) Vietnam 14) East Timor 28) Kuwait 42) Réunion 56) Yemen #? 23 The following information has been given: Japan Therefore TZ=\u0026#39;Asia/Tokyo\u0026#39; will be used. Selected time is now: Tue Mar 19 23:38:56 JST 2024. Universal Time is now: Tue Mar 19 14:38:56 UTC 2024. Is the above information OK? 1) Yes 2) No #? 1 You can make this change permanent for yourself by appending the line TZ=\u0026#39;Asia/Tokyo\u0026#39;; export TZ to the file \u0026#39;.profile\u0026#39; in your home directory; then log out and log in again. Here is that TZ value again, this time on standard output so that you can use the /usr/bin/tzselect command in shell scripts: Asia/Tokyo Asia/Tokyo が日本のタイムゾーンである。\nちなみに、以下コマンドで全てを列挙することもできる。\n$ timedatectl list-timezones Africa/Abidjan Africa/Accra Africa/Addis_Ababa Africa/Algiers Africa/Asmara Africa/Asmera Africa/Bamako Africa/Bangui Africa/Banjul Africa/Bissau Africa/Blantyre Africa/Brazzaville Africa/Bujumbura Africa/Cairo Africa/Casablanca Africa/Ceuta Africa/Conakry Africa/Dakar Africa/Dar_es_Salaam Africa/Djibouti Africa/Douala Africa/El_Aaiun Africa/Freetown Africa/Gaborone Africa/Harare Africa/Johannesburg Africa/Juba Africa/Kampala Africa/Khartoum lines 1-29 ","permalink":"https://0x1feb.github.io/posts/2024/03/19/changing-the-time-zone-in-ubuntu/","summary":"概要 Ubuntu の時刻が日本時間になっていないため、日本時間を設定する。 Windows と Ubuntu をデュアルブートしているとき、時刻がずれないようにしたい。 今回は Ubuntu 側の設","title":"Ubuntu のタイムゾーンを変更する"},{"content":"概要 以下をデュアルブートしている。 Ubuntu 22.04.4 LTS Windows 11 Pro メインは Ubuntu であり、Ubuntu → Windows の起動順を設定している。 基本的には Wake on LAN で起動し、SSH で Ubuntu に接続する使い方をしている。 Windows を使いたいときだけ、Ubuntu 内で設定変更し、再起動したら Windows が起動するようにしたい。 今回は Ubuntu 側での変更手順のみ記載する。 前提 $ lsb_release -d Description: Ubuntu 22.04.4 LTS 手順 ブートエントリの確認 efibootmgr コマンドで、現在の設定を確認する。\n$ efibootmgr BootCurrent: 0002 Timeout: 1 seconds BootOrder: 0002,0000,0003,0001 Boot0000* Windows Boot Manager Boot0001* UEFI: Built-in EFI Shell Boot0002* ubuntu Boot0003* UEFI: PXE IPv4 Realtek PCIe GBE Family Controller BootCurrent: 現在のブートエントリ Timeout: ブートメニューを選択する待機時間 BootOrder: ブートする順序 BootXXXX: 各ブートエントリ この場合、0002(Ubuntu) → 0000(Windows) → \u0026hellip; の順に設定されていることがわかる。\n次回起動時のみ特定のブートエントリで起動 Windows を起動したいときは、0000 を指定する。\n$ sudo efibootmgr -n 0000 BootNext: 0000 BootCurrent: 0002 Timeout: 1 seconds BootOrder: 0002,0000,0003,0001 Boot0000* Windows Boot Manager Boot0001* UEFI: Built-in EFI Shell Boot0002* ubuntu Boot0003* UEFI: PXE IPv4 Realtek PCIe GBE Family Controller この状態で再起動すると、自動的に Windows が起動する。\nなお、この設定は1度きりであるため、Windows を再起動すると、 0002 の Ubuntu が自動起動する。\n永続的にブート順序を変更 常に Windows を優先的に起動したい場合、ブートの順序を変更する。\n$ sudo efibootmgr -o 0000,0002,0003,0001 BootCurrent: 0002 Timeout: 1 seconds BootOrder: 0000,0002,0003,0001 Boot0000* Windows Boot Manager Boot0001* UEFI: Built-in EFI Shell Boot0002* ubuntu Boot0003* UEFI: PXE IPv4 Realtek PCIe GBE Family Controller この状態で再起動すると、0000 の Windows が常に最優先で起動する。\n順序自体を変更するコマンドであるため、再起動しても Windows が優先的に起動する。\n","permalink":"https://0x1feb.github.io/posts/2024/03/18/changing-the-boot-order-in-windows-and-ubuntu-dual-boot-configuration/","summary":"概要 以下をデュアルブートしている。 Ubuntu 22.04.4 LTS Windows 11 Pro メインは Ubuntu であり、Ubuntu → Windows の起動順を設定している。 基本的には Wake on LAN で起動し、SSH で Ubuntu","title":"Windows と Ubuntu のデュアルブート中に起動順序を変更する"},{"content":"概要 新たに SSD を追加したため、フォーマットする。 前提 $ lsb_release -d Description: Ubuntu 22.04.4 LTS 手順 パーティション作成 パーティションを確認する。\n$ sudo parted -l Error: /dev/sda: unrecognised disk label Model: ATA SPCC Solid State (scsi) Disk /dev/sda: 1024GB Sector size (logical/physical): 512B/512B Partition Table: unknown Disk Flags: ... パーティション (/dev/sda) を選択する。\n$ sudo parted /dev/sda GNU Parted 3.4 Using /dev/sda Welcome to GNU Parted! Type \u0026#39;help\u0026#39; to view a list of commands. (parted) パーティションテーブルを作成する。今回は GPT を指定している。\n(parted) mklabel gpt ファイルシステム ext4 のパーティションを1つ作成する。\nmkpart primary ext4 0% 100% 作成したパーティションを確認する。\n(parted) print Model: ATA SPCC Solid State (scsi) Disk /dev/sda: 1024GB Sector size (logical/physical): 512B/512B Partition Table: gpt Disk Flags: Number Start End Size File system Name Flags 1 1049kB 1024GB 1024GB ext4 primary 終了する。\n(parted) q Information: You may need to update /etc/fstab. フォーマット '新增磁碟區' は中国語で「新しいディスク領域」という意味らしい。\n$ sudo mkfs.ext4 /dev/sda1 mke2fs 1.46.5 (30-Dec-2021) /dev/sda1 contains a ntfs file system labelled \u0026#39;新增磁碟區\u0026#39; Proceed anyway? (y,N) y Discarding device blocks: done Creating filesystem with 250050816 4k blocks and 62513152 inodes Filesystem UUID: 138f65e9-8a01-44fe-9ea5-fb02fbefc787 Superblock backups stored on blocks: 32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208, 4096000, 7962624, 11239424, 20480000, 23887872, 71663616, 78675968, 102400000, 214990848 Allocating group tables: done Writing inode tables: done Creating journal (262144 blocks): done Writing superblocks and filesystem accounting information: done マウント /data ディレクトリを作成する。\nsudo mkdir /data /dev/sda1 を /data にマウントする。\nsudo mount -t ext4 /dev/sda1 /data 起動時に自動マウント sda1 の UUID を調べる。\n$ sudo blkid /dev/sda1 /dev/sda1: UUID=\u0026#34;138f65e9-8a01-44fe-9ea5-fb02fbefc787\u0026#34; BLOCK_SIZE=\u0026#34;4096\u0026#34; TYPE=\u0026#34;ext4\u0026#34; PARTLABEL=\u0026#34;primary\u0026#34; PARTUUID=\u0026#34;95f4e458-5376-4d3f-b983-2a9b89873cc9\u0026#34; 任意のエディタで /etc/fstab を開く。\nsudo vi /etc/fstab 以下の情報を追記する。 \u0026lt;file system\u0026gt;: マウントするデバイスのパス or UUID \u0026lt;mount point\u0026gt;: マウントされるディレクトリのパス \u0026lt;type\u0026gt;: ファイルシステムの種類 \u0026lt;options\u0026gt;: マウントオプション \u0026lt;dump\u0026gt;: dump によるバックアップ対象に含めるか \u0026lt;pass\u0026gt;: fsck のチェック順序 ... UUID=138f65e9-8a01-44fe-9ea5-fb02fbefc787 /data ext4 defaults 0 1 再度マウントする。\nsudo mount -a ","permalink":"https://0x1feb.github.io/posts/2024/03/17/formatting-hdd/ssd-on-ubuntu-22.04.4-lts/","summary":"概要 新たに SSD を追加したため、フォーマットする。 前提 $ lsb_release -d Description: Ubuntu 22.04.4 LTS 手順 パーティション作成 パーティションを確認する。 $ sudo parted -l Error: /dev/sda: unrecognised disk label Model: ATA SPCC Solid State","title":"Ubuntu 22.04.4 LTS で HDD/SSD をフォーマットする"},{"content":"概要 Ubuntu 22.04.4 LTS にて Wake on LAN を設定する。 PC の電源を落としていても、WOL パケットを送信することで、電源を入れることができるようになる。 前提 $ lsb_release -d Description: Ubuntu 22.04.4 LTS 手順 ネットワークインタフェースの確認 ネットワークインタフェース名を調べる。\n$ ip addr show 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 ... 2: enp1s0: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 ... 今回は enp1s0 を例に説明する。\nWake on LAN を有効化したいネットワークインタフェースの設定を調べる。\n$ sudo ethtool enp1s0 | grep -i wake Supports Wake-on: pumbg Wake-on: d Wake-on: d は無効化された状態である。有効化している場合、Wake-on: g となる。\nWake on LAN の有効化 Wake on LAN を有効化する。\nsudo ethtool -s enp1s0 wol g Wake-on: g に代わっていることを確認する。\n$ sudo ethtool enp1s0 | grep -i wake Supports Wake-on: pumbg Wake-on: g しかし、このままだと再起動すると Wake-on: d に戻ってしまう。\nWake on LAN 設定の永続化 起動時に Wake on LAN 設定を有効化する systemd のサービスを作成する。\n任意のエディタでサービスファイルを作成する。\nsudo vi /etc/systemd/system/wol.service [Unit] Description=Enable Wake on LAN for enp1s0 After=network-online.target [Service] Type=oneshot ExecStart=/sbin/ethtool -s enp1s0 wol g [Install] WantedBy=multi-user.target サービスをリロードする。\nsudo systemctl daemon-reload wol.service サービスを有効化する。\n$ sudo systemctl enable wol.service Created symlink /etc/systemd/system/multi-user.target.wants/wol.service → /etc/systemd/system/wol.service. サービスを開始する。\nsudo systemctl start wol.service Wake on LAN の確認 WOL パケットを送信するため、MAC アドレスをメモする。\nenp1s0 の場合、以下の xx:xx:xx:xx:xx:xx 部分が MAC アドレスとなる。\n$ ip addr show 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 ... 2: enp1s0: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether xx:xx:xx:xx:xx:xx brd ff:ff:ff:ff:ff:ff PC をシャットダウンし、WOL パケットを送信する。\nPC が立ち上がったら、念のため Wake-on: g になっていることを確認する。\n$ sudo ethtool enp1s0 | grep -i wake Supports Wake-on: pumbg Wake-on: g ","permalink":"https://0x1feb.github.io/posts/2024/03/15/setting-up-wake-on-lan-on-ubuntu-22.04.4-lts/","summary":"概要 Ubuntu 22.04.4 LTS にて Wake on LAN を設定する。 PC の電源を落としていても、WOL パケットを送信することで、電源を入れることができるようになる。 前提 $ lsb_release -d Description: Ubuntu","title":"Ubuntu 22.04.4 LTS にて Wake on LAN を設定する"},{"content":"概要 bash のシェルスクリプトでログ出力する方法を色々と調べたので整理した。 前提 $ bash --version GNU bash, version 5.1.16(1)-release (x86_64-pc-linux-gnu) Copyright (C) 2020 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later \u0026lt;http://gnu.org/licenses/gpl.html\u0026gt; This is free software; you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. ログ出力方法 リダイレクトする #!/bin/bash # 標準出力をログにリダイレクトする echo \u0026#34;standard output\u0026#34; 1\u0026gt;output.log # 省略した場合も同じ echo \u0026#34;standard output (implicit)\u0026#34; \u0026gt;output.log # 標準エラー出力をログにリダイレクトする ls --unrecognized-option 2\u0026gt;output.log # 追記する echo \u0026gt;\u0026gt; output.log # 標準エラー出力を標準出力にリダイレクトする ls --unrecognized-option \u0026gt;output.log 2\u0026gt;\u0026amp;1 # 標準出力と標準エラー出力をログにリダイレクトする ls --unrecognized-option \u0026amp;\u0026gt;output.log ちょっとしたスクリプトならこれで問題ないが、ある程度大きくなると、全てに付与するのが面倒である。\n{\u0026hellip;} で括って一括出力する #!/bin/bash { echo \u0026#34;hello, world!\u0026#34; ls --unrecognized-option } \u0026amp;\u0026gt;output.log {...} の中で実行されたコマンドの標準出力と標準エラー出力をログに出力する。\nある程度まとまった処理ごとにログを分けたい場合に使えそう。\nexec コマンドを使って一括設定する #!/bin/bash exec \u0026amp;\u0026gt;output.log echo \u0026#34;hello, world!\u0026#34; ls --unrecognized-option 標準出力と標準エラー出力をログファイルにリダイレクトする。\n実行すると、output.log は以下のような中身になる。\nhello, world! ls: unrecognized option \u0026#39;--unrecognized-option\u0026#39; Try \u0026#39;ls --help\u0026#39; for more information. いちいちリダイレクト処理を書かなくてよいので楽になる。\nコンソールにも出力する #!/bin/bash exec \u0026amp;\u0026gt; \u0026gt;(tee -a output.log) echo \u0026#34;hello, world!\u0026#34; ls --unrecognized-option \u0026gt;(command) はプロセス置換という。\n標準出力と標準エラー出力を tee コマンドに渡して、コンソールとログに出力している。\n各行の先頭に日付(yyyy-MM-dd hh:mm:ss)を付与する #!/bin/bash exec \u0026amp;\u0026gt; \u0026gt;(awk \u0026#39;{print strftime(\u0026#34;%Y-%m-%d %H:%M:%S \u0026#34;) $0; fflush();}\u0026#39;) echo \u0026#34;hello, world!\u0026#34; ls --unrecognized-option awk コマンドを使って、日付 strftime(\u0026quot;%Y-%m-%d %H:%M:%S \u0026quot;) を付与している。\n$0 で標準出力と標準エラー出力の全量が渡される。\nfflush() でバッファせずに出力する。\n実行すると、次のようなログがコンソールに出力される。\n$ bash main.sh 2024-03-13 23:08:39 hello, world! 2024-03-13 23:08:39 ls: unrecognized option \u0026#39;--unrecognized-option\u0026#39; 2024-03-13 23:08:39 Try \u0026#39;ls --help\u0026#39; for more information. コンソールとログの両方に出力したい場合は、awk コマンドの出力を tee コマンドに渡す。\n#!/bin/bash exec \u0026amp;\u0026gt; \u0026gt;(awk \u0026#39;{print strftime(\u0026#34;%Y-%m-%d %H:%M:%S \u0026#34;) $0; fflush();}\u0026#39; | tee -a \u0026#34;$LOG_FILE\u0026#34;) ","permalink":"https://0x1feb.github.io/posts/2024/03/13/outputting-timestamped-logs-in-a-bash-shell-script/","summary":"概要 bash のシェルスクリプトでログ出力する方法を色々と調べたので整理した。 前提 $ bash --version GNU bash, version 5.1.16(1)-release (x86_64-pc-linux-gnu) Copyright (C) 2020 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later \u0026lt;http://gnu.org/licenses/gpl.html\u0026gt; This is free software; you are free to change","title":"bash のシェルスクリプトの実行結果をログ出力する"},{"content":"概要 Wi-Fi 経由で Android 端末を PC へミラーリングする。 Android 端末の画面をキャプチャできる。 PC から Android 端末を操作できる。 前提 Android 端末: Pixel 6a (Android 14) PC: Windows 11 Software: scrcpy 2.3.1 手順 PC に scrcpy をインストールする PC にて、scrcpy (Release scrcpy v2.3.1 · Genymobile/scrcpy) をインストールする。 Windows は winget を使ったインストールもできる。\n\u0026gt; winget install scrcpy 見つかりました scrcpy [Genymobile.scrcpy] バージョン 2.3.1 このアプリケーションは所有者からライセンス供与されます。 Microsoft はサードパーティのパッケージに対して責任を負わず、ライセンスも付与しません。 ダウンロード中 https://github.com/Genymobile/scrcpy/releases/download/v2.3.1/scrcpy-win64-v2.3.1.zip ██████████████████████████████ 5.76 MB / 5.76 MB インストーラーハッシュが正常に検証されました アーカイブを展開しています... アーカイブが正常に展開されました パッケージのインストールを開始しています... パス環境変数が変更されました; 新しい値を使用するにはシェルを再起動してください。 コマンド ライン エイリアスが追加されました: \u0026#34;scrcpy\u0026#34; インストールが完了しました Android の Wi-Fi デバッグ機能を有効化する Settings \u0026gt; About phone \u0026gt; Build number より、ビルド番号を7回タップする。 Settings \u0026gt; System \u0026gt; Developer options をタップする。 Wireless debugging を有効化する。 ペアリングして接続する Android 端末にて、Settings \u0026gt; System \u0026gt; Developer options をタップする。\nPair device with pairing code をタップする。\n表示されている情報を次の手順で使用する。 PC にて、Android 端末に表示されている情報でペアリングする。\n\u0026gt; adb pair 192.168.11.1:12345 999999 Successfully paired to 192.168.11.1:12345 [guid=adb-HOGE-FUGA] ペアリングした端末に接続する。\nペアリング用に表示されたものではなく、Android 端末の Wireless debugging 画面に表示されている IP Address \u0026amp; Port なので注意する。\n\u0026gt; adb connect 192.168.11.1:67890 connected to 192.168.11.1:67890 \u0026gt; scrcpy scrcpy 2.3.1 \u0026lt;https://github.com/Genymobile/scrcpy\u0026gt; INFO: ADB device found: INFO: --\u0026gt; (tcpip) 192.168.11.6:67890 device Pixel_6a C:\\Users\\user\\AppData\\Local\\Microsoft\\WinGet\\Packages\\Geny... file pushed, 0 skipped. 19.1 MB/s (66007 bytes in 0.003s) [server] INFO: Device: [Google] google Pixel 6a (Android 14) INFO: Renderer: direct3d INFO: Texture: 1080x2400 参考 Genymobile/scrcpy： Display and control your Android device Configure on-device developer options ｜ Android Studio ｜ Android Developers ","permalink":"https://0x1feb.github.io/posts/2024/01/02/mirroring-android-to-pc-via-wi-fi/","summary":"概要 Wi-Fi 経由で Android 端末を PC へミラーリングする。 Android 端末の画面をキャプチャできる。 PC から Android 端末を操作できる。 前提 Android 端末: Pixel 6a (Android 14) PC: Windows 11 Software: scrcpy 2.3.1 手順 PC に","title":"Wi-Fi 経由で Android 端末を PC へミラーリングする"},{"content":"概要 ThinkPad E14 Gen 5 AMD にメモリと SSD を増設した。 自分で分解するため、自己責任で行うこと。 前提 本体: ThinkPad E14 Gen 5 AMD (21JRCTO1WWJP2) 合計メモリは、「8 GB DDR4-3200MHz (オンボード) 」を選択した。 1stストレージは、「256 GB SSD M.2 2242 PCIe-NVMe Gen4 TLC OPAL対応」を選択した。 2ndストレージは、「なし」を選択した。 メモリ: Crucial 16GB DDR4-3200 SODIMM (CT16G4SFRA32A) 購入時にカスタマイズできる合計メモリが24GBのため、16GB以上のメモリを増設できるかは不明である。 SSD: PCIe SSD 240S (TS500GMTE240S) 500GBのものを使用したが、1TBも同様に増設できると思われる。 工具: 三角オープナー (Wave Profesional) 背景 購入時のカスタマイズにて、メモリ16GBの追加と SSD M.2 2280 の追加が選択肢に存在しているため、自分で増設することができるのではないかと考えた。 増設手順 本体裏側の隙間に三角オープナーを差し込み、蓋全体のロックを外す。 押し込むとカチッという音がするため、そのまま三角オープナーを全体に回していくと全て外れる。 蓋を外す。 左から順に、SSD (1st ストレージ)、メモリ、SSD (2nd ストレージ) となっている。 メモリ部分の銀色の蓋を外し、メモリを差し込む。 赤枠の下部分に4つついているのがオンボードメモリである。 カチッという音がするまで差し込む。 SSD (2nd ストレージ) 部分のねじを外し、SSD を差し込む。 先にねじを外さないと入らないので注意する。 SSD を差し込んだら、ねじを入れて固定する。 蓋を閉める。 起動して、メモリ・SSD が認識されていることを確認する。 以上。 ","permalink":"https://0x1feb.github.io/posts/2024/01/01/adding-memory-and-ssd-to-thinkpad-e14-gen-5-amd/","summary":"概要 ThinkPad E14 Gen 5 AMD にメモリと SSD を増設した。 自分で分解するため、自己責任で行うこと。 前提 本体: ThinkPad E14 Gen 5 AMD (21JRCTO1WWJP2) 合計メモリは、「8 GB DDR4-3200MHz (オンボード) 」を","title":"ThinkPad E14 Gen 5 AMD にメモリと SSD を増設する"},{"content":"概要 Windows の PowerShell を新しいバージョンにアップグレードする。 前提 Windows 11 PowerShell のバージョン アップグレード前: 7.3.9 アップグレード後: 7.4.0 手順 最新バージョンを確認する。\n\u0026gt; winget search Microsoft.PowerShell 名前 ID バージョン ソース ------------------------------------------------------------------ PowerShell Microsoft.PowerShell 7.4.0.0 winget PowerShell Preview Microsoft.PowerShell.Preview 7.4.0.101 winget インストールコマンドを実行する。(アップグレードを試みるが、失敗する。)\n\u0026gt; winget install --id Microsoft.Powershell --source winget 既存のパッケージが既にインストールされています。インストールされているパッケージ...をアップグレードしようとしています 新しいバージョンが見つかりましたが、インストールテクノロジが現在インストールされているバージョンと異なります。パッケージをアンインストールして、新しいバージョンをインストールしてください。 既存の PowerShell をアンインストールする。\n\u0026gt; winget remove --id Microsoft.Powershell --source winget 見つかりました PowerShell [Microsoft.PowerShell] パッケージのアンインストールを開始しています... 正常にアンインストールされました 再度インストールする。\n\u0026gt; winget install --id Microsoft.Powershell --source winget 見つかりました PowerShell [Microsoft.PowerShell] バージョン 7.4.0.0 このアプリケーションは所有者からライセンス供与されます。 Microsoft はサードパーティのパッケージに対して責任を負わず、ライセンスも付与しません。 ダウンロード中 https://github.com/PowerShell/PowerShell/releases/download/v7.4.0/PowerShell-7.4.0-win-x64.msi ██████████████████████████████ 103 MB / 103 MB インストーラーハッシュが正常に検証されました パッケージのインストールを開始しています... インストールが完了しました 参考 Installing PowerShell on Windows - PowerShell ｜ Microsoft Learn ","permalink":"https://0x1feb.github.io/posts/2023/11/26/how-to-upgrade-powershell/","summary":"概要 Windows の PowerShell を新しいバージョンにアップグレードする。 前提 Windows 11 PowerShell のバージョン アップグレード前: 7.3.9 アップグレード後: 7.4.0 手順 最新バージョンを確認する","title":"Windows の PowerShell をアップグレードする"},{"content":"概要 深さ優先探索とは、グラフの探索等に用いられる探索アルゴリズムである。ある頂点をスタートとし、その点から探索可能な点を探索する。探索したそれぞれの点についても同様に探索可能な点を探索することを繰り返す。\n以下のような各頂点に番号が振られているグラフを例に考える。\ngraph TD 0((0))---1((1)) 0((0))---2((2)) 0((0))---3((3)) 1((1))---4((4)) 1((1))---5((5)) 3((3))---6((6)) 4((4))---7((7)) 4((4))---8((8)) 6((6))---9((9)) 入力は以下の形式で標準入力から与えられるものとする。\n$N ~ M ~ S ~ T \\\\ A_{1} ~ B_{1} \\\\ \\vdots \\\\ A_{m} ~ B_{m}$\n$N$: 頂点の数 $M$: 辺の数 $S$: 開始頂点 $T$: 終了頂点 $A_{i} ~ B_{i}$: $i$ 本目の辺は頂点 $A_{i}$ と $B_{i}$ を結んでいる 頂点 $S$ から頂点 $T$ までの経路を出力する。例えば、頂点8から頂点9までの経路は、以下の太線 (8 4 1 0 3 6 9) となる。\ngraph TD 0((0))===1((1)) 0((0))---2((2)) 0((0))===3((3)) 1((1))===4((4)) 1((1))---5((5)) 3((3))===6((6)) 4((4))---7((7)) 4((4))===8((8)) 6((6))===9((9)) ソースコード #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define rep(i, n) for (int i = 0; i \u0026lt; (n); ++i) #define rng(a) a.begin(), a.end() using vi = vector\u0026lt;int\u0026gt;; using vvi = vector\u0026lt;vi\u0026gt;; using vb = vector\u0026lt;bool\u0026gt;; int main() { int n, m, s, t; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; vvi g(n); rep(i, m) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; g[a].push_back(b); g[b].push_back(a); } vi prev(n, -1); vb visited(n, false); auto dfs = [\u0026amp;](auto dfs, int v) -\u0026gt; void { visited[v] = true; for (int v_next : g[v]) { if (visited[v_next]) continue; prev[v_next] = v; dfs(dfs, v_next); } }; dfs(dfs, s); vi path; int u = t; while (u != -1) { path.push_back(u); u = prev[u]; } reverse(rng(path)); int path_size = path.size(); rep(i, path_size) cout \u0026lt;\u0026lt; path[i] \u0026lt;\u0026lt; (i \u0026lt; path_size - 1 ? \u0026#34; \u0026#34; : \u0026#34;\\n\u0026#34;); return 0; } // 入力 10 9 8 9 0 1 0 2 0 3 1 4 1 5 3 6 4 7 4 8 6 9 // 出力 8 4 1 0 3 6 9 解説 まず、入力値を受け取る。\nint n, m, s, t; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; vvi g(n); rep(i, m) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; g[a].push_back(b); g[b].push_back(a); } 2次元配列 g を作成し、 辺の情報を格納する。g[x] は、点 x と繋がる点のリストとなる。\n次に、探索する。\nvi prev(n, -1); vb visited(n, false); auto dfs = [\u0026amp;](auto dfs, int v) -\u0026gt; void { visited[v] = true; for (int v_next : g[v]) { if (visited[v_next]) continue; prev[v_next] = v; dfs(dfs, v_next); } }; dfs(dfs, s); prev[x] には、点 x に到達したときに経由した1つ前の点を記録する。点 x から点 y を探索したとき、 prev[y] に x を格納する。prev は -1 で初期化し、最初に探索する点の前の点は -1 とする。\nvisited[x] には、点 x が探索済みかどうかを記録する。点 x を探索したとき、 visited[x] は true となる。\n探索は、以下の流れで実行する。\ndfs を探索の開始点 s で呼び出す。 全ての点を探索し終えるまで以下を繰り返す。 dfs の引数 v を探索済みとして visited に記録する。 v と辺で繋がる点 v_next を取り出す。 v_next が探索済みであれば、以降の処理はスキップする。 prev にどの点からどの点へと探索したか記録する。 dfs の引数に v_next を設定し、再帰的に呼び出す。 全ての点を探索し終えると dfs の再帰が終わる。 最後に、探索したパスを出力する。\nvi path; int u = t; while (u != -1) { path.push_back(u); u = prev[u]; } reverse(rng(path)); int path_size = path.size(); rep(i, path_size) cout \u0026lt;\u0026lt; path[i] \u0026lt;\u0026lt; (i \u0026lt; path_size - 1 ? \u0026#34; \u0026#34; : \u0026#34;\\n\u0026#34;); 目的となる点 t の1つ前の点は prev[t] で取得できる。この点を u とすると、 t の2つ前の点は prev[u] で取得できる。これを繰り返して s にたどり着くまでの点の情報を path に格納する。\npath には、 t から s までの経路上の点が格納されるため、逆順にしてから出力する。\n辺の数だけ探索するため、計算量は $O(M)$ となる。\n参考 深さ優先探索 - Wikipedia ","permalink":"https://0x1feb.github.io/posts/2023/08/27/depth-first-search/","summary":"概要 深さ優先探索とは、グラフの探索等に用いられる探索アルゴリズムである。ある頂点をスタートとし、その点から探索可能な点を探索する。探索したそ","title":"深さ優先探索 (Breadth-first search / DFS)"},{"content":"概要 幅優先探索とは、グラフの探索等に用いられる探索アルゴリズムである。ある頂点をスタートとし、その点に隣接する全ての点を探索する。探索したそれぞれの点についても同様に隣接する点を探索することを繰り返す。\n以下のような各頂点に番号が振られているグラフを例に考える。\ngraph TD 0((0))---1((1)) 0((0))---2((2)) 0((0))---3((3)) 1((1))---4((4)) 1((1))---5((5)) 3((3))---6((6)) 4((4))---7((7)) 4((4))---8((8)) 6((6))---9((9)) 入力は以下の形式で標準入力から与えられるものとする。\n$N ~ M ~ S ~ T \\\\ A_{1} ~ B_{1} \\\\ \\vdots \\\\ A_{m} ~ B_{m}$\n$N$: 頂点の数 $M$: 辺の数 $S$: 開始頂点 $T$: 終了頂点 $A_{i} ~ B_{i}$: $i$ 本目の辺は頂点 $A_{i}$ と $B_{i}$ を結んでいる 頂点 $S$ から頂点 $T$ までの経路を出力する。例えば、頂点8から頂点9までの経路は、以下の太線 (8 4 1 0 3 6 9) となる。\ngraph TD 0((0))===1((1)) 0((0))---2((2)) 0((0))===3((3)) 1((1))===4((4)) 1((1))---5((5)) 3((3))===6((6)) 4((4))---7((7)) 4((4))===8((8)) 6((6))===9((9)) ソースコード #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define rep(i, n) for (int i = 0; i \u0026lt; (n); ++i) #define rng(a) a.begin(), a.end() using vi = vector\u0026lt;int\u0026gt;; using vvi = vector\u0026lt;vi\u0026gt;; using vb = vector\u0026lt;bool\u0026gt;; int main() { int n, m, s, t; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; vvi g(n); rep(i, m) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; g[a].push_back(b); g[b].push_back(a); } vi prev(n, -1); vb visited(n, false); queue\u0026lt;int\u0026gt; que; que.push(s); while (!que.empty()) { int v = que.front(); que.pop(); visited[v] = true; for (int v_next : g[v]) { if (visited[v_next]) continue; prev[v_next] = v; que.push(v_next); } } vi path; int u = t; while (u != -1) { path.push_back(u); u = prev[u]; } reverse(rng(path)); int path_size = path.size(); rep(i, path_size) cout \u0026lt;\u0026lt; path[i] \u0026lt;\u0026lt; (i \u0026lt; path_size - 1 ? \u0026#34; \u0026#34; : \u0026#34;\\n\u0026#34;); return 0; } // 入力 10 9 8 9 0 1 0 2 0 3 1 4 1 5 3 6 4 7 4 8 6 9 // 出力 8 4 1 0 3 6 9 解説 まず、入力値を受け取る。\nint n, m, s, t; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; vvi g(n); rep(i, m) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; g[a].push_back(b); g[b].push_back(a); } 2次元配列 g を作成し、 辺の情報を格納する。g[x] は、点 x と繋がる点のリストとなる。\n次に、探索する。\nvi prev(n, -1); vb visited(n, false); queue\u0026lt;int\u0026gt; que; que.push(s); while (!que.empty()) { int v = que.front(); que.pop(); visited[v] = true; for (int v_next : g[v]) { if (visited[v_next]) continue; prev[v_next] = v; que.push(v_next); } } prev[x] には、点 x に到達したときに経由した1つ前の点を記録する。点 x から点 y を探索したとき、 prev[y] に x を格納する。prev は -1 で初期化し、最初に探索する点の前の点は -1 とする。\nvisited[x] には、点 x が探索済みかどうかを記録する。点 x を探索したとき、 visited[x] は true となる。\n探索は、以下の流れで実行する。\nque に探索の開始点 s を追加する。 que が空になるまで以下を繰り返す。 que から先頭の要素を取り出す。 取り出した点 v を探索済みとして visited に記録する。 v と辺で繋がる点 v_next を取り出す。 v_next が探索済みであれば、以降の処理はスキップする。 prev にどの点からどの点へと探索したか記録する。 que に v_next を追加する。 que が空になったら処理を終了する。 最後に、探索したパスを出力する。\nvi path; int u = t; while (u != -1) { path.push_back(u); u = prev[u]; } reverse(rng(path)); int path_size = path.size(); rep(i, path_size) cout \u0026lt;\u0026lt; path[i] \u0026lt;\u0026lt; (i \u0026lt; path_size - 1 ? \u0026#34; \u0026#34; : \u0026#34;\\n\u0026#34;); 目的となる点 t の1つ前の点は prev[t] で取得できる。この点を u とすると、 t の2つ前の点は prev[u] で取得できる。これを繰り返して s にたどり着くまでの点の情報を path に格納する。\npath には、 t から s までの経路上の点が格納されるため、逆順にしてから出力する。\n辺の数だけ探索するため、計算量は $O(M)$ となる。\n参考 幅優先探索 - Wikipedia ","permalink":"https://0x1feb.github.io/posts/2023/04/27/breadth-first-search/","summary":"概要 幅優先探索とは、グラフの探索等に用いられる探索アルゴリズムである。ある頂点をスタートとし、その点に隣接する全ての点を探索する。探索したそ","title":"幅優先探索 (Breadth-first search / BFS)"},{"content":"背景 GitHub の RSA SSH のホストキーが変更されたため、以下に沿ってキーを更新した。 We updated our RSA SSH host key | The GitHub Blog これは GitHub 側が作成した鍵に関する設定である。 ついでに自分が設定している SSH 接続の鍵ペアを確認したら、RSA を使用していた。 これは自分が GitHub に SSH 接続するときに作成した鍵に関する設定である。 セキュリティやパフォーマンスの面で Ed25519 の方が推奨されているらしいので、この機会に変更しておくことにした。 この変更は前述した GitHub の RSA SSH のホストキー変更とは関係なく、自分が GitHub に接続するときの鍵ペアを交換するというだけである。 概要 RSA で作成した鍵ペアによる GitHub への接続設定を削除する。 Ed25519 で作成した鍵ペアによる GitHub への接続設定を追加する。 前提 WSL 2 (Ubuntu 20.04.6 LTS) 手順 古い鍵ペアを削除する GitHub に登録した公開鍵を削除する。 SSH and GPG keys より、登録済みの SSH Key を削除する。 クライアントに保存している鍵を削除する。 特に指定してなければ、 ~/.ssh/ 配下に格納されている。 新しい鍵ペアを追加する ssh-keygen で新たな鍵ペアを生成する。\n$ ssh-keygen -t ed25519 -C \u0026#34;user@example.com\u0026#34; Generating public/private ed25519 key pair. Enter file in which to save the key (/home/user/.ssh/id_ed25519): id_ed25519_github Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in id_ed25519_github Your public key has been saved in id_ed25519_github.pub The key fingerprint is: SHA256:... user@example.com The key\u0026#39;s randomart image is: +--[ED25519 256]--+ ... +----[SHA256]-----+ 作成した公開鍵をコピーする。\nid_ed25519_github.pub の中身を全てコピーする。\n$ cat ~/.ssh/id_ed25519_github.pub ssh-ed25519 ... user@example.com GitHub に公開鍵を登録する。\nSSH and GPG keys より、「New SSH key」をクリックする。 以下項目を入力する。 Title: 任意 Key type: Authentication Key Key: コピーした公開鍵を貼り付ける。 SSH のコンフィグを設定する。\n~/.ssh/config ファイルを作成し、GitHub への SSH 接続で使う鍵を指定する。\nHost github.com User git Hostname github.com IdentityFile ~/.ssh/id_ed25519_github SSH 接続できることを確認する。\n$ ssh -T git@github.com Hi user! You\u0026#39;ve successfully authenticated, but GitHub does not provide shell access. 参考 Connecting to GitHub with SSH - GitHub Docs ","permalink":"https://0x1feb.github.io/posts/2023/03/27/setting-up-ssh-keys-for-github/","summary":"背景 GitHub の RSA SSH のホストキーが変更されたため、以下に沿ってキーを更新した。 We updated our RSA SSH host key | The GitHub Blog これは GitHub 側が作成した鍵に関する設定である。 ついで","title":"GitHub への SSH 接続を再設定する"},{"content":"背景 Firefox のアドオンであるツリー型タブ (Tree Style Tab) を使用しており、現在開いているタブはサイドバーに表示している。 ブラウザ上部に表示されている従来のタブは使用しないため、非表示にしたい。 前提 Windows 11 Firefox 111.0.1 (64 ビット) Tree Style Tab 3.9.14 概要 Firefox の外観を変更できるオプションを有効化する。 userChrome.css で外観をカスタマイズする。 上部のタブバーを非表示にする。 右上のウィンドウ操作ボタンを1段下のメニューの右端に移動する。 手順 userChrome.css を有効化する Firefox にて about:config を開く。 toolkit.legacyUserProfileCustomizations.stylesheets を検索する。 true に設定する。 userChrome.css を配置する Firefox にて about:support を開く。\nプロファイルフォルダー にある「フォルダーを開く」をクリックし、プロファイルフォルダーを開く。\n以降、このパスを {prifile} とする。 {prifile}\\chrome\\userChrome.css を作成する。\nフォルダやファイルが存在しなければ、新規に作成する。 userChrome.css に以下を入力し、上書き保存する。\nウィンドウ上部にあるタブ部分を非表示にする。 (Hide horizontal tabs at the top of the window)\n#main-window[tabsintitlebar=\u0026#34;true\u0026#34;]:not([extradragspace=\u0026#34;true\u0026#34;]) #TabsToolbar\u0026gt;.toolbar-items { opacity: 0; pointer-events: none; } #main-window:not([tabsintitlebar=\u0026#34;true\u0026#34;]) #TabsToolbar { visibility: collapse !important; } 右上のウィンドウ操作ボタンを1段下のメニューに移動する。 (Move Minimize/Restore/Close window buttons to the right of Hamburger menu (after hiding horizontal tabs))\n/* Adding empty space for buttons */ #nav-bar { margin-right: 140px; } /* 15px for dragging whole window by mouse*/ #titlebar { appearance: none !important; height: 15px; } /* Fix for main menu calling by Alt button */ #titlebar\u0026gt;#toolbar-menubar { margin-top: 10px; } /* Move minimize/restore/close buttons to empty space */ #TabsToolbar\u0026gt;.titlebar-buttonbox-container { display: block; position: absolute; top: 17px; right: 1px; } Firefox を再起動する。\n参考 Code snippets for custom style rules · piroor/treestyletab Wiki ","permalink":"https://0x1feb.github.io/posts/2023/03/22/hide-the-horizontal-tabs-at-the-top-of-the-firefox-window/","summary":"背景 Firefox のアドオンであるツリー型タブ (Tree Style Tab) を使用しており、現在開いているタブはサイドバーに表示している。 ブラウザ上部に表示されている従来のタブ","title":"Firefox の上部にあるタブを非表示にする"},{"content":"背景 Windows 10 から Windows 11 にアップグレードしたい。 Windows 11 のシステム要件である CPU の対象外だった。 使っていたのは AMD Ryzen 5 1600 である。 概要 Windows 11 でサポートされている CPU (Windows processor requirements Windows 11 supported AMD processors ｜ Microsoft Learn) に変更する。 変更前: AMD Ryzen 5 1600 変更後: AMD Ryzen 5 5500 手順 BIOS を更新する 新しい CPU に対応しているバージョンに更新する。 BitLocker の設定を確認する BitLocker を使用している場合は、解除するか、回復キーを保存しておく BitLocker を有効にしていると、起動時に回復キーを求められる。 CPU を交換する CPU クーラーを取り外す。 グリスが固まって CPU とくっついているため、 CPU ごと強引に外さないように注意する。 CPU を取り外す。 交換する CPU を設置する。 CPU クーラーを設置する。 ネジが届かないと思っていたら、バックプレートが外れていることに気付いてなかっただけだった。 起動して BIOS 設定画面を開き、CPU が認識されていることを確認する。 ","permalink":"https://0x1feb.github.io/posts/2023/03/19/replace-cpu/","summary":"背景 Windows 10 から Windows 11 にアップグレードしたい。 Windows 11 のシステム要件である CPU の対象外だった。 使っていたのは AMD Ryzen 5 1600 である。 概要 Windows 11 でサポートされている","title":"Ryzen 5 1600 を Ryzen 5 5500 に交換する"},{"content":"背景 Windows 10 から Windows 11 にアップグレードしたい。 Windows 11 のシステム要件であるセキュアブートを満たしていなかった。 Legacy BIOS で Windows 10 をインストールしていた。 Windows 10 が MBR ディスクにインストールされているため、 UEFI を有効にしても Legacy BIOS で起動してしまう。 マザーボードは PRIME B350-PLUS (BIOS Version 6061) を使用している。 概要 Windows 10 がインストールされているドライブが MBR ディスクになっているため、 GPT ディスクに変換する。 BIOS の設定を Legacy Boot から UEFI に変更する。 手順 MBR ディスクを GPT ディスクに変換する Windows 10 の回復オプションを開く。（開き方は以下など）\n「設定 \u0026gt; 更新とセキュリティ \u0026gt; 回復 \u0026gt; 今すぐ再起動」をクリックする。 「Shift」キーを押しながら「再起動」ボタンをクリックする。 「トラブルシューティング \u0026gt; 詳細オプション \u0026gt; コマンドプロンプト」をクリックする。\ndiskpart コマンドで対象ディスクの GPT に * がついていないことを確認する。\n\u0026gt; diskpart DISKPART\u0026gt; list disk ディスク 状態 サイズ 空き ダイナ GPT ### ミック ------------ ------------- ------- ------- --- --- ディスク 0 オンライン 489 GB 3072 KB ディスク 1 オンライン 3726 GB 1024 KB * ディスク 2 オンライン 3725 GB 0 B * DISKPART\u0026gt; exit mbr2gpt コマンドで対象の MBR ディスクを GPT ディスクに変換する。\n\u0026gt; mbr2gpt /validate /disk:0 /allowFULLOS MBR2GPT: Attempting to validate disk 0 MBR2GPT: Retrieving layout of disk MBR2GPT: Validating layout, disk sector size is: 512 bytes MBR2GPT: Validation completed successfully \u0026gt; mbr2gpt /convert /disk:0 /allowFullOS MBR2GPT will now attempt to convert disk 0. If conversion is successful the disk can only be booted in GPT mode. These changes cannot be undone! MBR2GPT: Attempting to convert disk 0 MBR2GPT: Retrieving layout of disk MBR2GPT: Validating layout, disk sector size is: 512 bytes MBR2GPT: Trying to shrink the OS partition MBR2GPT: Creating the EFI system partition MBR2GPT: Installing the new boot files MBR2GPT: Performing the layout conversion MBR2GPT: Migrating default boot entry MBR2GPT: Adding recovery boot entry MBR2GPT: Fixing drive letter mapping MBR2GPT: Conversion completed successfully Call WinReReapir to repair WinRE MBR2GPT: Failed to update ReAgent.xml, please try to manually disable and enable WinRE. MBR2GPT: Before the new system can boot properly you need to switch the firmware to boot to UEFI mode! Failed to update ReAgent.xml, please try to manually disable and enable WinRE. というエラーが出ていたが、無視しても特に問題なかった。 手動で WinRE の無効化と有効化を実行する場合は、以下コマンドを実行する。\n\u0026gt; reagentc /disable REAGENTC.EXE: Operation Successful. \u0026gt; reagentc /enable REAGENTC.EXE: Operation Successful. 再起動して BIOS のブートオプションを変更する。\nBIOS のブートオプションを設定する 再起動して「F2」キーをクリックし、 BIOS の設定画面を開く。\nUEFI モードで起動するように以下2箇所を設定して保存する。\n「Boot \u0026gt; Secure Boot \u0026gt; OS Type」: Windows UEFI mode 「Boot \u0026gt; CSM \u0026gt; Launch CSM」: Disabled Windows 10 が起動したら、 PowerShell で以下コマンドを実行し、 UEFI が有効になっていることを確認する。\n\u0026gt; Confirm-SecureBootUEFI True ","permalink":"https://0x1feb.github.io/posts/2023/03/18/change-legacy-bios-to-uefi/","summary":"背景 Windows 10 から Windows 11 にアップグレードしたい。 Windows 11 のシステム要件であるセキュアブートを満たしていなかった。 Legacy BIOS で Windows 10 をインストールしていた。 Windows 10 が","title":"Legacy BIOS を UEFI に変更する"},{"content":"バケットソートとは、整列したいデータがとりうる値の数だけバケツを用意し、全ての要素をバケツに入れた後、順番に取り出すソートアルゴリズムである。\nソースコード #include \u0026lt;bits/stdc++.h\u0026gt; #define rep(i, n) for (int i = 0; i \u0026lt; (n); ++i) using namespace std; using vi = vector\u0026lt;int\u0026gt;; const int X = 1000000; void print_list(vi a, int n) { rep(i, n) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; (i \u0026lt; n - 1 ? \u0026#34; \u0026#34; : \u0026#34;\\n\u0026#34;); } void bucket_sort(vi \u0026amp;a, int n) { // 要素の値の個数を記録する vi count(X); rep(i, n) count[a[i]]++; // 開始位置を記録する vi offset(X); rep(num, X) offset[num] = (num == 0 ? count[num] : offset[num - 1] + count[num]); // ソート vi b(n); rep(i, n) b[--offset[a[i]]] = a[i]; a = b; } int main() { int n; cin \u0026gt;\u0026gt; n; vi a(n); rep(i, n) cin \u0026gt;\u0026gt; a[i]; bucket_sort(a, n); print_list(a, n); return 0; } 実行した結果は以下のとおり。\n// 入力 8 2 1 3 7 1 6 2 5 // 出力 1 1 2 2 3 5 6 7 解説 配列 a の各要素の個数をカウントする。 $i$ 番目の要素の数は count[a[i]] 個となる。 開始位置を記録する。 offset[num] が num 以下の数の要素数となる。 ソート結果を配列 b に格納する。 $i$ 番目の要素の開始位置である --offset[a[i]] に a[i] を格納する。 計算量は $O(n^{2})$ となる。要素が $k$ 種類のとき、平均計算量は $O(n + k)$ となる。\n参考 バケットソート - Wikipedia ","permalink":"https://0x1feb.github.io/posts/2023/02/16/backet-sort/","summary":"バケットソートとは、整列したいデータがとりうる値の数だけバケツを用意し、全ての要素をバケツに入れた後、順番に取り出すソートアルゴリズムである","title":"バケットソート (Bucket Sort)"},{"content":"概要 正規表現の個人的メモである。 個人的に使いそうなもののみを取り上げているため、全てを網羅している訳ではない。 Visual Studio Code の検索で試した結果をもとにしている。 正規表現を使用するツールやプログラミング言語によっては結果が異なる可能性がある。 正規表現とは 文字列を表現するための方法である。 文字列の検索や置換などで使用される。 文字 メタ文字以外 メタ文字とは、正規表現用の記号として解釈される文字である。 メタ文字以外の文字は、そのままの1文字と一致する。 メタ文字を文字として表現するには、エスケープ文字を用いる。 以下の例だと、^ は行頭を意味するメタ文字として解釈される。 ^ という文字として表現するためにはエスケープする必要がある。 regexp example text match result a abc cba a 0 012 890 0 ^ a^b no match エスケープ文字 正規表現としての意味を持つ文字を本来の文字として使う場合、エスケープする必要がある。 エスケープする文字の前に \\ を付与することで、本来の文字として扱われる。 以下の例では、() をエスケープしない場合、正規表現のグルーピング記号として表現される。 regexp example text match result \\(abc\\) (abc) (abc) (abc) (abc) abc 任意の1文字 (.) . は任意の1文字と一致する。 改行コードは含まれない。 regexp example text match result .bc abc abc a.c xa@cx a@c 1.4 1234 no match 数字の1文字 (\\d) \\d は数字の1文字と一致する。 regexp example text match result \\d@ 0@ 0@ \\d@ a@ no match \\d 以外の1文字 (\\D) \\D は \\d 以外の1文字と一致する。 regexp example text match result \\D@ a@ a@ \\D@ 0@ no match 英数字 (_を含む) の1文字 (\\w) \\w は英数字 (_を含む) の1文字と一致する。 regexp example text match result \\w@ a@ a@ \\w@ 0@ 0@ \\w@ _@ _@ \\w@ -@ no match \\w 以外の1文字 (\\W) \\W は \\w 以外の1文字と一致する。 regexp example text match result \\W@ -@ -@ \\W@ a@ no match \\W@ 0@ no match \\W@ _@ no match 空白の1文字 (\\s) \\s は空白の1文字と一致する。 regexp example text match result 0\\s1 0 1 0 1 0\\s1 0　1 0　1 0\\s1 0_1 no match \\s 以外の1文字 (\\S) \\S は \\s 以外の1文字と一致する。 regexp example text match result 0\\S1 0_1 0_1 0\\S1 0 1 no match 0\\S1 0　1 no match 改行の1文字 (\\n) \\n は改行コード1文字と一致する。 タブの1文字 (\\t) \\t はタブ1文字と一致する。 アンカー 行頭 (^) ^ は行頭と一致する。 regexp example text match result ^abc abcdef abc ^abc defabc no match 行末 ($) $ は行末と一致する。 regexp example text match result abc$ defabc abc abc$ abcdef no match 先読み 肯定先読み ((?=\u0026hellip;)) (?=...) は、パターンが続く文字列を表現するが、マッチした結果の文字列には含めない。 regexp example text match result abc(?=xyz) abcxyz abc abc(?=xyz) abcdef no match 否定先読み ((?!\u0026hellip;)) (?!...) は、パターンが続かない文字列を表現するが、マッチした結果の文字列には含めない。 regexp example text match result abc(?!xyz) abcdef abc abc(?!xyz) abcxyz no match 後読み 肯定後読み ((?\u0026lt;=\u0026hellip;)) (?\u0026lt;=...) は、パターンが続く文字列を表現するが、マッチした結果の文字列には含めない。 regexp example text match result (?\u0026lt;=abc)xyz abcxyz xyz (?\u0026lt;=abc)xyz defxyz no match 否定後読み ((?\u0026lt;!\u0026hellip;)) (?\u0026lt;!...) は、パターンが続かない文字列を表現するが、マッチした結果の文字列には含めない。 regexp example text match result (?\u0026lt;!abc)xyz abcxyz no match (?\u0026lt;!abc)xyz defxyz xyz 量指定子 0回以上の繰り返し (*) * は直前の文字を0回以上繰り返した文字と一致する。 regexp example text match result a*bc bc bc a*bc abc abc a*bc aabc aabc a*bc -bc bc 1回以上の繰り返し (+) + は直前の文字を1回以上繰り返した文字と一致する。 regexp example text match result a+bc abc abc a+bc aabc aabc a+bc bc no match a+bc -bc no match 0回または1回の繰り返し (?) ? は直前の文字を0回または1回繰り返した文字と一致する。 regexp example text match result a?bc bc bc a?bc abc abc a?bc aabc abc a?bc -bc bc n回の繰り返し ({n}) {n} は直前の文字をn回繰り返した文字と一致する。 regexp example text match result ab{0}c ac ac ab{1}c abc abc ab{2}c abbc abbc ab{0}c abc no match ab{1}c abbc no match ab{2}c abbbc no match n回以上m回以下の繰り返し ({n,m}) {n,m} は直前の文字をn回以上m回以下繰り返した文字と一致する。 {n,} は直前の文字をn回以上繰り返した文字と一致する。 regexp example text match result ab{1,3}c abc abc ab{1,3}c abbc abbc ab{1,3}c abbbc abbbc ab{1,3}c ac no match ab{1,3}c abbbbc no match ab{2}c abbc abbc ab{2}c abbbc abbbc 集合と範囲 いずれかの1文字 ([\u0026hellip;]) [...] は [] 内のいずれかの1文字と一致する。 regexp example text match result [a0]@ a@ a@ [a0]@ 0@ 0@ [a0]@ b@ no match [a0]@ 1@ no match [a-z] や [0-9] で連続する文字を短縮表記で表現することができる。 regexp example text match result [a-d]@ c@ c@ [2-5]@ 3@ 3@ いずれかの1文字以外の1文字 ([^\u0026hellip;]) [^...] は [^] 内のいずれかの1文字と一致する。 regexp example text match result [^a0]@ b@ b@ [^a0]@ 1@ 1@ [^a0]@ a@ not mtach [^a0]@ 0@ not mtach その他 AまたはB (A|B) A|B は A または B の1文字と一致する。 regexp example text match result a a a a b b a c no match グルーピング ((\u0026hellip;)) (...) は () 内を1つのサブグループとして表現する。 () 内にマッチする文字列を個々に取り出すことができる。 VSCode では、n番目の () にマッチする文字列を $n で取り出せる。 regexp example text match result (abc)(xyz) abcxyz abcxyz (abc){2}(xyz) abcabcxyz abcabcxyz ","permalink":"https://0x1feb.github.io/posts/2023/02/04/regular-expression/","summary":"概要 正規表現の個人的メモである。 個人的に使いそうなもののみを取り上げているため、全てを網羅している訳ではない。 Visual Studio Code の検索で試した結果をもと","title":"正規表現メモ"},{"content":"クイックソートとは、適当な数を基準として、小さい値と大きい値に分割することを繰り返すソートアルゴリズムである。\nソースコード #include \u0026lt;bits/stdc++.h\u0026gt; #define rep(i, n) for (int i = 0; i \u0026lt; (n); ++i) using namespace std; using vi = vector\u0026lt;int\u0026gt;; void print_list(vi A, int n) { rep(i, n) cout \u0026lt;\u0026lt; (i \u0026gt; 0 ? \u0026#34; \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; A[i]; cout \u0026lt;\u0026lt; endl; } void quick_sort(vi \u0026amp;A, int left, int right) { if (right - left \u0026lt;= 1) return; // 右端の値を pivot とする int pivot = A[right - 1]; // pivot 未満となる要素の右端となる添え字 int i = left; // pivot を基準として、pivot 未満の値が左側になるよう交換 for (int j = left; j \u0026lt; right - 1; j++) { if (A[j] \u0026lt; pivot) swap(A[i++], A[j]); } // pivot を適切な位置に挿入 swap(A[i], A[right - 1]); // pivot の左側を再帰的にソート quick_sort(A, left, i); // pivot の右側を再帰的にソート quick_sort(A, i + 1, right); } int main() { int n; cin \u0026gt;\u0026gt; n; vi A(n); rep(i, n) cin \u0026gt;\u0026gt; A[i]; quick_sort(A, 0, n); print_list(A, n); return 0; } 実行した結果は以下のとおり。\n// 入力 8 8 4 3 7 1 6 2 5 // 出力 1 2 3 4 5 6 7 8 解説 初期データを [8, 4, 3, 7, 1, 6, 2, 5] とする。 右端の値である 5 を pivot とし、5 未満の値が左側、5 以上の値が右側になるよう整理する。 4 と 8 を交換 [4, 8, 3, 7, 1, 6, 2, 5] 3 と 8 を交換 [4, 3, 8, 7, 1, 6, 2, 5] 1 と 8 を交換 [4, 3, 1, 7, 8, 6, 2, 5] 2 と 7 を交換 [4, 3, 1, 2, 8, 6, 7, 5] pivot である 5 を適切な位置に挿入 [4, 3, 1, 2, 5, 6, 7, 8] 分割した左半分 [4, 3, 1, 2] と右半分 [5, 6, 7, 8] の要素について、再帰的に同じ処理を繰り返す。 pivot の選択に毎回最大値か最小値が選ばれる場合、最悪の計算量は $O(n^{2})$ となる。pivot が左右均等に分割できる場合、平均計算量は $O(n \\log{n})$ となる。\n参考 クイックソート - Wikipedia ","permalink":"https://0x1feb.github.io/posts/2023/01/12/quick-sort/","summary":"クイックソートとは、適当な数を基準として、小さい値と大きい値に分割することを繰り返すソートアルゴリズムである。 ソースコード #include \u0026lt;bits/stdc++.h\u0026gt; #define rep(i, n) for (int i =","title":"クイックソート (Quick Sort)"},{"content":"マージソートとは、配列を分割し、分割された各配列の要素をソートしてマージするソートアルゴリズムである。\nソースコード #include \u0026lt;bits/stdc++.h\u0026gt; #define rep(i, n) for (int i = 0; i \u0026lt; (n); ++i) using namespace std; using vi = vector\u0026lt;int\u0026gt;; void print_list(vi A, int n) { rep(i, n) cout \u0026lt;\u0026lt; (i \u0026gt; 0 ? \u0026#34; \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; A[i]; cout \u0026lt;\u0026lt; endl; } void merge_sort(vi \u0026amp;A, int left, int right) { if (right - left == 1) return; int mid = (left + right) / 2; // 左半分をソート merge_sort(A, left, mid); // 右半分をソート merge_sort(A, mid, right); // 左半分と右半分のソート結果をコピー（右は逆順） vi buf; for (int i = left; i \u0026lt; mid; i++) buf.push_back(A[i]); for (int i = right - 1; i \u0026gt;= mid; i--) buf.push_back(A[i]); // 左半分と右半分の要素から小さい順に要素を取り出してマージ int left_i = 0; int right_i = buf.size() - 1; for (int i = left; i \u0026lt; right; i++) { A[i] = buf[left_i] \u0026lt;= buf[right_i] ? buf[left_i++] : buf[right_i--]; } } int main() { int n; cin \u0026gt;\u0026gt; n; vi A(n); rep(i, n) cin \u0026gt;\u0026gt; A[i]; merge_sort(A, 0, n); print_list(A, n); return 0; } 実行した結果は以下のとおり。\n// 入力 8 8 4 3 7 6 5 2 1 // 出力 1 2 3 4 5 6 7 8 解説 初期データを [8, 4, 3, 7, 6, 5, 2, 1] とする。 分割できなくなるまで（分割した要素数が1になるまで）再帰的に分割する。 [8, 4, 3, 7], [6, 5, 2, 1] [8, 4], [3, 7], [6, 5], [2, 1] [8], [4], [3], [7], [6], [5], [2], [1] 分割した左半分と右半分の要素から、小さい順に要素を取り出してマージする。 [4, 8], [7, 3], [5, 6], [1, 2] [3, 4, 7, 8], [1, 2, 5, 6] [1, 2, 3, 4, 5, 6, 7, 8] 分割するときの計算量は $O(\\log{n})$ であり、マージするときの計算量は $O(n)$ となるので、マージソートの計算量は $O(n \\log{n})$ となる。\n参考 マージソート - Wikipedia ","permalink":"https://0x1feb.github.io/posts/2023/01/06/merge-sort/","summary":"マージソートとは、配列を分割し、分割された各配列の要素をソートしてマージするソートアルゴリズムである。 ソースコード #include \u0026lt;bits/stdc++.h\u0026gt; #define rep(i, n) for (int i = 0; i \u0026lt; (n);","title":"マージソート (Merge Sort)"},{"content":"注意点 過去のコミットを修正すると、修正したコミット以降のハッシュ値が変わる。そのため、GitHub 等のリモートリポジトリに push するときは、push -f とする必要がある。これは強制的に上書きする行為なので、複数人で管理しているときなどは注意すること。\n初期状態 以下のファイルを上から順番にコミットしたとする。\nhello morning night $ ls hello morning night $ cat hello hallo, world! $ cat morning god morning! $ cat night good night $ git log --oneline 564bd9c (HEAD -\u0026gt; main) Add night 97e326f Add morning b739670 first commit 直前のコミットを修正 直前のコミットを修正したい場合は、commit コマンドに --amend オプションを付ける。\n以下の例では、night ファイルに sweet dreams というメッセージを追加し、コミットメッセージも変更している。\n$ echo \u0026#39;sweet dreams\u0026#39; \u0026gt;\u0026gt; night $ git diff diff --git a/night b/night index d55621b..461a258 100644 --- a/night +++ b/night @@ -1 +1,2 @@ good night +sweet dreams $ git add night $ git commit --amend -m \u0026#34;Add night messages\u0026#34; [main a8e822b] Add night messages Date: Fri Apr 16 01:13:50 2021 +0900 1 file changed, 2 insertions(+) create mode 100644 night $ git log --oneline a8e822b (HEAD -\u0026gt; main) Add night messages 97e326f Add morning b739670 first commit 2つ以上前のコミットを修正 2つ前にコミットした morning ファイルの内容が god morning になっているので good morning に修正する。\ncommit --amend は直前のコミットにしか使えないので、rebase コマンドを用いる。\ngit log でコミットログを出力し、修正したいコミットの1つ前のコミットを指定して rebase を実行する。\n$ git log --oneline a8e822b (HEAD -\u0026gt; main) Add night messages 97e326f Add morning b739670 first commit $ git rebase -i b739670 Stopped at 97e326f... Add morning You can amend the commit now, with git commit --amend Once you are satisfied with your changes, run git rebase --continue 以下のファイルが開かれるので、修正したいコミットの pick を edit に変更して保存する。\n- pick 97e326f Add morning + edit 97e326f Add morning pick a8e822b Add night messages # Rebase b739670..a8e822b onto b739670 (2 commands) # # Commands: # p, pick \u0026lt;commit\u0026gt; = use commit # r, reword \u0026lt;commit\u0026gt; = use commit, but edit the commit message # e, edit \u0026lt;commit\u0026gt; = use commit, but stop for amending # s, squash \u0026lt;commit\u0026gt; = use commit, but meld into previous commit # f, fixup \u0026lt;commit\u0026gt; = like \u0026#34;squash\u0026#34;, but discard this commit\u0026#39;s log message # x, exec \u0026lt;command\u0026gt; = run command (the rest of the line) using shell # b, break = stop here (continue rebase later with \u0026#39;git rebase --continue\u0026#39;) # d, drop \u0026lt;commit\u0026gt; = remove commit # l, label \u0026lt;label\u0026gt; = label current HEAD with a name # t, reset \u0026lt;label\u0026gt; = reset HEAD to a label # m, merge [-C \u0026lt;commit\u0026gt; | -c \u0026lt;commit\u0026gt;] \u0026lt;label\u0026gt; [# \u0026lt;oneline\u0026gt;] # . create a merge commit using the original merge commit\u0026#39;s # . message (or the oneline, if no original merge commit was # . specified). Use -c \u0026lt;commit\u0026gt; to reword the commit message. # # These lines can be re-ordered; they are executed from top to bottom. # # If you remove a line here THAT COMMIT WILL BE LOST. # # However, if you remove everything, the rebase will be aborted. # # Note that empty commits are commented out ファイルを閉じると、修正したいコミットをした直後の状態になる。\n$ git log --oneline 97e326f (HEAD) Add morning b739670 first commit あとは直前のコミットを修正するのと同じように修正する。\n$ git diff diff --git a/morning b/morning index c94a8fd..527cb14 100644 --- a/morning +++ b/morning @@ -1 +1 @@ -god morning! +good morning! $ git add morning $ git commit --amend -m \u0026#34;Add morning\u0026#34; [detached HEAD 4667fe5] Add morning Date: Fri Apr 16 01:12:51 2021 +0900 1 file changed, 1 insertion(+) create mode 100644 morning $ git status interactive rebase in progress; onto b739670 Last command done (1 command done): edit 97e326f Add morning Next command to do (1 remaining command): pick a8e822b Add night messages (use \u0026#34;git rebase --edit-todo\u0026#34; to view and edit) You are currently editing a commit while rebasing branch \u0026#39;main\u0026#39; on \u0026#39;b739670\u0026#39;. (use \u0026#34;git commit --amend\u0026#34; to amend the current commit) (use \u0026#34;git rebase --continue\u0026#34; once you are satisfied with your changes) nothing to commit, working tree clean このコミット以外は修正しないので、以下コマンドで最新コミットまで進める。\n$ git rebase --continue Successfully rebased and updated refs/heads/main. $ git status On branch main nothing to commit, working tree clean $ git log --oneline 63c4c92 (HEAD -\u0026gt; main) Add night messages 4667fe5 Add morning b739670 first commit 初回コミットを修正 初回にコミットした hello ファイルの内容を hallo world! から hello, world! に修正する。\nしかし、rebase -i では初回コミットの前のコミットハッシュを指定することができない。\nこの場合は、rebase -i --root とすると、初回コミットを修正することができる。\n$ git rebase -i --root Stopped at b739670... first commit You can amend the commit now, with git commit --amend Once you are satisfied with your changes, run git rebase --continue 初回コミットを edit に変更し、保存して閉じる。\n- pick b739670 first commit + edit b739670 first commit pick 4667fe5 Add morning pick 63c4c92 Add night messages 初回コミット直後の状態になるので、先ほどと同じような手順で修正を反映する。\n$ git diff diff --git a/hello b/hello index 7ed9b8c..270c611 100644 --- a/hello +++ b/hello @@ -1 +1 @@ -hallo, world! +hello, world! $ git add hello $ git commit --amend -m \u0026#34;Add hello\u0026#34; [detached HEAD 2390055] Add hello Date: Fri Apr 16 01:11:31 2021 +0900 1 file changed, 1 insertion(+) create mode 100644 hello $ git status interactive rebase in progress; onto dc37feb Last command done (1 command done): edit b739670 first commit Next commands to do (2 remaining commands): pick 4667fe5 Add morning pick 63c4c92 Add night messages (use \u0026#34;git rebase --edit-todo\u0026#34; to view and edit) You are currently editing a commit while rebasing branch \u0026#39;main\u0026#39; on \u0026#39;dc37feb\u0026#39;. (use \u0026#34;git commit --amend\u0026#34; to amend the current commit) (use \u0026#34;git rebase --continue\u0026#34; once you are satisfied with your changes) nothing to commit, working tree clean $ git rebase --continue Successfully rebased and updated refs/heads/main. $ git log --oneline 078325e (HEAD -\u0026gt; main) Add night messages f56e0d9 Add morning 2390055 Add hello ","permalink":"https://0x1feb.github.io/posts/2023/01/05/modifying-past-commit/","summary":"注意点 過去のコミットを修正すると、修正したコミット以降のハッシュ値が変わる。そのため、GitHub 等のリモートリポジトリに push するときは、pu","title":"Git における過去コミットの修正"},{"content":"ソースコード バブルソートとは、順番が逆になっている隣接要素がなくなるまで大小を比較し交換するソートアルゴリズムである。\n#include \u0026lt;bits/stdc++.h\u0026gt; #define rep(i, n) for (int i = 0; i \u0026lt; (n); ++i) using namespace std; using vi = vector\u0026lt;int\u0026gt;; void print_list(vi A, int n) { rep(i, n) cout \u0026lt;\u0026lt; (i \u0026gt; 0 ? \u0026#34; \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; A[i]; cout \u0026lt;\u0026lt; endl; } void bubble_sort(vi \u0026amp;A, int n) { // 外側のループが1週すると、配列の最後からi番目の数が確定する rep(i, n - 1) { // 未確定部分について、隣同士を比較して入れ替えていく rep(j, n - 1 - i) { if (A[j] \u0026gt; A[j + 1]) swap(A[j], A[j + 1]); } print_list(A, n); } } int main() { int n; cin \u0026gt;\u0026gt; n; vi A(n); rep(i, n) cin \u0026gt;\u0026gt; A[i]; bubble_sort(A, n); return 0; } 実行した結果は以下のとおり。\n// 入力 8 8 4 3 7 6 5 2 1 // 出力 4 3 7 6 5 2 1 8 (1回目の外側ループ終了時) 3 4 6 5 2 1 7 8 (2回目の外側ループ終了時) 3 4 5 2 1 6 7 8 (3回目の外側ループ終了時) 3 4 2 1 5 6 7 8 (4回目の外側ループ終了時) 3 2 1 4 5 6 7 8 (5回目の外側ループ終了時) 2 1 3 4 5 6 7 8 (6回目の外側ループ終了時) 1 2 3 4 5 6 7 8 (7回目の外側ループ終了時) 解説 外側のループ変数 $i$ で整列済み部分の先頭インデックスをカウントする。 内側のループ変数 $j$ で先頭から未整列部分の末尾まで $[0, n-1-i)$ のインデックスをカウントする。 内側のループで隣同士を比較し、順序が逆なら入れ替える。 上記操作を繰り返すと、配列全体が整列する。 最悪の場合の比較回数は $(n-1) + (n-2) + \\cdots + 1 = (n^2-n)/2$ となるため、計算量は $O(n^{2})$ となる。\n参考 バブルソート - Wikipedia ","permalink":"https://0x1feb.github.io/posts/2023/01/04/bubble-sort/","summary":"ソースコード バブルソートとは、順番が逆になっている隣接要素がなくなるまで大小を比較し交換するソートアルゴリズムである。 #include \u0026lt;bits/stdc++.h\u0026gt; #define rep(i, n) for (int i = 0; i","title":"バブルソート (Bubble sort)"},{"content":"概要 Android アプリを作ってみたくなったので、チュートリアルを試してみた結果をメモとして残す。\n準備 Kotlin の基礎知識があること。 Android Studio がインストールされていること。 実機でアプリを動かす場合は確認用の Android 端末があること。 サンプルアプリの作成 テンプレートからプロジェクトを作成する Android Studio を起動し、[New Project] をクリックする。 [Phone and Tablet] を選択し、[Empty Compose Activity] を選択する。 [Next] をクリックする。 以下を入力する。 Name: GreetingCard Package name: com.example.greetingcard Save location: 任意のパス Language: Kotlin (固定) Minimum SDK: API 21: Android 5.0 (Lollipop) [Finish] をクリックする。 読み込みが終わるまで時間がかかるのでしばらく待つと、テンプレートを使用したプロジェクトが作成される。\nテキスト/デザインを更新する MainActivity.kt の Greeting() を次のように変更する。\n@Composable fun Greeting(name: String) { Text(text = \u0026#34;Hi, my name is $name!\u0026#34;) } Greeting() を呼び出すときの引数を任意の名前に変更する。\nGreeting(\u0026#34;rano\u0026#34;) Text... の行をハイライト表示し、Alt + Enter を押して、[Surround with widget] を選択する。\n@Composable fun Greeting(name: String) { Box { Text(text = \u0026#34;Hi, my name is $name!\u0026#34;) } } Box を Surface() に変更する。\n@Composable fun Greeting(name: String) { Surface() { Text(text = \u0026#34;Hi, my name is $name!\u0026#34;) } } color パラメータを追加する。（ここでは青を指定）\n... import androidx.compose.ui.graphics.Color ... @Composable fun Greeting(name: String) { Surface(color = Color.Blue) { Text(text = \u0026#34;Hi, my name is $name!\u0026#34;) } } パディングを追加する。\n... import androidx.compose.foundation.layout.padding ... import androidx.compose.ui.unit.dp ... @Composable fun Greeting(name: String) { Surface(color = Color.Blue) { Text(text = \u0026#34;Hi, my name is $name!\u0026#34;, modifier = Modifier.padding(24.dp)) } } 以上で簡単なカスタマイズが完了した。\n実機での動作確認 開発用デバイスをセットアップする デバイスとの接続は、USB 接続と Wi-Fi 接続の2種類あるが、今回は Wi-Fi 経由で接続する。\nデバイスの設定アプリより、[開発者向けオプション] を選択し、[ワイヤレス デバッグ] を有効にする。 デバイスの開発者向けオプションを設定する ｜ Android デベロッパー ｜ Android Developers デバイスに接続する 実行構成のプルダウンメニューから [Pair Devices Using Wi-Fi] を選択する。 デバイスの設定アプリより、[開発者向けオプション] を選択し、[ワイヤレス デバッグ] を選択する。 [QR コードによるデバイスのペア設定] を選択し、QR コードを読み取る。 ペアリングしたら対象のデバイスを選択し、[Run \u0026lsquo;app\u0026rsquo;] のアイコンをクリックする。 実機端末にサンプルアプリが表示される。 基本はエミュレータでの確認で問題ないと思うが、実際の操作感を確認したい場合は実機を使うのが良い。\n参考 初めてのアプリを作成する ｜ Android デベロッパー ｜ Android Developers ハードウェア デバイス上でのアプリの実行 ｜ Android デベロッパー ｜ Android Developers ","permalink":"https://0x1feb.github.io/posts/2023/01/03/basic-android-kotlin-compose-first-app/","summary":"概要 Android アプリを作ってみたくなったので、チュートリアルを試してみた結果をメモとして残す。 準備 Kotlin の基礎知識があること。 Android Studio がインストールされてい","title":"Android アプリ入門"},{"content":"挿入ソートとは、未ソートの部分から取り出した要素を、ソート済みの部分の適切な位置に挿入するソートアルゴリズムである。\nソースコード #include \u0026lt;bits/stdc++.h\u0026gt; #define rep(i, n) for (int i = 0; i \u0026lt; (n); ++i) using namespace std; using vi = vector\u0026lt;int\u0026gt;; void print_list(vi A, int n) { rep(i, n) cout \u0026lt;\u0026lt; (i \u0026gt; 0 ? \u0026#34; \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; A[i]; cout \u0026lt;\u0026lt; endl; } void insertion_sort(vi \u0026amp;A, int n) { rep(i, n - 1) { // i番目までソート済み // i+1番目の要素を挿入対象とする int tmp = A[i + 1]; // 整列済みの要素 (A[j], A[j-1], ..., A[0]) の中で適切な挿入位置を探す int j = i; while (j \u0026gt;= 0 \u0026amp;\u0026amp; A[j] \u0026gt; tmp) { A[j + 1] = A[j]; j--; } A[j + 1] = tmp; print_list(A, n); } } int main() { int n; cin \u0026gt;\u0026gt; n; vi A(n); rep(i, n) cin \u0026gt;\u0026gt; A[i]; insertion_sort(A, n); return 0; } 実行した結果は以下のとおり。\n// 入力 8 8 4 3 7 6 5 2 1 // 出力 4 8 3 7 6 5 2 1 (1回目のループ終了時) 3 4 8 7 6 5 2 1 (2回目のループ終了時) 3 4 7 8 6 5 2 1 (3回目のループ終了時) 3 4 6 7 8 5 2 1 (4回目のループ終了時) 3 4 5 6 7 8 2 1 (5回目のループ終了時) 2 3 4 5 6 7 8 1 (6回目のループ終了時) 1 2 3 4 5 6 7 8 (7回目のループ終了時) 解説 以下の操作を繰り返すことでソートする。\n0番目の要素を整列済みの配列とし、1番目の要素を適切な位置に挿入する。 0番目と1番目までの配列は整列済みなので、2番目の要素を適切な位置に挿入する。 上記操作を配列の最後の要素まで繰り返すと、配列全体が整列する。 挿入対象となる値は tmp に格納し、適切な位置が見つかるまで A[j + 1] = A[j] で整列済みの配列の要素を後ろにずらす。\nループの条件を抜けたときの j + 1 が挿入位置となるため、A[j + 1] = tmp で挿入する。\n最悪の場合、 $i$ ループの各処理が $i$ 回行われるため、計算量は $O(n^{2})$ となる。\n参考 挿入ソート - Wikipedia ","permalink":"https://0x1feb.github.io/posts/2022/12/29/insertion-sort/","summary":"挿入ソートとは、未ソートの部分から取り出した要素を、ソート済みの部分の適切な位置に挿入するソートアルゴリズムである。 ソースコード #include \u0026lt;bits/stdc++.h\u0026gt; #define rep(i, n) for","title":"挿入ソート (Insertion sort)"},{"content":"ユークリッドの互除法とは、2つの自然数の最大公約数を求めるアルゴリズムである。\nソースコード #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int gcd(int a, int b) { return (b == 0 ? a : gcd(b, a % b)); } int main() { cout \u0026lt;\u0026lt; gcd(1071, 1029) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; gcd(1029, 1071) \u0026lt;\u0026lt; endl; return 0; } 出力結果は以下の通り。\n21 21 参考 ユークリッドの互除法 - Wikipedia - Wikipedia ","permalink":"https://0x1feb.github.io/posts/2022/12/27/euclidean-algorithm/","summary":"ユークリッドの互除法とは、2つの自然数の最大公約数を求めるアルゴリズムである。 ソースコード #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int gcd(int a, int b) { return (b == 0 ? a : gcd(b, a % b)); } int main()","title":"最大公約数 (ユークリッドの互除法)"},{"content":"二分探索とは、ソート済みの配列について、探索範囲を半分に絞り込む操作を繰り返す検索アルゴリズムである。\nたとえば、素数の配列が与えられているとき、指定した数よりも小さい数のうち最大となる数を調べる。\nソースコード #include \u0026lt;bits/stdc++.h\u0026gt; #define rep(i, n) for (int i = 0; i \u0026lt; (n); ++i) #define srep(i, s, t) for (int i = s; i \u0026lt; t; ++i) using namespace std; using vi = vector\u0026lt;int\u0026gt;; vi sieve_of_eratosthenes(int n) { vector\u0026lt;bool\u0026gt; is_prime(n + 1); srep(i, 2, n + 1) is_prime[i] = true; vi primes; rep(i, n + 1) { if (is_prime[i]) { primes.push_back(i); for (int j = i * i; j \u0026lt;= n; j += i) is_prime[j] = false; } } return primes; } bool solve(int a, int x) { // 判定条件 return a \u0026lt; x; } int binary_search(vi list, int x) { int ok = -1; // 条件を満たす最大の位置 int ng = list.size(); // 条件を満たさない最小の位置 while (abs(ok - ng) \u0026gt; 1) { int mid = (ok + ng) / 2; if (solve(list[mid], x)) { // 条件を満たす場合 ok の位置を拡張する ok = mid; } else { // 条件を満たさない場合 ng の位置を拡張する ng = mid; } } return ok; } void print_info(vi list, int i) { cout \u0026lt;\u0026lt; \u0026#34;index: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;number: \u0026#34;; if (i == -1) { cout \u0026lt;\u0026lt; \u0026#34;not found\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; list[i] \u0026lt;\u0026lt; endl; } } int main() { // 100までの素数の配列 // 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 vi primes = sieve_of_eratosthenes(100); cout \u0026lt;\u0026lt; \u0026#34;29より小さい数のうち最大となる素数\u0026#34; \u0026lt;\u0026lt; endl; print_info(primes, binary_search(primes, 29)); cout \u0026lt;\u0026lt; \u0026#34;30より小さい数のうち最大となる素数\u0026#34; \u0026lt;\u0026lt; endl; print_info(primes, binary_search(primes, 30)); cout \u0026lt;\u0026lt; \u0026#34;2より小さい数のうち最大となる素数\u0026#34; \u0026lt;\u0026lt; endl; print_info(primes, binary_search(primes, 2)) return 0; } 出力結果は以下の通り。\n29より小さい数のうち最大となる素数 index: 8 number: 23 30より小さい数のうち最大となる素数 index: 9 number: 29 2より小さい数のうち最大となる素数 index: -1 number: not found 解説 探索する配列はソート済みである必要がある。\nok と ng は配列の添え字の下限-1と上限+1で初期化する。 ok: 条件を満たす最大の位置（初期値-1を除く） ng: 条件を満たさない最小の位置 中央値 mid が条件を満たすかを判定する。 true: ok の位置を mid まで拡張 false: ng の位置を mid まで拡張 ok と ng が隣同士になったとき、探索を終了する。 探索終了時点の ok の位置が、条件を満たす最大の値となる。 条件を満たす値が1つもない場合、ok の値は初期値のままで -1 となることに注意 $n$ 個のデータがある場合の計算量は $O(\\log n)$ となる。\n参考 https://twitter.com/meguru_comp/status/697008509376835584 ","permalink":"https://0x1feb.github.io/posts/2022/12/25/binary-search/","summary":"二分探索とは、ソート済みの配列について、探索範囲を半分に絞り込む操作を繰り返す検索アルゴリズムである。 たとえば、素数の配列が与えられていると","title":"二分探索 (binary search)"},{"content":"ナップサック問題とは、 $n$ 種類の品物（価値 $v$ , 重量 $w$ ）のうちいくつかを選び、ナップサックに収まる範囲で品物の価値の合計が最大になる選び方を求める問題である。\n様々な解き方があるが、動的計画法で解いてみる。（問題は D - Knapsack 1）\nソースコード #include \u0026lt;bits/stdc++.h\u0026gt; #define rep(i, n) for (int i = 0; i \u0026lt; (n); ++i) #define maxs(x, y) (x = max(x, y)) using namespace std; using ll = long long; using vl = vector\u0026lt;ll\u0026gt;; using vvl = vector\u0026lt;vl\u0026gt;; int main() { int N, W; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; W; vl weight(N), value(N); rep(i, N) cin \u0026gt;\u0026gt; weight[i] \u0026gt;\u0026gt; value[i]; vvl dp(N + 1, vl(W + 1, 0)); rep(i, N) rep(w, W + 1) { // i個目の品物を選ぶ場合 if (w \u0026gt;= weight[i]) maxs(dp[i + 1][w], dp[i][w - weight[i]] + value[i]); // i個目の品物を選ばない場合 maxs(dp[i + 1][w], dp[i][w]); } cout \u0026lt;\u0026lt; dp[N][W] \u0026lt;\u0026lt; endl; return 0; } 解説 dp[i][w] には、最初の $i$ 個の品物の中から重さの合計が $w$ 以下になるよう選んだときの価値の合計の最大値を格納する。\n$i$ 個目の品物を選ぶ場合は、選ぶ前の状態 dp[i][w - weight[i]] に $i$ 個目の品物の価値 value[i] を追加した値を格納する。（ナップサックの容量を超えてはならないため、w \u0026gt;= weight[i] の条件が必要となる。）\nmaxs(dp[i + 1][w], dp[i][w - weight[i]] + value[i])\n$i$ 個目の品物を選ばない場合は、選ぶ前の状態 dp[i][w] と何の変化もないため、そのままの値を格納する。\nmaxs(dp[i + 1][w], dp[i][w]);\nちなみに、 $i = 0$ のときは品物を1つも選ばないので、すべての $w$ について価値の合計の最大値は0となる。また、任意の $i$ について、$w = 0$ のときは品物を1つも入れることができないので、価値の合計の最大値は0となる。\n参考 ナップサック問題 - Wikipedia D - Knapsack 1 ","permalink":"https://0x1feb.github.io/posts/2022/12/21/knapsack-dp/","summary":"ナップサック問題とは、 $n$ 種類の品物（価値 $v$ , 重量 $w$ ）のうちいくつかを選び、ナップサックに収まる範囲で品物の価値の合計が最大になる選び方を求め","title":"ナップサック問題 (動的計画法)"},{"content":"エラトステネスの篩とは、指定した数以下の素数を探すアルゴリズムである。\n指定した数までの数列を用意し、素数を見つけたらその素数の倍数を篩い落としていくことで、素数のみの数列が残るという仕組みである。\nソースコード #include \u0026lt;bits/stdc++.h\u0026gt; #define rep(i, n) for (int i = 0; i \u0026lt; (n); ++i) #define srep(i, s, t) for (int i = s; i \u0026lt; t; ++i) using namespace std; using vi = vector\u0026lt;int\u0026gt;; vi sieve_of_eratosthenes(int n) { vector\u0026lt;bool\u0026gt; is_prime(n + 1); // 添え字の数が素数か判定した結果を持つ配列 // 0, 1 は素数ではないので false のまま初期化する srep(i, 2, n + 1) is_prime[i] = true; vi primes; // 素数を格納する配列 rep(i, n + 1) { if (is_prime[i]) { primes.push_back(i); // 素数iについて、i^2以上のiの倍数を篩い落とすため false にする for (int j = i * i; j \u0026lt;= n; j += i) is_prime[j] = false; } } return primes; } int main() { vi primes = sieve_of_eratosthenes(100); for (int p : primes) cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; return 0; } 100までの素数を出力した結果は以下の通り。\n2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 参考 エラトステネスの篩 - Wikipedia ","permalink":"https://0x1feb.github.io/posts/2022/12/20/sieve-of-eratosthenes/","summary":"エラトステネスの篩とは、指定した数以下の素数を探すアルゴリズムである。 指定した数までの数列を用意し、素数を見つけたらその素数の倍数を篩い落と","title":"素数列挙 (エラトステネスの篩)"},{"content":"2のべき乗で求められる組み合わせを全探索する方法として、bit 全探索という方法がある。\n例えば、 $n$ 人が「立っている」または「座っている」のどちらかの状態で行列に並んでいるとする。このとき、考えられる行列の並び方を全て列挙する場合に使える。\nソースコード #include \u0026lt;bits/stdc++.h\u0026gt; #define rep(i, n) for (int i = 0; i \u0026lt; (n); ++i) using namespace std; void bit_full_search(int n) { rep(i, 1 \u0026lt;\u0026lt; n) { rep(j, n) { if (i \u0026amp; (1 \u0026lt;\u0026lt; j)) { cout \u0026lt;\u0026lt; \u0026#34;1\u0026#34;; // 1のときの処理 } else { cout \u0026lt;\u0026lt; \u0026#34;0\u0026#34;; // 0のときの処理 } } cout \u0026lt;\u0026lt; endl; } } int main() { bit_full_search(4); return 0; } n = 4 のときの出力結果は以下の通り。先ほどの例えで考えると、立っている状態を0、座っている状態を1とすれば、ありうる行列の組み合わせが全て出力されていることになる。\n0000 1000 0100 1100 0010 1010 0110 1110 0001 1001 0101 1101 0011 1011 0111 1111 解説 数値同士の論理積は、2進数の各位のビットを比較し、両方が1のときのみ1となる。\n#include \u0026lt;bits/stdc++.h\u0026gt; #define rep(i, n) for (int i = 0; i \u0026lt; (n); ++i) using namespace std; void printAndValue(int x, int y) { cout \u0026lt;\u0026lt; bitset\u0026lt;8\u0026gt;(x) \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; bitset\u0026lt;8\u0026gt;(y) \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; bitset\u0026lt;8\u0026gt;(x \u0026amp; y) \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026amp; \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; } int main() { printAndValue(42, 121); return 0; } 00101010 = 42 01111001 = 121 00101000 = 42 \u0026amp; 121 上記の例の場合、42と121を2進数で表したとき、右から4桁目と6桁目はどちらも1であるから、42と121の論理積は 00101000 となる。\nまた、1 \u0026lt;\u0026lt; n で 00000001 を n ビット左シフトした値を得ることができる。\n#include \u0026lt;bits/stdc++.h\u0026gt; #define rep(i, n) for (int i = 0; i \u0026lt; (n); ++i) using namespace std; void printLeftShiftValue(int n) { rep(i, n) { int num = 1 \u0026lt;\u0026lt; i; bitset\u0026lt;8\u0026gt; bit_num(num); cout \u0026lt;\u0026lt; \u0026#34;bit: \u0026#34; \u0026lt;\u0026lt; bit_num \u0026lt;\u0026lt; \u0026#34;, num: \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; } } int main() { printLeftShiftValue(8); return 0; } 1を0ビットから7ビットまで左シフトした出力結果は以下の通り。\nbit: 00000001, num: 1 bit: 00000010, num: 2 bit: 00000100, num: 4 bit: 00001000, num: 8 bit: 00010000, num: 16 bit: 00100000, num: 32 bit: 01000000, num: 64 bit: 10000000, num: 128 ある数iについて、上記の数との論理積をとれば、任意の位が0か1かを判定することができる。\nbitFullSearch() ではこの性質を組み合わせることで、全探索を実現している。\n外側のループで $0$ から $2^{n-1}$ までの数値 $i$ を作る。 各 $i$ について、 $2^{0}$ から $2^{n-1}$ 乗までの数値 (1 \u0026lt;\u0026lt; j) との論理積をとる。 論理積 (i \u0026amp; (1 \u0026lt;\u0026lt; j)) の値が $0$ となれば $j+1$ 桁目は $0$ であり、それ以外なら $1$ となる。 ","permalink":"https://0x1feb.github.io/posts/2022/12/18/bit-full-search/","summary":"2のべき乗で求められる組み合わせを全探索する方法として、bit 全探索という方法がある。 例えば、 $n$ 人が「立っている」または「座っている」のどち","title":"bit 全探索"},{"content":"概要 AtCoder で std::map を使うときのメモ書き。\n基本 map キーに設定した値の昇順にソートされる。 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { map\u0026lt;int, int\u0026gt; mp; mp[5] = 10; mp[1] = 3; mp[4] = 6; for (auto p : mp) { printf(\u0026#34;key:%d, value:%d\\n\u0026#34;, p.first, p.second); } return 0; } key:1, value:3 key:4, value:6 key:5, value:10 unorderd_map ソートされないため、 map よりも高速に動作する。 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { unordered_map\u0026lt;int, int\u0026gt; mp; mp[5] = 10; mp[1] = 3; mp[4] = 6; for (auto p : mp) { printf(\u0026#34;key:%d, value:%d\\n\u0026#34;, p.first, p.second); } return 0; } key:4, value:6 key:1, value:3 key:5, value:10 キーの検索 find find でキーを指定すると、該当する場合はイテレータを返す。 該当しない場合は末尾のイテレータを返す。 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { map\u0026lt;int, int\u0026gt; mp; mp[5] = 10; mp[1] = 3; mp[4] = 6; auto f = [](map\u0026lt;int, int\u0026gt; mp, int x) { auto it = mp.find(x); if (it == mp.end()) { cout \u0026lt;\u0026lt; \u0026#34;該当なし。\u0026#34; \u0026lt;\u0026lt; endl; return; } cout \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; endl; }; // 対象キーが存在しない場合 f(mp, 0); // 対象キーが存在する場合 f(mp, 4); return 0; } 該当なし。 4, 6 二分探索(lower_bound/upper_bound) lower_bound 指定したキー \u0026lt;= x となる最小のキー x を持つイテレータを返す。 該当する x が存在しない場合、末尾のイテレータを返す。 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { map\u0026lt;int, int\u0026gt; mp; mp[5] = 10; mp[1] = 3; mp[4] = 6; auto f = [](map\u0026lt;int, int\u0026gt; mp, int x) { auto it = mp.lower_bound(x); if (it == mp.end()) { cout \u0026lt;\u0026lt; \u0026#34;該当なし。\u0026#34; \u0026lt;\u0026lt; endl; return; } cout \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; endl; }; f(mp, 3); f(mp, 4); f(mp, 5); f(mp, 6); return 0; } 4, 6 4, 6 5, 10 該当なし。 upper_bound 指定したキー \u0026lt; x となる最小のキー x を持つイテレータを返す。 該当する x が存在しない場合、末尾のイテレータを返す。 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { map\u0026lt;int, int\u0026gt; mp; mp[5] = 10; mp[1] = 3; mp[4] = 6; auto f = [](map\u0026lt;int, int\u0026gt; mp, int x) { auto it = mp.upper_bound(x); if (it == mp.end()) { cout \u0026lt;\u0026lt; \u0026#34;該当なし。\u0026#34; \u0026lt;\u0026lt; endl; return; } cout \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; endl; }; f(mp, 3); f(mp, 4); f(mp, 5); f(mp, 6); return 0; } 4, 6 5, 10 該当なし。 該当なし。 ","permalink":"https://0x1feb.github.io/posts/2022/10/26/cpp-map-memo/","summary":"概要 AtCoder で std::map を使うときのメモ書き。 基本 map キーに設定した値の昇順にソートされる。 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { map\u0026lt;int, int\u0026gt; mp; mp[5] = 10; mp[1] = 3; mp[4] = 6; for (auto p : mp) { printf(\u0026#34;key:%d, value:%d\\n\u0026#34;, p.first, p.second); } return","title":"C++ の std::map メモ"},{"content":"やりたいこと 単体のリストではない複数の要素に、同じ処理を適用したい。\n複数のリストや要素を一時的にまとめた Stream を作成し、一括で処理したい。\npublic class User { private String name; private int age; public User(String name, int age) { this.name = name; this.age = age; } // getter と setter は省略 public String toString() { return \u0026#34;name: \u0026#34; + name + \u0026#34;, age: \u0026#34; + age; } } 以下のリスト1とリスト2をまとめたり、リスト1と単体の要素1をまとめたりして処理する。\n// リスト1 List\u0026lt;User\u0026gt; userList1 = new ArrayList\u0026lt;User\u0026gt;(); userList1.add(new User(\u0026#34;John\u0026#34;, 40)); userList1.add(new User(\u0026#34;Paul\u0026#34;, 79)); userList1.add(new User(\u0026#34;George\u0026#34;, 58)); userList1.add(new User(\u0026#34;Ringo\u0026#34;, 81)); // リスト2 List\u0026lt;User\u0026gt; userList2 = new ArrayList\u0026lt;User\u0026gt;(); userList2.add(new User(\u0026#34;Albert\u0026#34;, 76)); userList2.add(new User(\u0026#34;Richard\u0026#34;, 69)); // 単体の要素1 User user1 = new User(\u0026#34;Tanaka\u0026#34;, 36); // 単体の要素2 User user2 = new User(\u0026#34;Suzuki\u0026#34;, 74); 単体の要素同士 Stream.of に要素を列挙して Stream を作成する。\nStream.of(user1, user2) .forEach(System.out::println); // name: Tanaka, age: 36 // name: Suzuki, age: 74 リスト同士 Stream.of でリストをまとめると、リスト単位で処理する。\nStream.of(userList1, userList2) .forEach(System.out::println); // [name: John, age: 40, name: Paul, age: 79, name: George, age: 58, name: Ringo, age: 81] // [name: Albert, age: 76, name: Richard, age: 69] リスト内の要素単位で処理する場合は、flatMap を用いる。\nStream.of(userList1, userList2) .flatMap(Collection::stream) .forEach(System.out::println); // name: John, age: 40 // name: Paul, age: 79 // name: George, age: 58 // name: Ringo, age: 81 // name: Albert, age: 76 // name: Richard, age: 69 各リストを Stream に変換し、均した新しい Stream を返ため、各要素単位で処理できる。\n単体の要素とリスト リストと単体の要素を個別に Stream に変換し、Stream.concat でまとめた Stream を作成する。\nStream.concat(userList1.stream(), Stream.of(user1)) .forEach(System.out::println); // name: John, age: 40 // name: Paul, age: 79 // name: George, age: 58 // name: Ringo, age: 81 // name: Tanaka, age: 36 ","permalink":"https://0x1feb.github.io/posts/2022/01/27/combining-multi-elements-in-java-stream/","summary":"やりたいこと 単体のリストではない複数の要素に、同じ処理を適用したい。 複数のリストや要素を一時的にまとめた Stream を作成し、一括で処理したい。 public class User","title":"複数の要素を Stream でまとめる"},{"content":"Stream とは Java 8 から追加され、コレクションに対する集約操作をサポートした機能を持つ。\n中間操作と終端操作を組み合わせてパイプラインにできるため、for 文による繰り返し処理を簡潔に記述できる。\nサンプルクラス User クラス 年齢と名前の情報のみを持つ、以下のユーザクラスを用いる。\npublic class User { private String name; private int age; public User(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String toString() { return \u0026#34;name: \u0026#34; + name + \u0026#34;, age: \u0026#34; + age; } } User のコレクション コレクションは以下とする。\nList\u0026lt;User\u0026gt; userList = new ArrayList\u0026lt;User\u0026gt;(); userList.add(new User(\u0026#34;John\u0026#34;, 40)); userList.add(new User(\u0026#34;Paul\u0026#34;, 79)); userList.add(new User(\u0026#34;George\u0026#34;, 58)); userList.add(new User(\u0026#34;Ringo\u0026#34;, 81)); 要素を順番に処理 forEach userList.stream() .forEach(u -\u0026gt; System.out.println(u)); // name: John, age: 40 // name: Paul, age: 79 // name: George, age: 58 // name: Ringo, age: 81 // 以下も同じ結果 userList.stream() .forEach(System.out::println); ラムダ式を受け取るが、別のメソッドをそのまま呼び出す場合、メソッドのみを渡すこともできる。\n順次/並列 stream ストリームは明示的に並列を指定しない限り、順次で実行される。\n// stream userList.stream() .forEach(System.out::println); // name: John, age: 40 // name: Paul, age: 79 // name: George, age: 58 // name: Ringo, age: 81 parallelStream 並列で実行する場合は、並列のストリームを生成する必要がある。\n// parallelStream userList.parallelStream() .forEach(System.out::println); // name: George, age: 58 // name: Ringo, age: 81 // name: John, age: 40 // name: Paul, age: 79 絞り込み filter 与えられたラムダ式が true となる要素から構成された stream を返す。\n// 60歳未満のみ出力 userList.stream() .filter(u -\u0026gt; u.getAge() \u0026lt; 60) .forEach(System.out::println); // name: John, age: 40 // name: George, age: 58 加工 map 与えられたラムダ式で加工した結果から構成される stream を返す。\n// \u0026#34;My name is XX\u0026#34; の文字列に加工して出力 userList.stream() .map(u -\u0026gt; \u0026#34;My name is\u0026#34; + u.getName()) .forEach(System.out::println); // My name isJohn // My name isPaul // My name isGeorge // My name isRingo スキップ skip 先頭から n 番目の要素を除いた stream を返す。\nuserList.stream() .skip(2) .forEach(System.out::println); // name: George, age: 58 // name: Ringo, age: 81 この例の場合、John と Paul の2人がスキップされている。\n要素数の制限 limit 指定した要素数の stream を返す。\nuserList.stream() .limit(2) .forEach(System.out::println); // name: John, age: 40 // name: Paul, age: 79 並べ替え sorted 指定したルールでソートした stream を返す。\n// 年齢の昇順 userList.stream() .sorted(Comparator.comparing(User::getAge)) .forEach(System.out::println); // name: John, age: 40 // name: George, age: 58 // name: Paul, age: 79 // name: Ringo, age: 81 // 年齢の降順 userList.stream() .sorted(Comparator.comparing(User::getAge).reversed()) .forEach(System.out::println); // name: Ringo, age: 81 // name: Paul, age: 79 // name: George, age: 58 // name: John, age: 40 条件判定 anyMatch // いずれかの要素が指定した条件を満たせば true boolean anyMatch = userList.stream() .anyMatch(u -\u0026gt; u.getAge() \u0026lt; 60); System.out.println(anyMatch); // true allMatch // 全ての要素が指定した条件を満たせば true boolean allMatch = userList.stream() .anyMatch(u -\u0026gt; u.getAge() \u0026lt; 60); System.out.println(allMatch); // false noneMatch // 全ての要素が指定した条件を満たさなければ true boolean noneMatch = userList.stream() .noneMatch(u -\u0026gt; u.getName().equals(\u0026#34;Pete\u0026#34;)); System.out.println(noneMatch); 先頭の要素を取得 findFirst Optional 型を返すので、orElse などが必要となる。\nUser user = userList.stream() .findFirst() .orElse(null); System.out.println(user); 集計 max // 年齢が最大のユーザ User maxAgeUser = userList.stream() .max(Comparator.comparing(User::getAge)) .orElse(null); System.out.println(maxAgeUser); // name: Ringo, age: 81 min // 年齢が最小のユーザ User minAgeUser = userList.stream() .min(Comparator.comparing(User::getAge)) .orElse(null); System.out.println(minAgeUser); // name: John, age: 40 count // 要素の個数 long count = userList.stream() .count(); System.out.println(count); // 4 average // 年齢の平均 double average = userList.stream() .mapToInt(User::getAge) .average() .orElse(0); System.out.println(average); // 64.5 sum // 年齢の合計 int sum = userList.stream() .mapToInt(User::getAge) .sum(); System.out.println(sum); // 258 値をまとめる reduce // 全員の名前をカンマ区切りで並べた文字列を取得 String result = userList.stream() .map(User::getName) .reduce((res, u) -\u0026gt; res += \u0026#34;, \u0026#34; + u) .orElse(\u0026#34;\u0026#34;); System.out.println(result); // John, Paul, George, Ringo ","permalink":"https://0x1feb.github.io/posts/2022/01/24/java-stream-memo/","summary":"Stream とは Java 8 から追加され、コレクションに対する集約操作をサポートした機能を持つ。 中間操作と終端操作を組み合わせてパイプラインにできるため、fo","title":"Java の Stream メモ"},{"content":"hello, world main() { printf(\u0026#34;hello, world\\n\u0026#34;); } ","permalink":"https://0x1feb.github.io/posts/2022/01/21/hello-world/","summary":"hello, world main() { printf(\u0026#34;hello, world\\n\u0026#34;); } ","title":"hello, world"}]