[{"content":"Stream とは Java 8 から追加され、コレクションに対する集約操作をサポートした機能を持つ。\n中間操作と終端操作を組み合わせてパイプラインにできるため、for 文による繰り返し処理を簡潔に記述できる。\nサンプルクラス User クラス 年齢と名前の情報のみを持つ、以下のユーザクラスを用いる。\npublic class User { private String name; private int age; public User(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String toString() { return \u0026#34;name: \u0026#34; + name + \u0026#34;, age: \u0026#34; + age; } } User のコレクション コレクションは以下とする。\nList\u0026lt;User\u0026gt; userList = new ArrayList\u0026lt;User\u0026gt;(); userList.add(new User(\u0026#34;John\u0026#34;, 40)); userList.add(new User(\u0026#34;Paul\u0026#34;, 79)); userList.add(new User(\u0026#34;George\u0026#34;, 58)); userList.add(new User(\u0026#34;Ringo\u0026#34;, 81)); 要素を順番に処理 forEach userList.stream() .forEach(u -\u0026gt; System.out.println(u)); // name: John, age: 40 // name: Paul, age: 79 // name: George, age: 58 // name: Ringo, age: 81  // 以下も同じ結果 userList.stream() .forEach(System.out::println); ラムダ式を受け取るが、別のメソッドをそのまま呼び出す場合、メソッドのみを渡すこともできる。\n順次/並列 stream ストリームは明示的に並列を指定しない限り、順次で実行される。\n// stream userList.stream() .forEach(System.out::println); // name: John, age: 40 // name: Paul, age: 79 // name: George, age: 58 // name: Ringo, age: 81 parallelStream 並列で実行する場合は、並列のストリームを生成する必要がある。\n// parallelStream userList.parallelStream() .forEach(System.out::println); // name: George, age: 58 // name: Ringo, age: 81 // name: John, age: 40 // name: Paul, age: 79 絞り込み filter 与えられたラムダ式が true となる要素から構成された stream を返す。\n// 60歳未満のみ出力 userList.stream() .filter(u -\u0026gt; u.getAge() \u0026lt; 60) .forEach(System.out::println); // name: John, age: 40 // name: George, age: 58 加工 map 与えられたラムダ式で加工した結果から構成される stream を返す。\n// \u0026#34;My name is XX\u0026#34; の文字列に加工して出力 userList.stream() .map(u -\u0026gt; \u0026#34;My name is\u0026#34; + u.getName()) .forEach(System.out::println); // My name isJohn // My name isPaul // My name isGeorge // My name isRingo スキップ skip 先頭から n 番目の要素を除いた stream を返す。\nuserList.stream() .skip(2) .forEach(System.out::println); // name: George, age: 58 // name: Ringo, age: 81 この例の場合、John と Paul の2人がスキップされている。\n要素数の制限 limit 指定した要素数の stream を返す。\nuserList.stream() .limit(2) .forEach(System.out::println); // name: John, age: 40 // name: Paul, age: 79 並べ替え sorted 指定したルールでソートした stream を返す。\n// 年齢の昇順 userList.stream() .sorted(Comparator.comparing(User::getAge)) .forEach(System.out::println); // name: John, age: 40 // name: George, age: 58 // name: Paul, age: 79 // name: Ringo, age: 81  // 年齢の降順 userList.stream() .sorted(Comparator.comparing(User::getAge).reversed()) .forEach(System.out::println); // name: Ringo, age: 81 // name: Paul, age: 79 // name: George, age: 58 // name: John, age: 40 条件判定 anyMatch // いずれかの要素が指定した条件を満たせば true boolean anyMatch = userList.stream() .anyMatch(u -\u0026gt; u.getAge() \u0026lt; 60); System.out.println(anyMatch); // true allMatch // 全ての要素が指定した条件を満たせば true boolean allMatch = userList.stream() .anyMatch(u -\u0026gt; u.getAge() \u0026lt; 60); System.out.println(allMatch); // false noneMatch // 全ての要素が指定した条件を満たさなければ true boolean noneMatch = userList.stream() .noneMatch(u -\u0026gt; u.getName().equals(\u0026#34;Pete\u0026#34;)); System.out.println(noneMatch); 先頭の要素を取得 findFirst Optional 型を返すので、orElse などが必要となる。\nUser user = userList.stream() .findFirst() .orElse(null); System.out.println(user); 集計 max // 年齢が最大のユーザ User maxAgeUser = userList.stream() .max(Comparator.comparing(User::getAge)) .orElse(null); System.out.println(maxAgeUser); // name: Ringo, age: 81 min // 年齢が最小のユーザ User minAgeUser = userList.stream() .min(Comparator.comparing(User::getAge)) .orElse(null); System.out.println(minAgeUser); // name: John, age: 40 count // 要素の個数 long count = userList.stream() .count(); System.out.println(count); // 4 average // 年齢の平均 double average = userList.stream() .mapToInt(User::getAge) .average() .orElse(0); System.out.println(average); // 64.5 sum // 年齢の合計 int sum = userList.stream() .mapToInt(User::getAge) .sum(); System.out.println(sum); // 258 値をまとめる reduce // 全員の名前をカンマ区切りで並べた文字列を取得 String result = userList.stream() .map(User::getName) .reduce((res, u) -\u0026gt; res += \u0026#34;, \u0026#34; + u) .orElse(\u0026#34;\u0026#34;); System.out.println(result); // John, Paul, George, Ringo ","permalink":"https://0x1feb.github.io/posts/2022/01/24/java-stream-memo/","summary":"Stream とは Java 8 から追加され、コレクションに対する集約操作をサポートした機能を持つ。 中間操作と終端操作を組み合わせてパイプラインにできるため、fo","title":"Java の Stream メモ"},{"content":"hello, world main() { printf(\u0026#34;hello, world\\n\u0026#34;); } ","permalink":"https://0x1feb.github.io/posts/2022/01/21/hello-world/","summary":"hello, world main() { printf(\u0026#34;hello, world\\n\u0026#34;); } ","title":"hello, world"}]