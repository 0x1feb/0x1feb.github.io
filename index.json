[{"content":"バケットソートとは、整列したいデータがとりうる値の数だけバケツを用意し、全ての要素をバケツに入れた後、順番に取り出すソートアルゴリズムである。\nソースコード #include \u0026lt;bits/stdc++.h\u0026gt;#define rep(i, n) for (int i = 0; i \u0026lt; (n); ++i) using namespace std; using vi = vector\u0026lt;int\u0026gt;; const int X = 1000000; void print_list(vi a, int n) { rep(i, n) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; (i \u0026lt; n - 1 ? \u0026#34; \u0026#34; : \u0026#34;\\n\u0026#34;); } void bucket_sort(vi \u0026amp;a, int n) { // 要素の値の個数を記録する  vi count(X); rep(i, n) count[a[i]]++; // 開始位置を記録する  vi offset(X); rep(num, X) offset[num] = (num == 0 ? count[num] : offset[num - 1] + count[num]); // ソート  vi b(n); rep(i, n) b[--offset[a[i]]] = a[i]; a = b; } int main() { int n; cin \u0026gt;\u0026gt; n; vi a(n); rep(i, n) cin \u0026gt;\u0026gt; a[i]; bucket_sort(a, n); print_list(a, n); return 0; } 実行した結果は以下のとおり。\n// 入力 8 2 1 3 7 1 6 2 5 // 出力 1 1 2 2 3 5 6 7 解説  配列 a の各要素の個数をカウントする。  $i$ 番目の要素の数は count[a[i]] 個となる。   開始位置を記録する。  offset[num] が num 以下の数の要素数となる。   ソート結果を配列 b に格納する。  $i$ 番目の要素の開始位置である --offset[a[i]] に a[i] を格納する。    計算量は $O(n^{2})$ となる。要素が $k$ 種類のとき、平均計算量は $O(n + k)$ となる。\n参考  バケットソート - Wikipedia  ","permalink":"https://0x1feb.github.io/posts/2023/02/16/backet-sort/","summary":"バケットソートとは、整列したいデータがとりうる値の数だけバケツを用意し、全ての要素をバケツに入れた後、順番に取り出すソートアルゴリズムである","title":"バケットソート (Bucket Sort)"},{"content":"前例に倣う 前例に倣うとは、何かに取り組むとき、これまでのやり方があるならば、それに倣った通りにやることである。仕事ではよくあることだが、過去に似たような例があれば、そのときやり方をそのまま流用することが推奨されたりする。\n以前、プログラミングで既存の共通処理を使ったら、その処理にバグが入っていたことに気づかず、リリース後に障害が発生してしまった。この対応をしているとき、既存の共通処理を使うことは、前例に倣うことと似ているなと感じた。前例に倣うことについて、自分なりに考えたことを整理しておく。\n利点 前例と新たな取り組みが似たようなものであった場合、前例に倣うことの利点は大きい。やり方を新たに考えるコストが省けるし、そのやり方を採用した場合の結果も予測できる。\n会社では、誰かの承認を得るときの根拠としても力を発揮する。「過去にこんなプロジェクトで採用されており、実績があります。」という説明は、何故か相手を納得させやすい。多くの人が、同じやり方で上手くいっている実績があるなら、今回も同じように上手くいくだろうと考えるからかもしれない。\nプログラミングでは、過去に作成された共通処理を使うことが、前例に倣うことに近いと思う。新たに作成するクラスで必要な処理が既存の共通クラスとして既に存在しているのであれば、共通クラスを呼び出すだけで良い。共通クラスとして使用される目的で作られているのであれば、既にテストされているであろうから、安心して使うことができるはずである。\n欠点 前例でのやり方が、新たな取り組みにおいては適していないこともある。新たにやり方を考えるべきときに前例に倣った場合、不適当なやり方を採用してしまう可能性がある。コストや効率が悪く、品質の悪い結果にも繋がる。\n会社では、非効率なやり方とわかっていながら、前例に倣ったやり方で進めることがある。誰かの承認を得なければ進められないような仕事がある場合、新たなやり方に対して拒否反応を示す人が多い。また、前例を変えると、失敗したときの責任を背負わなければならないと考える人も多いように思う。前例に倣って失敗した場合は、何故か前例が悪いから仕方ないといった具合に、責任が有耶無耶になる傾向がある気がする。\nプログラミングでは、共通処理として使えると思っていた部分にバグが入っていたりすると、面倒なことになる。新たに処理を作成するのではなく既存の共通処理を使う場合、その中身まで厳密に確認することは少ない。基本的にはテスト済みと考えるからである。実際に動かしてからバグが見つかると、修正するコストが追加で発生する。新たに処理を作成しなおすか、既存処理のバグを修正するしかないが、どちらにしても手戻りになる。既存処理を修正する場合、その処理を使っている全ての機能に影響しないかもテストする必要が出てくる。\n今時点で思うところ 何かに取り組むとき、基本的には前例を無視して、毎回新たに考えるのが良いのではないかと思っている。労力はかかるが、その時点の情報から新たに考える方が、最善のやり方になるはずだからである。新たに考えた結果、前例と同じやり方が選ばれるかもしれないが、常に新たに考えるという手順を踏んだかどうかが、大事なことなのではないかと思う。\nプログラミングにおいては、既存の処理を呼び出す場合、必ずテスト済みもしくはテストがあるかを確認すべきである。テストがないのであれば、既存処理のテストコードを新たに作成したり、既存処理を含めてテストできるようなテストコードを作ったりするべきである。テストコードのない昔の共通処理を使う場合などは、特に注意しなければならない。他の多くの処理から呼び出されていたとしても、テストされていないのであれば気軽に使えるものではないかもしれない。\n自分は楽な方へと惰性で進んでしまう傾向があるので、面倒だから前例のままでいいやと考えてしまいがちである。前例に倣うことは必ずしも悪いこととは思わないが、常に本当にそのやり方が最善なのかを考える習慣は持っておきたい。\n","permalink":"https://0x1feb.github.io/posts/2023/02/13/the-merits-and-demerits-of-following-precedent/","summary":"前例に倣う 前例に倣うとは、何かに取り組むとき、これまでのやり方があるならば、それに倣った通りにやることである。仕事ではよくあることだが、過去","title":"前例に倣うことの功罪"},{"content":"概要  正規表現の個人的メモである。 個人的に使いそうなもののみを取り上げているため、全てを網羅している訳ではない。 Visual Studio Code の検索で試した結果をもとにしている。  正規表現を使用するツールやプログラミング言語によっては結果が異なる可能性がある。    正規表現とは  文字列を表現するための方法である。 文字列の検索や置換などで使用される。  文字 メタ文字以外  メタ文字とは、正規表現用の記号として解釈される文字である。 メタ文字以外の文字は、そのままの1文字と一致する。 メタ文字を文字として表現するには、エスケープ文字を用いる。  以下の例だと、^ は行頭を意味するメタ文字として解釈される。 ^ という文字として表現するためにはエスケープする必要がある。       regexp example text match result     a abc cba a   0 012 890 0   ^ a^b no match    エスケープ文字  正規表現としての意味を持つ文字を本来の文字として使う場合、エスケープする必要がある。 エスケープする文字の前に \\ を付与することで、本来の文字として扱われる。 以下の例では、() をエスケープしない場合、正規表現のグルーピング記号として表現される。     regexp example text match result     \\(abc\\) (abc) (abc)   (abc) (abc) abc    任意の1文字 (.)  . は任意の1文字と一致する。 改行コードは含まれない。     regexp example text match result     .bc abc abc   a.c xa@cx a@c   1.4 1234 no match    数字の1文字 (\\d)  \\d は数字の1文字と一致する。     regexp example text match result     \\d@ 0@ 0@   \\d@ a@ no match    \\d 以外の1文字 (\\D)  \\D は \\d 以外の1文字と一致する。     regexp example text match result     \\D@ a@ a@   \\D@ 0@ no match    英数字 (_を含む) の1文字 (\\w)  \\w は英数字 (_を含む) の1文字と一致する。     regexp example text match result     \\w@ a@ a@   \\w@ 0@ 0@   \\w@ _@ _@   \\w@ -@ no match    \\w 以外の1文字 (\\W)  \\W は \\w 以外の1文字と一致する。     regexp example text match result     \\W@ -@ -@   \\W@ a@ no match   \\W@ 0@ no match   \\W@ _@ no match    空白の1文字 (\\s)  \\s は空白の1文字と一致する。     regexp example text match result     0\\s1 0 1 0 1   0\\s1 0　1 0　1   0\\s1 0_1 no match    \\s 以外の1文字 (\\S)  \\S は \\s 以外の1文字と一致する。     regexp example text match result     0\\S1 0_1 0_1   0\\S1 0 1 no match   0\\S1 0　1 no match    改行の1文字 (\\n)  \\n は改行コード1文字と一致する。  タブの1文字 (\\t)  \\t はタブ1文字と一致する。  アンカー 行頭 (^)  ^ は行頭と一致する。     regexp example text match result     ^abc abcdef abc   ^abc defabc no match    行末 ($)  $ は行末と一致する。     regexp example text match result     abc$ defabc abc   abc$ abcdef no match    先読み 肯定先読み ((?=\u0026hellip;))  (?=...) は、パターンが続く文字列を表現するが、マッチした結果の文字列には含めない。     regexp example text match result     abc(?=xyz) abcxyz abc   abc(?=xyz) abcdef no match    否定先読み ((?!\u0026hellip;))  (?!...) は、パターンが続かない文字列を表現するが、マッチした結果の文字列には含めない。     regexp example text match result     abc(?!xyz) abcdef abc   abc(?!xyz) abcxyz no match    後読み 肯定後読み ((?\u0026lt;=\u0026hellip;))  (?\u0026lt;=...) は、パターンが続く文字列を表現するが、マッチした結果の文字列には含めない。     regexp example text match result     (?\u0026lt;=abc)xyz abcxyz xyz   (?\u0026lt;=abc)xyz defxyz no match    否定後読み ((?\u0026lt;!\u0026hellip;))  (?\u0026lt;!...) は、パターンが続かない文字列を表現するが、マッチした結果の文字列には含めない。     regexp example text match result     (?\u0026lt;!abc)xyz abcxyz no match   (?\u0026lt;!abc)xyz defxyz xyz    量指定子 0回以上の繰り返し (*)  * は直前の文字を0回以上繰り返した文字と一致する。     regexp example text match result     a*bc bc bc   a*bc abc abc   a*bc aabc aabc   a*bc -bc bc    1回以上の繰り返し (+)  + は直前の文字を1回以上繰り返した文字と一致する。     regexp example text match result     a+bc abc abc   a+bc aabc aabc   a+bc bc no match   a+bc -bc no match    0回または1回の繰り返し (?)  ? は直前の文字を0回または1回繰り返した文字と一致する。     regexp example text match result     a?bc bc bc   a?bc abc abc   a?bc aabc abc   a?bc -bc bc    n回の繰り返し ({n})  {n} は直前の文字をn回繰り返した文字と一致する。     regexp example text match result     ab{0}c ac ac   ab{1}c abc abc   ab{2}c abbc abbc   ab{0}c abc no match   ab{1}c abbc no match   ab{2}c abbbc no match    n回以上m回以下の繰り返し ({n,m})  {n,m} は直前の文字をn回以上m回以下繰り返した文字と一致する。 {n,} は直前の文字をn回以上繰り返した文字と一致する。     regexp example text match result     ab{1,3}c abc abc   ab{1,3}c abbc abbc   ab{1,3}c abbbc abbbc   ab{1,3}c ac no match   ab{1,3}c abbbbc no match   ab{2}c abbc abbc   ab{2}c abbbc abbbc    集合と範囲 いずれかの1文字 ([\u0026hellip;])  [...] は [] 内のいずれかの1文字と一致する。     regexp example text match result     [a0]@ a@ a@   [a0]@ 0@ 0@   [a0]@ b@ no match   [a0]@ 1@ no match     [a-z] や [0-9] で連続する文字を短縮表記で表現することができる。     regexp example text match result     [a-d]@ c@ c@   [2-5]@ 3@ 3@    いずれかの1文字以外の1文字 ([^\u0026hellip;])  [^...] は [^] 内のいずれかの1文字と一致する。     regexp example text match result     [^a0]@ b@ b@   [^a0]@ 1@ 1@   [^a0]@ a@ not mtach   [^a0]@ 0@ not mtach    その他 AまたはB (A|B)  A|B は A または B の1文字と一致する。     regexp example text match result     a a a   a b b   a c no match    グルーピング ((\u0026hellip;))  (...) は () 内を1つのサブグループとして表現する。 () 内にマッチする文字列を個々に取り出すことができる。  VSCode では、n番目の () にマッチする文字列を $n で取り出せる。       regexp example text match result     (abc)(xyz) abcxyz abcxyz   (abc){2}(xyz) abcabcxyz abcabcxyz    ","permalink":"https://0x1feb.github.io/posts/2023/02/04/regular-expression/","summary":"概要 正規表現の個人的メモである。 個人的に使いそうなもののみを取り上げているため、全てを網羅している訳ではない。 Visual Studio Code の検索で試した結果をもと","title":"正規表現メモ"},{"content":"クイックソートとは、適当な数を基準として、小さい値と大きい値に分割することを繰り返すソートアルゴリズムである。\nソースコード #include \u0026lt;bits/stdc++.h\u0026gt;#define rep(i, n) for (int i = 0; i \u0026lt; (n); ++i) using namespace std; using vi = vector\u0026lt;int\u0026gt;; void print_list(vi A, int n) { rep(i, n) cout \u0026lt;\u0026lt; (i \u0026gt; 0 ? \u0026#34; \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; A[i]; cout \u0026lt;\u0026lt; endl; } void quick_sort(vi \u0026amp;A, int left, int right) { if (right - left \u0026lt;= 1) return; // 右端の値を pivot とする  int pivot = A[right - 1]; // pivot 未満となる要素の右端となる添え字  int i = left; // pivot を基準として、pivot 未満の値が左側になるよう交換  for (int j = left; j \u0026lt; right - 1; j++) { if (A[j] \u0026lt; pivot) swap(A[i++], A[j]); } // pivot を適切な位置に挿入  swap(A[i], A[right - 1]); // pivot の左側を再帰的にソート  quick_sort(A, left, i); // pivot の右側を再帰的にソート  quick_sort(A, i + 1, right); } int main() { int n; cin \u0026gt;\u0026gt; n; vi A(n); rep(i, n) cin \u0026gt;\u0026gt; A[i]; quick_sort(A, 0, n); print_list(A, n); return 0; } 実行した結果は以下のとおり。\n// 入力 8 8 4 3 7 1 6 2 5 // 出力 1 2 3 4 5 6 7 8 解説  初期データを [8, 4, 3, 7, 1, 6, 2, 5] とする。 右端の値である 5 を pivot とし、5 未満の値が左側、5 以上の値が右側になるよう整理する。  4 と 8 を交換  [4, 8, 3, 7, 1, 6, 2, 5]   3 と 8 を交換  [4, 3, 8, 7, 1, 6, 2, 5]   1 と 8 を交換  [4, 3, 1, 7, 8, 6, 2, 5]   2 と 7 を交換  [4, 3, 1, 2, 8, 6, 7, 5]   pivot である 5 を適切な位置に挿入  [4, 3, 1, 2, 5, 6, 7, 8]     分割した左半分 [4, 3, 1, 2] と右半分 [5, 6, 7, 8] の要素について、再帰的に同じ処理を繰り返す。  pivot の選択に毎回最大値か最小値が選ばれる場合、最悪の計算量は $O(n^{2})$ となる。pivot が左右均等に分割できる場合、平均計算量は $O(n \\log{n})$ となる。\n参考  クイックソート - Wikipedia  ","permalink":"https://0x1feb.github.io/posts/2023/01/12/quick-sort/","summary":"クイックソートとは、適当な数を基準として、小さい値と大きい値に分割することを繰り返すソートアルゴリズムである。 ソースコード #include \u0026lt;bits/stdc++.h\u0026gt;#define rep(i, n) for (int i = 0;","title":"クイックソート (Quick Sort)"},{"content":"マージソートとは、配列を分割し、分割された各配列の要素をソートしてマージするソートアルゴリズムである。\nソースコード #include \u0026lt;bits/stdc++.h\u0026gt;#define rep(i, n) for (int i = 0; i \u0026lt; (n); ++i) using namespace std; using vi = vector\u0026lt;int\u0026gt;; void print_list(vi A, int n) { rep(i, n) cout \u0026lt;\u0026lt; (i \u0026gt; 0 ? \u0026#34; \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; A[i]; cout \u0026lt;\u0026lt; endl; } void merge_sort(vi \u0026amp;A, int left, int right) { if (right - left == 1) return; int mid = (left + right) / 2; // 左半分をソート  merge_sort(A, left, mid); // 右半分をソート  merge_sort(A, mid, right); // 左半分と右半分のソート結果をコピー（右は逆順）  vi buf; for (int i = left; i \u0026lt; mid; i++) buf.push_back(A[i]); for (int i = right - 1; i \u0026gt;= mid; i--) buf.push_back(A[i]); // 左半分と右半分の要素から小さい順に要素を取り出してマージ  int left_i = 0; int right_i = buf.size() - 1; for (int i = left; i \u0026lt; right; i++) { A[i] = buf[left_i] \u0026lt;= buf[right_i] ? buf[left_i++] : buf[right_i--]; } } int main() { int n; cin \u0026gt;\u0026gt; n; vi A(n); rep(i, n) cin \u0026gt;\u0026gt; A[i]; merge_sort(A, 0, n); print_list(A, n); return 0; } 実行した結果は以下のとおり。\n// 入力 8 8 4 3 7 6 5 2 1 // 出力 1 2 3 4 5 6 7 8 解説  初期データを [8, 4, 3, 7, 6, 5, 2, 1] とする。 分割できなくなるまで（分割した要素数が1になるまで）再帰的に分割する。  [8, 4, 3, 7], [6, 5, 2, 1] [8, 4], [3, 7], [6, 5], [2, 1] [8], [4], [3], [7], [6], [5], [2], [1]   分割した左半分と右半分の要素から、小さい順に要素を取り出してマージする。  [4, 8], [7, 3], [5, 6], [1, 2] [3, 4, 7, 8], [1, 2, 5, 6] [1, 2, 3, 4, 5, 6, 7, 8]    分割するときの計算量は $O(\\log{n})$ であり、マージするときの計算量は $O(n)$ となるので、マージソートの計算量は $O(n \\log{n})$ となる。\n参考  マージソート - Wikipedia  ","permalink":"https://0x1feb.github.io/posts/2023/01/06/merge-sort/","summary":"マージソートとは、配列を分割し、分割された各配列の要素をソートしてマージするソートアルゴリズムである。 ソースコード #include \u0026lt;bits/stdc++.h\u0026gt;#define rep(i, n) for (int i = 0; i \u0026lt; (n); ++i)","title":"マージソート (Merge Sort)"},{"content":"注意点 過去のコミットを修正すると、修正したコミット以降のハッシュ値が変わる。そのため、GitHub 等のリモートリポジトリに push するときは、push -f とする必要がある。これは強制的に上書きする行為なので、複数人で管理しているときなどは注意すること。\n初期状態 以下のファイルを上から順番にコミットしたとする。\n hello morning night  $ ls hello morning night $ cat hello hallo, world! $ cat morning god morning! $ cat night good night $ git log --oneline 564bd9c (HEAD -\u0026gt; main) Add night 97e326f Add morning b739670 first commit 直前のコミットを修正 直前のコミットを修正したい場合は、commit コマンドに --amend オプションを付ける。\n以下の例では、night ファイルに sweet dreams というメッセージを追加し、コミットメッセージも変更している。\n$ echo \u0026#39;sweet dreams\u0026#39; \u0026gt;\u0026gt; night $ git diff diff --git a/night b/night index d55621b..461a258 100644 --- a/night +++ b/night @@ -1 +1,2 @@ good night +sweet dreams $ git add night $ git commit --amend -m \u0026#34;Add night messages\u0026#34; [main a8e822b] Add night messages Date: Fri Apr 16 01:13:50 2021 +0900 1 file changed, 2 insertions(+) create mode 100644 night $ git log --oneline a8e822b (HEAD -\u0026gt; main) Add night messages 97e326f Add morning b739670 first commit 2つ以上前のコミットを修正 2つ前にコミットした morning ファイルの内容が god morning になっているので good morning に修正する。\ncommit --amend は直前のコミットにしか使えないので、rebase コマンドを用いる。\ngit log でコミットログを出力し、修正したいコミットの1つ前のコミットを指定して rebase を実行する。\n$ git log --oneline a8e822b (HEAD -\u0026gt; main) Add night messages 97e326f Add morning b739670 first commit $ git rebase -i b739670 Stopped at 97e326f... Add morning You can amend the commit now, with git commit --amend Once you are satisfied with your changes, run git rebase --continue 以下のファイルが開かれるので、修正したいコミットの pick を edit に変更して保存する。\n- pick 97e326f Add morning + edit 97e326f Add morning pick a8e822b Add night messages # Rebase b739670..a8e822b onto b739670 (2 commands) # # Commands: # p, pick \u0026lt;commit\u0026gt; = use commit # r, reword \u0026lt;commit\u0026gt; = use commit, but edit the commit message # e, edit \u0026lt;commit\u0026gt; = use commit, but stop for amending # s, squash \u0026lt;commit\u0026gt; = use commit, but meld into previous commit # f, fixup \u0026lt;commit\u0026gt; = like \u0026#34;squash\u0026#34;, but discard this commit\u0026#39;s log message # x, exec \u0026lt;command\u0026gt; = run command (the rest of the line) using shell # b, break = stop here (continue rebase later with \u0026#39;git rebase --continue\u0026#39;) # d, drop \u0026lt;commit\u0026gt; = remove commit # l, label \u0026lt;label\u0026gt; = label current HEAD with a name # t, reset \u0026lt;label\u0026gt; = reset HEAD to a label # m, merge [-C \u0026lt;commit\u0026gt; | -c \u0026lt;commit\u0026gt;] \u0026lt;label\u0026gt; [# \u0026lt;oneline\u0026gt;] # . create a merge commit using the original merge commit\u0026#39;s # . message (or the oneline, if no original merge commit was # . specified). Use -c \u0026lt;commit\u0026gt; to reword the commit message. # # These lines can be re-ordered; they are executed from top to bottom. # # If you remove a line here THAT COMMIT WILL BE LOST. # # However, if you remove everything, the rebase will be aborted. # # Note that empty commits are commented out ファイルを閉じると、修正したいコミットをした直後の状態になる。\n$ git log --oneline 97e326f (HEAD) Add morning b739670 first commit あとは直前のコミットを修正するのと同じように修正する。\n$ git diff diff --git a/morning b/morning index c94a8fd..527cb14 100644 --- a/morning +++ b/morning @@ -1 +1 @@ -god morning! +good morning! $ git add morning $ git commit --amend -m \u0026#34;Add morning\u0026#34; [detached HEAD 4667fe5] Add morning Date: Fri Apr 16 01:12:51 2021 +0900 1 file changed, 1 insertion(+) create mode 100644 morning $ git status interactive rebase in progress; onto b739670 Last command done (1 command done): edit 97e326f Add morning Next command to do (1 remaining command): pick a8e822b Add night messages (use \u0026#34;git rebase --edit-todo\u0026#34; to view and edit) You are currently editing a commit while rebasing branch \u0026#39;main\u0026#39; on \u0026#39;b739670\u0026#39;. (use \u0026#34;git commit --amend\u0026#34; to amend the current commit) (use \u0026#34;git rebase --continue\u0026#34; once you are satisfied with your changes) nothing to commit, working tree clean このコミット以外は修正しないので、以下コマンドで最新コミットまで進める。\n$ git rebase --continue Successfully rebased and updated refs/heads/main. $ git status On branch main nothing to commit, working tree clean $ git log --oneline 63c4c92 (HEAD -\u0026gt; main) Add night messages 4667fe5 Add morning b739670 first commit 初回コミットを修正 初回にコミットした hello ファイルの内容を hallo world! から hello, world! に修正する。\nしかし、rebase -i では初回コミットの前のコミットハッシュを指定することができない。\nこの場合は、rebase -i --root とすると、初回コミットを修正することができる。\n$ git rebase -i --root Stopped at b739670... first commit You can amend the commit now, with git commit --amend Once you are satisfied with your changes, run git rebase --continue 初回コミットを edit に変更し、保存して閉じる。\n- pick b739670 first commit + edit b739670 first commit pick 4667fe5 Add morning pick 63c4c92 Add night messages 初回コミット直後の状態になるので、先ほどと同じような手順で修正を反映する。\n$ git diff diff --git a/hello b/hello index 7ed9b8c..270c611 100644 --- a/hello +++ b/hello @@ -1 +1 @@ -hallo, world! +hello, world! $ git add hello $ git commit --amend -m \u0026#34;Add hello\u0026#34; [detached HEAD 2390055] Add hello Date: Fri Apr 16 01:11:31 2021 +0900 1 file changed, 1 insertion(+) create mode 100644 hello $ git status interactive rebase in progress; onto dc37feb Last command done (1 command done): edit b739670 first commit Next commands to do (2 remaining commands): pick 4667fe5 Add morning pick 63c4c92 Add night messages (use \u0026#34;git rebase --edit-todo\u0026#34; to view and edit) You are currently editing a commit while rebasing branch \u0026#39;main\u0026#39; on \u0026#39;dc37feb\u0026#39;. (use \u0026#34;git commit --amend\u0026#34; to amend the current commit) (use \u0026#34;git rebase --continue\u0026#34; once you are satisfied with your changes) nothing to commit, working tree clean $ git rebase --continue Successfully rebased and updated refs/heads/main. $ git log --oneline 078325e (HEAD -\u0026gt; main) Add night messages f56e0d9 Add morning 2390055 Add hello ","permalink":"https://0x1feb.github.io/posts/2023/01/05/modifying-past-commit/","summary":"注意点 過去のコミットを修正すると、修正したコミット以降のハッシュ値が変わる。そのため、GitHub 等のリモートリポジトリに push するときは、pu","title":"Git における過去コミットの修正"},{"content":"ソースコード バブルソートとは、順番が逆になっている隣接要素がなくなるまで大小を比較し交換するソートアルゴリズムである。\n#include \u0026lt;bits/stdc++.h\u0026gt;#define rep(i, n) for (int i = 0; i \u0026lt; (n); ++i) using namespace std; using vi = vector\u0026lt;int\u0026gt;; void print_list(vi A, int n) { rep(i, n) cout \u0026lt;\u0026lt; (i \u0026gt; 0 ? \u0026#34; \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; A[i]; cout \u0026lt;\u0026lt; endl; } void bubble_sort(vi \u0026amp;A, int n) { // 外側のループが1週すると、配列の最後からi番目の数が確定する  rep(i, n - 1) { // 未確定部分について、隣同士を比較して入れ替えていく  rep(j, n - 1 - i) { if (A[j] \u0026gt; A[j + 1]) swap(A[j], A[j + 1]); } print_list(A, n); } } int main() { int n; cin \u0026gt;\u0026gt; n; vi A(n); rep(i, n) cin \u0026gt;\u0026gt; A[i]; bubble_sort(A, n); return 0; } 実行した結果は以下のとおり。\n// 入力 8 8 4 3 7 6 5 2 1 // 出力 4 3 7 6 5 2 1 8 (1回目の外側ループ終了時) 3 4 6 5 2 1 7 8 (2回目の外側ループ終了時) 3 4 5 2 1 6 7 8 (3回目の外側ループ終了時) 3 4 2 1 5 6 7 8 (4回目の外側ループ終了時) 3 2 1 4 5 6 7 8 (5回目の外側ループ終了時) 2 1 3 4 5 6 7 8 (6回目の外側ループ終了時) 1 2 3 4 5 6 7 8 (7回目の外側ループ終了時) 解説  外側のループ変数 $i$ で整列済み部分の先頭インデックスをカウントする。 内側のループ変数 $j$ で先頭から未整列部分の末尾まで $[0, n-1-i)$ のインデックスをカウントする。 内側のループで隣同士を比較し、順序が逆なら入れ替える。 上記操作を繰り返すと、配列全体が整列する。  最悪の場合の比較回数は $(n-1) + (n-2) + \\cdots + 1 = (n^2-n)/2$ となるため、計算量は $O(n^{2})$ となる。\n参考  バブルソート - Wikipedia  ","permalink":"https://0x1feb.github.io/posts/2023/01/04/bubble-sort/","summary":"ソースコード バブルソートとは、順番が逆になっている隣接要素がなくなるまで大小を比較し交換するソートアルゴリズムである。 #include \u0026lt;bits/stdc++.h\u0026gt;#define rep(i, n) for (int i = 0; i \u0026lt;","title":"バブルソート (Bubble sort)"},{"content":"概要 Android アプリを作ってみたくなったので、チュートリアルを試してみた結果をメモとして残す。\n準備  Kotlin の基礎知識があること。 Android Studio がインストールされていること。 実機でアプリを動かす場合は確認用の Android 端末があること。  サンプルアプリの作成 テンプレートからプロジェクトを作成する  Android Studio を起動し、[New Project] をクリックする。 [Phone and Tablet] を選択し、[Empty Compose Activity] を選択する。 [Next] をクリックする。 以下を入力する。  Name: GreetingCard Package name: com.example.greetingcard Save location: 任意のパス Language: Kotlin (固定) Minimum SDK: API 21: Android 5.0 (Lollipop)   [Finish] をクリックする。  読み込みが終わるまで時間がかかるのでしばらく待つと、テンプレートを使用したプロジェクトが作成される。\nテキスト/デザインを更新する   MainActivity.kt の Greeting() を次のように変更する。\n@Composable fun Greeting(name: String) { Text(text = \u0026#34;Hi, my name is $name!\u0026#34;) }   Greeting() を呼び出すときの引数を任意の名前に変更する。\nGreeting(\u0026#34;rano\u0026#34;)   Text... の行をハイライト表示し、Alt + Enter を押して、[Surround with widget] を選択する。\n@Composable fun Greeting(name: String) { Box { Text(text = \u0026#34;Hi, my name is $name!\u0026#34;) } }   Box を Surface() に変更する。\n@Composable fun Greeting(name: String) { Surface() { Text(text = \u0026#34;Hi, my name is $name!\u0026#34;) } }   color パラメータを追加する。（ここでは青を指定）\n... import androidx.compose.ui.graphics.Color ... @Composable fun Greeting(name: String) { Surface(color = Color.Blue) { Text(text = \u0026#34;Hi, my name is $name!\u0026#34;) } }   パディングを追加する。\n... import androidx.compose.foundation.layout.padding ... import androidx.compose.ui.unit.dp ... @Composable fun Greeting(name: String) { Surface(color = Color.Blue) { Text(text = \u0026#34;Hi, my name is $name!\u0026#34;, modifier = Modifier.padding(24.dp)) } }   以上で簡単なカスタマイズが完了した。\n実機での動作確認 開発用デバイスをセットアップする デバイスとの接続は、USB 接続と Wi-Fi 接続の2種類あるが、今回は Wi-Fi 経由で接続する。\n デバイスの設定アプリより、[開発者向けオプション] を選択し、[ワイヤレス デバッグ] を有効にする。  デバイスの開発者向けオプションを設定する ｜ Android デベロッパー ｜ Android Developers    デバイスに接続する  実行構成のプルダウンメニューから [Pair Devices Using Wi-Fi] を選択する。 デバイスの設定アプリより、[開発者向けオプション] を選択し、[ワイヤレス デバッグ] を選択する。 [QR コードによるデバイスのペア設定] を選択し、QR コードを読み取る。 ペアリングしたら対象のデバイスを選択し、[Run \u0026lsquo;app\u0026rsquo;] のアイコンをクリックする。 実機端末にサンプルアプリが表示される。  基本はエミュレータでの確認で問題ないと思うが、実際の操作感を確認したい場合は実機を使うのが良い。\n参考  初めてのアプリを作成する ｜ Android デベロッパー ｜ Android Developers ハードウェア デバイス上でのアプリの実行 ｜ Android デベロッパー ｜ Android Developers  ","permalink":"https://0x1feb.github.io/posts/2023/01/03/basic-android-kotlin-compose-first-app/","summary":"概要 Android アプリを作ってみたくなったので、チュートリアルを試してみた結果をメモとして残す。 準備 Kotlin の基礎知識があること。 Android Studio がインストールされてい","title":"Android アプリ入門"},{"content":"挿入ソートとは、未ソートの部分から取り出した要素を、ソート済みの部分の適切な位置に挿入するソートアルゴリズムである。\nソースコード #include \u0026lt;bits/stdc++.h\u0026gt;#define rep(i, n) for (int i = 0; i \u0026lt; (n); ++i) using namespace std; using vi = vector\u0026lt;int\u0026gt;; void print_list(vi A, int n) { rep(i, n) cout \u0026lt;\u0026lt; (i \u0026gt; 0 ? \u0026#34; \u0026#34; : \u0026#34;\u0026#34;) \u0026lt;\u0026lt; A[i]; cout \u0026lt;\u0026lt; endl; } void insertion_sort(vi \u0026amp;A, int n) { rep(i, n - 1) { // i番目までソート済み  // i+1番目の要素を挿入対象とする  int tmp = A[i + 1]; // 整列済みの要素 (A[j], A[j-1], ..., A[0]) の中で適切な挿入位置を探す  int j = i; while (j \u0026gt;= 0 \u0026amp;\u0026amp; A[j] \u0026gt; tmp) { A[j + 1] = A[j]; j--; } A[j + 1] = tmp; print_list(A, n); } } int main() { int n; cin \u0026gt;\u0026gt; n; vi A(n); rep(i, n) cin \u0026gt;\u0026gt; A[i]; insertion_sort(A, n); return 0; } 実行した結果は以下のとおり。\n// 入力 8 8 4 3 7 6 5 2 1 // 出力 4 8 3 7 6 5 2 1 (1回目のループ終了時) 3 4 8 7 6 5 2 1 (2回目のループ終了時) 3 4 7 8 6 5 2 1 (3回目のループ終了時) 3 4 6 7 8 5 2 1 (4回目のループ終了時) 3 4 5 6 7 8 2 1 (5回目のループ終了時) 2 3 4 5 6 7 8 1 (6回目のループ終了時) 1 2 3 4 5 6 7 8 (7回目のループ終了時) 解説 以下の操作を繰り返すことでソートする。\n 0番目の要素を整列済みの配列とし、1番目の要素を適切な位置に挿入する。 0番目と1番目までの配列は整列済みなので、2番目の要素を適切な位置に挿入する。 上記操作を配列の最後の要素まで繰り返すと、配列全体が整列する。  挿入対象となる値は tmp に格納し、適切な位置が見つかるまで A[j + 1] = A[j] で整列済みの配列の要素を後ろにずらす。\nループの条件を抜けたときの j + 1 が挿入位置となるため、A[j + 1] = tmp で挿入する。\n最悪の場合、 $i$ ループの各処理が $i$ 回行われるため、計算量は $O(n^{2})$ となる。\n参考  挿入ソート - Wikipedia  ","permalink":"https://0x1feb.github.io/posts/2022/12/29/insertion-sort/","summary":"挿入ソートとは、未ソートの部分から取り出した要素を、ソート済みの部分の適切な位置に挿入するソートアルゴリズムである。 ソースコード #include \u0026lt;bits/stdc++.h\u0026gt;#define rep(i, n) for (int","title":"挿入ソート (Insertion sort)"},{"content":"ユークリッドの互除法とは、2つの自然数の最大公約数を求めるアルゴリズムである。\nソースコード #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int gcd(int a, int b) { return (b == 0 ? a : gcd(b, a % b)); } int main() { cout \u0026lt;\u0026lt; gcd(1071, 1029) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; gcd(1029, 1071) \u0026lt;\u0026lt; endl; return 0; } 出力結果は以下の通り。\n21 21 参考  ユークリッドの互除法 - Wikipedia - Wikipedia  ","permalink":"https://0x1feb.github.io/posts/2022/12/27/euclidean-algorithm/","summary":"ユークリッドの互除法とは、2つの自然数の最大公約数を求めるアルゴリズムである。 ソースコード #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int gcd(int a, int b) { return (b == 0 ? a : gcd(b, a % b)); } int main() {","title":"最大公約数 (ユークリッドの互除法)"},{"content":"二分探索とは、ソート済みの配列について、探索範囲を半分に絞り込む操作を繰り返す検索アルゴリズムである。\nたとえば、素数の配列が与えられているとき、指定した数よりも小さい数のうち最大となる数を調べる。\nソースコード #include \u0026lt;bits/stdc++.h\u0026gt;#define rep(i, n) for (int i = 0; i \u0026lt; (n); ++i) #define srep(i, s, t) for (int i = s; i \u0026lt; t; ++i) using namespace std; using vi = vector\u0026lt;int\u0026gt;; vi sieve_of_eratosthenes(int n) { vector\u0026lt;bool\u0026gt; is_prime(n + 1); srep(i, 2, n + 1) is_prime[i] = true; vi primes; rep(i, n + 1) { if (is_prime[i]) { primes.push_back(i); for (int j = i * i; j \u0026lt;= n; j += i) is_prime[j] = false; } } return primes; } bool solve(int a, int x) { // 判定条件  return a \u0026lt; x; } int binary_search(vi list, int x) { int ok = -1; // 条件を満たす最大の位置  int ng = list.size(); // 条件を満たさない最小の位置  while (abs(ok - ng) \u0026gt; 1) { int mid = (ok + ng) / 2; if (solve(list[mid], x)) { // 条件を満たす場合 ok の位置を拡張する  ok = mid; } else { // 条件を満たさない場合 ng の位置を拡張する  ng = mid; } } return ok; } void print_info(vi list, int i) { cout \u0026lt;\u0026lt; \u0026#34;index: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;number: \u0026#34;; if (i == -1) { cout \u0026lt;\u0026lt; \u0026#34;not found\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; list[i] \u0026lt;\u0026lt; endl; } } int main() { // 100までの素数の配列  // 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97  vi primes = sieve_of_eratosthenes(100); cout \u0026lt;\u0026lt; \u0026#34;29より小さい数のうち最大となる素数\u0026#34; \u0026lt;\u0026lt; endl; print_info(primes, binary_search(primes, 29)); cout \u0026lt;\u0026lt; \u0026#34;30より小さい数のうち最大となる素数\u0026#34; \u0026lt;\u0026lt; endl; print_info(primes, binary_search(primes, 30)); cout \u0026lt;\u0026lt; \u0026#34;2より小さい数のうち最大となる素数\u0026#34; \u0026lt;\u0026lt; endl; print_info(primes, binary_search(primes, 2)) return 0; } 出力結果は以下の通り。\n29より小さい数のうち最大となる素数 index: 8 number: 23 30より小さい数のうち最大となる素数 index: 9 number: 29 2より小さい数のうち最大となる素数 index: -1 number: not found 解説 探索する配列はソート済みである必要がある。\n ok と ng は配列の添え字の下限-1と上限+1で初期化する。  ok: 条件を満たす最大の位置（初期値-1を除く） ng: 条件を満たさない最小の位置   中央値 mid が条件を満たすかを判定する。  true: ok の位置を mid まで拡張 false: ng の位置を mid まで拡張   ok と ng が隣同士になったとき、探索を終了する。 探索終了時点の ok の位置が、条件を満たす最大の値となる。  条件を満たす値が1つもない場合、ok の値は初期値のままで -1 となることに注意    $n$ 個のデータがある場合の計算量は $O(\\log n)$ となる。\n参考  https://twitter.com/meguru_comp/status/697008509376835584  ","permalink":"https://0x1feb.github.io/posts/2022/12/25/binary-search/","summary":"二分探索とは、ソート済みの配列について、探索範囲を半分に絞り込む操作を繰り返す検索アルゴリズムである。 たとえば、素数の配列が与えられていると","title":"二分探索 (binary search)"},{"content":"ナップサック問題とは、 $n$ 種類の品物（価値 $v$ , 重量 $w$ ）のうちいくつかを選び、ナップサックに収まる範囲で品物の価値の合計が最大になる選び方を求める問題である。\n様々な解き方があるが、動的計画法で解いてみる。（問題は D - Knapsack 1）\nソースコード #include \u0026lt;bits/stdc++.h\u0026gt;#define rep(i, n) for (int i = 0; i \u0026lt; (n); ++i) #define maxs(x, y) (x = max(x, y)) using namespace std; using ll = long long; using vl = vector\u0026lt;ll\u0026gt;; using vvl = vector\u0026lt;vl\u0026gt;; int main() { int N, W; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; W; vl weight(N), value(N); rep(i, N) cin \u0026gt;\u0026gt; weight[i] \u0026gt;\u0026gt; value[i]; vvl dp(N + 1, vl(W + 1, 0)); rep(i, N) rep(w, W + 1) { // i個目の品物を選ぶ場合  if (w \u0026gt;= weight[i]) maxs(dp[i + 1][w], dp[i][w - weight[i]] + value[i]); // i個目の品物を選ばない場合  maxs(dp[i + 1][w], dp[i][w]); } cout \u0026lt;\u0026lt; dp[N][W] \u0026lt;\u0026lt; endl; return 0; } 解説 dp[i][w] には、最初の $i$ 個の品物の中から重さの合計が $w$ 以下になるよう選んだときの価値の合計の最大値を格納する。\n$i$ 個目の品物を選ぶ場合は、選ぶ前の状態 dp[i][w - weight[i]] に $i$ 個目の品物の価値 value[i] を追加した値を格納する。（ナップサックの容量を超えてはならないため、w \u0026gt;= weight[i] の条件が必要となる。）\nmaxs(dp[i + 1][w], dp[i][w - weight[i]] + value[i])\n$i$ 個目の品物を選ばない場合は、選ぶ前の状態 dp[i][w] と何の変化もないため、そのままの値を格納する。\nmaxs(dp[i + 1][w], dp[i][w]);\nちなみに、 $i = 0$ のときは品物を1つも選ばないので、すべての $w$ について価値の合計の最大値は0となる。また、任意の $i$ について、$w = 0$ のときは品物を1つも入れることができないので、価値の合計の最大値は0となる。\n参考  ナップサック問題 - Wikipedia D - Knapsack 1  ","permalink":"https://0x1feb.github.io/posts/2022/12/21/knapsack-dp/","summary":"ナップサック問題とは、 $n$ 種類の品物（価値 $v$ , 重量 $w$ ）のうちいくつかを選び、ナップサックに収まる範囲で品物の価値の合計が最大になる選び方を求め","title":"ナップサック問題 (動的計画法)"},{"content":"エラトステネスの篩とは、指定した数以下の素数を探すアルゴリズムである。\n指定した数までの数列を用意し、素数を見つけたらその素数の倍数を篩い落としていくことで、素数のみの数列が残るという仕組みである。\nソースコード #include \u0026lt;bits/stdc++.h\u0026gt;#define rep(i, n) for (int i = 0; i \u0026lt; (n); ++i) #define srep(i, s, t) for (int i = s; i \u0026lt; t; ++i) using namespace std; using vi = vector\u0026lt;int\u0026gt;; vi sieve_of_eratosthenes(int n) { vector\u0026lt;bool\u0026gt; is_prime(n + 1); // 添え字の数が素数か判定した結果を持つ配列  // 0, 1 は素数ではないので false のまま初期化する  srep(i, 2, n + 1) is_prime[i] = true; vi primes; // 素数を格納する配列  rep(i, n + 1) { if (is_prime[i]) { primes.push_back(i); // 素数iについて、i^2以上のiの倍数を篩い落とすため false にする  for (int j = i * i; j \u0026lt;= n; j += i) is_prime[j] = false; } } return primes; } int main() { vi primes = sieve_of_eratosthenes(100); for (int p : primes) cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; return 0; } 100までの素数を出力した結果は以下の通り。\n2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 参考  エラトステネスの篩 - Wikipedia  ","permalink":"https://0x1feb.github.io/posts/2022/12/20/sieve-of-eratosthenes/","summary":"エラトステネスの篩とは、指定した数以下の素数を探すアルゴリズムである。 指定した数までの数列を用意し、素数を見つけたらその素数の倍数を篩い落と","title":"素数列挙 (エラトステネスの篩)"},{"content":"2のべき乗で求められる組み合わせを全探索する方法として、bit 全探索という方法がある。\n例えば、 $n$ 人が「立っている」または「座っている」のどちらかの状態で行列に並んでいるとする。このとき、考えられる行列の並び方を全て列挙する場合に使える。\nソースコード #include \u0026lt;bits/stdc++.h\u0026gt;#define rep(i, n) for (int i = 0; i \u0026lt; (n); ++i) using namespace std; void bit_full_search(int n) { rep(i, 1 \u0026lt;\u0026lt; n) { rep(j, n) { if (i \u0026amp; (1 \u0026lt;\u0026lt; j)) { cout \u0026lt;\u0026lt; \u0026#34;1\u0026#34;; // 1のときの処理  } else { cout \u0026lt;\u0026lt; \u0026#34;0\u0026#34;; // 0のときの処理  } } cout \u0026lt;\u0026lt; endl; } } int main() { bit_full_search(4); return 0; } n = 4 のときの出力結果は以下の通り。先ほどの例えで考えると、立っている状態を0、座っている状態を1とすれば、ありうる行列の組み合わせが全て出力されていることになる。\n0000 1000 0100 1100 0010 1010 0110 1110 0001 1001 0101 1101 0011 1011 0111 1111 解説 数値同士の論理積は、2進数の各位のビットを比較し、両方が1のときのみ1となる。\n#include \u0026lt;bits/stdc++.h\u0026gt;#define rep(i, n) for (int i = 0; i \u0026lt; (n); ++i) using namespace std; void printAndValue(int x, int y) { cout \u0026lt;\u0026lt; bitset\u0026lt;8\u0026gt;(x) \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; bitset\u0026lt;8\u0026gt;(y) \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; bitset\u0026lt;8\u0026gt;(x \u0026amp; y) \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026amp; \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; } int main() { printAndValue(42, 121); return 0; } 00101010 = 42 01111001 = 121 00101000 = 42 \u0026amp; 121 上記の例の場合、42と121を2進数で表したとき、右から4桁目と6桁目はどちらも1であるから、42と121の論理積は 00101000 となる。\nまた、1 \u0026lt;\u0026lt; n で 00000001 を n ビット左シフトした値を得ることができる。\n#include \u0026lt;bits/stdc++.h\u0026gt;#define rep(i, n) for (int i = 0; i \u0026lt; (n); ++i) using namespace std; void printLeftShiftValue(int n) { rep(i, n) { int num = 1 \u0026lt;\u0026lt; i; bitset\u0026lt;8\u0026gt; bit_num(num); cout \u0026lt;\u0026lt; \u0026#34;bit: \u0026#34; \u0026lt;\u0026lt; bit_num \u0026lt;\u0026lt; \u0026#34;, num: \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; } } int main() { printLeftShiftValue(8); return 0; } 1を0ビットから7ビットまで左シフトした出力結果は以下の通り。\nbit: 00000001, num: 1 bit: 00000010, num: 2 bit: 00000100, num: 4 bit: 00001000, num: 8 bit: 00010000, num: 16 bit: 00100000, num: 32 bit: 01000000, num: 64 bit: 10000000, num: 128 ある数iについて、上記の数との論理積をとれば、任意の位が0か1かを判定することができる。\nbitFullSearch() ではこの性質を組み合わせることで、全探索を実現している。\n 外側のループで $0$ から $2^{n-1}$ までの数値 $i$ を作る。 各 $i$ について、 $2^{0}$ から $2^{n-1}$ 乗までの数値 (1 \u0026lt;\u0026lt; j) との論理積をとる。 論理積 (i \u0026amp; (1 \u0026lt;\u0026lt; j)) の値が $0$ となれば $j+1$ 桁目は $0$ であり、それ以外なら $1$ となる。  ","permalink":"https://0x1feb.github.io/posts/2022/12/18/bit-full-search/","summary":"2のべき乗で求められる組み合わせを全探索する方法として、bit 全探索という方法がある。 例えば、 $n$ 人が「立っている」または「座っている」のどち","title":"bit 全探索"},{"content":"概要 AtCoder で std::map を使うときのメモ書き。\n基本 map  キーに設定した値の昇順にソートされる。  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { map\u0026lt;int, int\u0026gt; mp; mp[5] = 10; mp[1] = 3; mp[4] = 6; for (auto p : mp) { printf(\u0026#34;key:%d, value:%d\\n\u0026#34;, p.first, p.second); } return 0; } key:1, value:3 key:4, value:6 key:5, value:10 unorderd_map  ソートされないため、 map よりも高速に動作する。  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { unordered_map\u0026lt;int, int\u0026gt; mp; mp[5] = 10; mp[1] = 3; mp[4] = 6; for (auto p : mp) { printf(\u0026#34;key:%d, value:%d\\n\u0026#34;, p.first, p.second); } return 0; } key:4, value:6 key:1, value:3 key:5, value:10 キーの検索 find  find でキーを指定すると、該当する場合はイテレータを返す。 該当しない場合は末尾のイテレータを返す。  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { map\u0026lt;int, int\u0026gt; mp; mp[5] = 10; mp[1] = 3; mp[4] = 6; auto f = [](map\u0026lt;int, int\u0026gt; mp, int x) { auto it = mp.find(x); if (it == mp.end()) { cout \u0026lt;\u0026lt; \u0026#34;該当なし。\u0026#34; \u0026lt;\u0026lt; endl; return; } cout \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; endl; }; // 対象キーが存在しない場合  f(mp, 0); // 対象キーが存在する場合  f(mp, 4); return 0; } 該当なし。 4, 6 二分探索(lower_bound/upper_bound) lower_bound  指定したキー \u0026lt;= x となる最小のキー x を持つイテレータを返す。 該当する x が存在しない場合、末尾のイテレータを返す。  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { map\u0026lt;int, int\u0026gt; mp; mp[5] = 10; mp[1] = 3; mp[4] = 6; auto f = [](map\u0026lt;int, int\u0026gt; mp, int x) { auto it = mp.lower_bound(x); if (it == mp.end()) { cout \u0026lt;\u0026lt; \u0026#34;該当なし。\u0026#34; \u0026lt;\u0026lt; endl; return; } cout \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; endl; }; f(mp, 3); f(mp, 4); f(mp, 5); f(mp, 6); return 0; } 4, 6 4, 6 5, 10 該当なし。 upper_bound  指定したキー \u0026lt; x となる最小のキー x を持つイテレータを返す。 該当する x が存在しない場合、末尾のイテレータを返す。  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { map\u0026lt;int, int\u0026gt; mp; mp[5] = 10; mp[1] = 3; mp[4] = 6; auto f = [](map\u0026lt;int, int\u0026gt; mp, int x) { auto it = mp.upper_bound(x); if (it == mp.end()) { cout \u0026lt;\u0026lt; \u0026#34;該当なし。\u0026#34; \u0026lt;\u0026lt; endl; return; } cout \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; endl; }; f(mp, 3); f(mp, 4); f(mp, 5); f(mp, 6); return 0; } 4, 6 5, 10 該当なし。 該当なし。 ","permalink":"https://0x1feb.github.io/posts/2022/10/26/cpp-map-memo/","summary":"概要 AtCoder で std::map を使うときのメモ書き。 基本 map キーに設定した値の昇順にソートされる。 #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { map\u0026lt;int, int\u0026gt; mp; mp[5] = 10; mp[1] = 3; mp[4] = 6; for (auto p : mp) { printf(\u0026#34;key:%d, value:%d\\n\u0026#34;, p.first, p.second); } return 0;","title":"C++ の std::map メモ"},{"content":"やりたいこと 単体のリストではない複数の要素に、同じ処理を適用したい。\n複数のリストや要素を一時的にまとめた Stream を作成し、一括で処理したい。\npublic class User { private String name; private int age; public User(String name, int age) { this.name = name; this.age = age; } // getter と setter は省略  public String toString() { return \u0026#34;name: \u0026#34; + name + \u0026#34;, age: \u0026#34; + age; } } 以下のリスト1とリスト2をまとめたり、リスト1と単体の要素1をまとめたりして処理する。\n// リスト1 List\u0026lt;User\u0026gt; userList1 = new ArrayList\u0026lt;User\u0026gt;(); userList1.add(new User(\u0026#34;John\u0026#34;, 40)); userList1.add(new User(\u0026#34;Paul\u0026#34;, 79)); userList1.add(new User(\u0026#34;George\u0026#34;, 58)); userList1.add(new User(\u0026#34;Ringo\u0026#34;, 81)); // リスト2 List\u0026lt;User\u0026gt; userList2 = new ArrayList\u0026lt;User\u0026gt;(); userList2.add(new User(\u0026#34;Albert\u0026#34;, 76)); userList2.add(new User(\u0026#34;Richard\u0026#34;, 69)); // 単体の要素1 User user1 = new User(\u0026#34;Tanaka\u0026#34;, 36); // 単体の要素2 User user2 = new User(\u0026#34;Suzuki\u0026#34;, 74); 単体の要素同士 Stream.of に要素を列挙して Stream を作成する。\nStream.of(user1, user2) .forEach(System.out::println); // name: Tanaka, age: 36 // name: Suzuki, age: 74 リスト同士 Stream.of でリストをまとめると、リスト単位で処理する。\nStream.of(userList1, userList2) .forEach(System.out::println); // [name: John, age: 40, name: Paul, age: 79, name: George, age: 58, name: Ringo, age: 81] // [name: Albert, age: 76, name: Richard, age: 69] リスト内の要素単位で処理する場合は、flatMap を用いる。\nStream.of(userList1, userList2) .flatMap(Collection::stream) .forEach(System.out::println); // name: John, age: 40 // name: Paul, age: 79 // name: George, age: 58 // name: Ringo, age: 81 // name: Albert, age: 76 // name: Richard, age: 69 各リストを Stream に変換し、均した新しい Stream を返ため、各要素単位で処理できる。\n単体の要素とリスト リストと単体の要素を個別に Stream に変換し、Stream.concat でまとめた Stream を作成する。\nStream.concat(userList1.stream(), Stream.of(user1)) .forEach(System.out::println); // name: John, age: 40 // name: Paul, age: 79 // name: George, age: 58 // name: Ringo, age: 81 // name: Tanaka, age: 36 ","permalink":"https://0x1feb.github.io/posts/2022/01/27/combining-multi-elements-in-java-stream/","summary":"やりたいこと 単体のリストではない複数の要素に、同じ処理を適用したい。 複数のリストや要素を一時的にまとめた Stream を作成し、一括で処理したい。 public class User","title":"複数の要素を Stream でまとめる"},{"content":"Stream とは Java 8 から追加され、コレクションに対する集約操作をサポートした機能を持つ。\n中間操作と終端操作を組み合わせてパイプラインにできるため、for 文による繰り返し処理を簡潔に記述できる。\nサンプルクラス User クラス 年齢と名前の情報のみを持つ、以下のユーザクラスを用いる。\npublic class User { private String name; private int age; public User(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String toString() { return \u0026#34;name: \u0026#34; + name + \u0026#34;, age: \u0026#34; + age; } } User のコレクション コレクションは以下とする。\nList\u0026lt;User\u0026gt; userList = new ArrayList\u0026lt;User\u0026gt;(); userList.add(new User(\u0026#34;John\u0026#34;, 40)); userList.add(new User(\u0026#34;Paul\u0026#34;, 79)); userList.add(new User(\u0026#34;George\u0026#34;, 58)); userList.add(new User(\u0026#34;Ringo\u0026#34;, 81)); 要素を順番に処理 forEach userList.stream() .forEach(u -\u0026gt; System.out.println(u)); // name: John, age: 40 // name: Paul, age: 79 // name: George, age: 58 // name: Ringo, age: 81  // 以下も同じ結果 userList.stream() .forEach(System.out::println); ラムダ式を受け取るが、別のメソッドをそのまま呼び出す場合、メソッドのみを渡すこともできる。\n順次/並列 stream ストリームは明示的に並列を指定しない限り、順次で実行される。\n// stream userList.stream() .forEach(System.out::println); // name: John, age: 40 // name: Paul, age: 79 // name: George, age: 58 // name: Ringo, age: 81 parallelStream 並列で実行する場合は、並列のストリームを生成する必要がある。\n// parallelStream userList.parallelStream() .forEach(System.out::println); // name: George, age: 58 // name: Ringo, age: 81 // name: John, age: 40 // name: Paul, age: 79 絞り込み filter 与えられたラムダ式が true となる要素から構成された stream を返す。\n// 60歳未満のみ出力 userList.stream() .filter(u -\u0026gt; u.getAge() \u0026lt; 60) .forEach(System.out::println); // name: John, age: 40 // name: George, age: 58 加工 map 与えられたラムダ式で加工した結果から構成される stream を返す。\n// \u0026#34;My name is XX\u0026#34; の文字列に加工して出力 userList.stream() .map(u -\u0026gt; \u0026#34;My name is\u0026#34; + u.getName()) .forEach(System.out::println); // My name isJohn // My name isPaul // My name isGeorge // My name isRingo スキップ skip 先頭から n 番目の要素を除いた stream を返す。\nuserList.stream() .skip(2) .forEach(System.out::println); // name: George, age: 58 // name: Ringo, age: 81 この例の場合、John と Paul の2人がスキップされている。\n要素数の制限 limit 指定した要素数の stream を返す。\nuserList.stream() .limit(2) .forEach(System.out::println); // name: John, age: 40 // name: Paul, age: 79 並べ替え sorted 指定したルールでソートした stream を返す。\n// 年齢の昇順 userList.stream() .sorted(Comparator.comparing(User::getAge)) .forEach(System.out::println); // name: John, age: 40 // name: George, age: 58 // name: Paul, age: 79 // name: Ringo, age: 81  // 年齢の降順 userList.stream() .sorted(Comparator.comparing(User::getAge).reversed()) .forEach(System.out::println); // name: Ringo, age: 81 // name: Paul, age: 79 // name: George, age: 58 // name: John, age: 40 条件判定 anyMatch // いずれかの要素が指定した条件を満たせば true boolean anyMatch = userList.stream() .anyMatch(u -\u0026gt; u.getAge() \u0026lt; 60); System.out.println(anyMatch); // true allMatch // 全ての要素が指定した条件を満たせば true boolean allMatch = userList.stream() .anyMatch(u -\u0026gt; u.getAge() \u0026lt; 60); System.out.println(allMatch); // false noneMatch // 全ての要素が指定した条件を満たさなければ true boolean noneMatch = userList.stream() .noneMatch(u -\u0026gt; u.getName().equals(\u0026#34;Pete\u0026#34;)); System.out.println(noneMatch); 先頭の要素を取得 findFirst Optional 型を返すので、orElse などが必要となる。\nUser user = userList.stream() .findFirst() .orElse(null); System.out.println(user); 集計 max // 年齢が最大のユーザ User maxAgeUser = userList.stream() .max(Comparator.comparing(User::getAge)) .orElse(null); System.out.println(maxAgeUser); // name: Ringo, age: 81 min // 年齢が最小のユーザ User minAgeUser = userList.stream() .min(Comparator.comparing(User::getAge)) .orElse(null); System.out.println(minAgeUser); // name: John, age: 40 count // 要素の個数 long count = userList.stream() .count(); System.out.println(count); // 4 average // 年齢の平均 double average = userList.stream() .mapToInt(User::getAge) .average() .orElse(0); System.out.println(average); // 64.5 sum // 年齢の合計 int sum = userList.stream() .mapToInt(User::getAge) .sum(); System.out.println(sum); // 258 値をまとめる reduce // 全員の名前をカンマ区切りで並べた文字列を取得 String result = userList.stream() .map(User::getName) .reduce((res, u) -\u0026gt; res += \u0026#34;, \u0026#34; + u) .orElse(\u0026#34;\u0026#34;); System.out.println(result); // John, Paul, George, Ringo ","permalink":"https://0x1feb.github.io/posts/2022/01/24/java-stream-memo/","summary":"Stream とは Java 8 から追加され、コレクションに対する集約操作をサポートした機能を持つ。 中間操作と終端操作を組み合わせてパイプラインにできるため、fo","title":"Java の Stream メモ"},{"content":"hello, world main() { printf(\u0026#34;hello, world\\n\u0026#34;); } ","permalink":"https://0x1feb.github.io/posts/2022/01/21/hello-world/","summary":"hello, world main() { printf(\u0026#34;hello, world\\n\u0026#34;); } ","title":"hello, world"}]